From 5954c794aee824ef85ee9dc22efeadf16d6f3ab2 Mon Sep 17 00:00:00 2001
From: John Crispin <john@phrozen.org>
Date: Sat, 24 Oct 2020 17:00:54 +0200
Subject: [PATCH 23/26] mac80211: add TIP tweaks

Signed-off-by: John Crispin <john@phrozen.org>
---
 .../mac80211/files/lib/wifi/mac80211.sh       |  6 --
 .../patches/subsys/130-disable-fils.patch     | 32 ---------
 .../mac80211/patches/subsys/800-oom.patch     | 71 +++++++++++++++++++
 3 files changed, 71 insertions(+), 38 deletions(-)
 delete mode 100644 package/kernel/mac80211/patches/subsys/130-disable-fils.patch
 create mode 100644 package/kernel/mac80211/patches/subsys/800-oom.patch

diff --git a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
index c0fbfbe5a8..453ac7d847 100644
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
@@ -106,12 +106,6 @@ detect_mac80211() {
 			${ht_capab}
 			set wireless.radio${devidx}.disabled=1
 
-			set wireless.default_radio${devidx}=wifi-iface
-			set wireless.default_radio${devidx}.device=radio${devidx}
-			set wireless.default_radio${devidx}.network=lan
-			set wireless.default_radio${devidx}.mode=ap
-			set wireless.default_radio${devidx}.ssid=OpenWrt
-			set wireless.default_radio${devidx}.encryption=none
 EOF
 		uci -q commit wireless
 
diff --git a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch b/package/kernel/mac80211/patches/subsys/130-disable-fils.patch
deleted file mode 100644
index 9c6e971f9d..0000000000
--- a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-Disable FILS support, since it pulls in crypto hash support
-
---- a/net/mac80211/fils_aead.h
-+++ b/net/mac80211/fils_aead.h
-@@ -7,7 +7,7 @@
- #ifndef FILS_AEAD_H
- #define FILS_AEAD_H
- 
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- int fils_encrypt_assoc_req(struct sk_buff *skb,
- 			   struct ieee80211_mgd_assoc_data *assoc_data);
- int fils_decrypt_assoc_resp(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/fils_aead.c
-+++ b/net/mac80211/fils_aead.c
-@@ -1,4 +1,4 @@
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- // SPDX-License-Identifier: GPL-2.0-only
- /*
-  * FILS AEAD for (Re)Association Request/Response frames
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -591,7 +591,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 			   NL80211_FEATURE_MAC_ON_CREATE |
- 			   NL80211_FEATURE_USERSPACE_MPM |
- 			   NL80211_FEATURE_FULL_AP_CLIENT_STATE;
--#if LINUX_VERSION_IS_GEQ(4,3,0)
-+#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_STA);
- #endif
- 	wiphy_ext_feature_set(wiphy,
diff --git a/package/kernel/mac80211/patches/subsys/800-oom.patch b/package/kernel/mac80211/patches/subsys/800-oom.patch
new file mode 100644
index 0000000000..401a8bf324
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/800-oom.patch
@@ -0,0 +1,71 @@
+From a8295e2c06e1aa313b4624df9dedf599df382eef Mon Sep 17 00:00:00 2001
+From: Ben Greear <greearb@candelatech.com>
+Date: Thu, 9 May 2013 11:56:22 -0700
+Subject: mac80211: Limit number of pending skbs.
+
+Current code will allow any number of pending skbs, and
+this can OOM the system when used with something like
+the pktgen tool (which may not back off properly if
+queue is stopped).
+
+Possibly this is just a bug in our version of pktgen,
+but either way, it seems reasonable to add a limit
+so that it is not possible to go OOM in this manner.
+
+Signed-off-by: Ben Greear <greearb@candelatech.com>
+
+diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
+index 3529d1368068..5eb60a50641e 100644
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -35,6 +35,17 @@
+ #include "wpa.h"
+ #include "wme.h"
+ #include "rate.h"
++#include <linux/moduleparam.h>
++
++/*
++ * Maximum number of skbs that may be queued in a pending
++ * queue.  After that, packets will just be dropped.
++ */
++static int max_pending_qsize = 1000;
++module_param(max_pending_qsize, int, 0644);
++MODULE_PARM_DESC(max_pending_qsize,
++		 "Maximum number of skbs that may be queued in a pending queue.");
++
+ 
+ /* misc utils */
+ 
+@@ -1671,15 +1682,28 @@ static bool ieee80211_tx_frags(struct ieee80211_local *local,
+ 				 * later transmission from the tx-pending
+ 				 * tasklet when the queue is woken again.
+ 				 */
+-				if (txpending)
++				bool do_free = false;
++				if (txpending) {
+ 					skb_queue_splice_init(skbs,
+ 							      &local->pending[q]);
+-				else
+-					skb_queue_splice_tail_init(skbs,
+-								   &local->pending[q]);
++				} else {
++					u32 len = skb_queue_len(&local->pending[q]);
++					if (len >= max_pending_qsize) {
++						__skb_unlink(skb, skbs);
++						do_free = true;
++					} else {
++						skb_queue_splice_tail_init(skbs,
++									   &local->pending[q]);
++					}
++				}
+ 
+ 				spin_unlock_irqrestore(&local->queue_stop_reason_lock,
+ 						       flags);
++				if (do_free) {
++					dev_kfree_skb_any(skb);
++					/* TODO:  Add counter for this */
++				}
++
+ 				return false;
+ 			}
+ 		}
-- 
2.25.1

