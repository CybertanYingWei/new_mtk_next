From bdfa30d3292a2d17ef80de2d3e419dc8aeedecbe Mon Sep 17 00:00:00 2001
From: Venkat Chimata <venkata@shasta.cloud>
Date: Wed, 14 Dec 2022 18:22:09 +0530
Subject: [PATCH] Support multiple Hostapd_data interfaces for radius das

Signed-off-by: Venkat Chimata <venkata@shasta.cloud>
---
 src/radius/radius_das.c | 43 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 42 insertions(+), 1 deletion(-)

diff --git a/src/radius/radius_das.c b/src/radius/radius_das.c
index 17dc3d2..9c25cfa 100644
--- a/src/radius/radius_das.c
+++ b/src/radius/radius_das.c
@@ -8,6 +8,7 @@
 
 #include "includes.h"
 #include <net/if.h>
+#include <pthread.h>
 
 #include "utils/common.h"
 #include "utils/eloop.h"
@@ -30,6 +31,9 @@ struct radius_das_data {
 	enum radius_das_res (*coa)(void *ctx, struct radius_das_attrs *attr);
 };
 
+#define MAX_HAPDS 16
+static void* hapd_data_ctx[MAX_HAPDS];
+pthread_mutex_t das_sock_lock = PTHREAD_MUTEX_INITIALIZER;
 
 static struct radius_msg * radius_das_disconnect(struct radius_das_data *das,
 						 struct radius_msg *msg,
@@ -38,6 +42,8 @@ static struct radius_msg * radius_das_disconnect(struct radius_das_data *das,
 {
 	struct radius_hdr *hdr;
 	struct radius_msg *reply;
+	int i;
+
 	u8 allowed[] = {
 		RADIUS_ATTR_USER_NAME,
 		RADIUS_ATTR_NAS_IP_ADDRESS,
@@ -146,7 +152,14 @@ static struct radius_msg * radius_das_disconnect(struct radius_das_data *das,
 		attrs.cui_len = len;
 	}
 
-	res = das->disconnect(das->ctx, &attrs);
+	for(i = 0; i < MAX_HAPDS; i++) {
+		if (hapd_data_ctx[i] != NULL) {
+			res = das->disconnect(hapd_data_ctx[i], &attrs);
+			if (res == RADIUS_DAS_SUCCESS) {
+				break;
+			}
+		}
+	}
 	switch (res) {
 	case RADIUS_DAS_NAS_MISMATCH:
 		wpa_printf(MSG_INFO, "DAS: NAS mismatch from %s:%d",
@@ -538,11 +551,29 @@ struct radius_das_data *
 radius_das_init(struct radius_das_conf *conf)
 {
 	struct radius_das_data *das;
+	int i;
+	int exists = 0;
 
 	if (conf->port == 0 || conf->shared_secret == NULL ||
 	    conf->client_addr == NULL)
 		return NULL;
 
+	pthread_mutex_lock(&das_sock_lock);
+	for(i = 0; i < MAX_HAPDS; i++) {
+		if(conf->ctx == hapd_data_ctx[i]) {
+			break;
+		}
+	}
+	if (!exists) {
+		for(i = 0; i < MAX_HAPDS; i++) {
+			if (hapd_data_ctx[i] == NULL) {
+				hapd_data_ctx[i] = conf->ctx;
+				break;
+			}	
+		}
+	}
+	pthread_mutex_unlock(&das_sock_lock);
+
 	das = os_zalloc(sizeof(*das));
 	if (das == NULL)
 		return NULL;
@@ -585,6 +616,8 @@ radius_das_init(struct radius_das_conf *conf)
 
 void radius_das_deinit(struct radius_das_data *das)
 {
+	int i;
+
 	if (das == NULL)
 		return;
 
@@ -592,6 +625,14 @@ void radius_das_deinit(struct radius_das_data *das)
 		eloop_unregister_read_sock(das->sock);
 		close(das->sock);
 	}
+	pthread_mutex_lock(&das_sock_lock);
+	for(i = 0; i < MAX_HAPDS; i++) {
+		if(das->ctx == hapd_data_ctx[i]) {
+			hapd_data_ctx[i] = NULL;
+			break;
+		}
+	}
+	pthread_mutex_unlock(&das_sock_lock);
 
 	os_free(das->shared_secret);
 	os_free(das);
-- 
2.34.1

