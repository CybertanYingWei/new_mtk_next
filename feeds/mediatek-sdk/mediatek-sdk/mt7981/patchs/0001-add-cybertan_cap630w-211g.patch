--- a/target/linux/mediatek/image/filogic.mk	2023-12-19 15:45:53.724800843 +0800
+++ b/target/linux/mediatek/image/filogic.mk	2023-12-18 16:20:33.260414869 +0800
@@ -598,3 +598,35 @@ define Device/zyxel_nwa50ax-pro
   IMAGE/sysupgrade.bin := sysupgrade-tar | append-metadata
 endef
 TARGET_DEVICES += zyxel_nwa50ax-pro
+
+define Device/cybertan_cap630w_211g
+  DEVICE_VENDOR := CYBERTAN
+  DEVICE_MODEL := CAP630W-211G
+  DEVICE_DTS := mt7981b-cybertan-cap630w-211g
+  DEVICE_DTS_DIR := ../dts
+  DEVICE_DTC_FLAGS := --pad 4096
+  DEVICE_DTS_LOADADDR := 0x43f00000
+  SUPPORTED_DEVICES := cybertan,cap630w-211g
+  DEVICE_PACKAGES := kmod-mt7981-firmware mt7981-wo-firmware kmod-usb3 \
+	e2fsprogs f2fsck mkf2fs
+  KERNEL_LOADADDR := 0x44000000
+  KERNEL := kernel-bin | lzma | \
+	  fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb
+  KERNEL_INITRAMFS := kernel-bin | lzma | \
+	fit lzma $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb with-initrd | pad-to 64k
+  KERNEL_INITRAMFS_SUFFIX := -recovery.itb
+  KERNEL_IN_UBI := 1
+  ROOTFSNAME_IN_UBI := rootfs
+  UBOOTENV_IN_UBI := 1
+  IMAGES := sysupgrade.tar
+  IMAGE_SIZE := $$(shell expr 64 + $$(CONFIG_TARGET_ROOTFS_PARTSIZE))m
+  IMAGE/sysupgrade.itb := append-kernel | \
+	 fit gzip $$(KDIR)/image-$$(firstword $$(DEVICE_DTS)).dtb external-static-with-rootfs | \
+	 pad-rootfs | append-metadata
+  IMAGE/sysupgrade.tar := sysupgrade-tar | append-metadata
+  ARTIFACTS := \
+	nand-preloader.bin nand-bl31-uboot.fip
+  ARTIFACT/nand-preloader.bin := mt7981-bl2 spim-nand-ddr4
+  ARTIFACT/nand-bl31-uboot.fip := mt7981-bl31-uboot cybertan_cap630w_211g-nand
+endef
+TARGET_DEVICES += cybertan_cap630w_211g

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/mediatek/dts/mt7981b-cybertan-cap630w-211g.dts	2023-12-18 17:24:03.154722211 +0800
@@ -0,0 +1,573 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR MIT
+
+/dts-v1/;
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/gpio.h>
+
+#include "mt7981.dtsi"
+
+/ {
+	aliases {
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory {
+		reg = <0 0x40000000 0 0x10000000>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			gpios = <&pio 1 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+
+		mesh {
+			label = "mesh";
+			gpios = <&pio 0 GPIO_ACTIVE_LOW>;
+			linux,code = <BTN_9>;
+			linux,input-type = <EV_SW>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led_blue {
+			label = "sys:blue";
+			gpios = <&pio 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "timer";
+			active-delay = <500>;
+			inactive-delay = <500>;
+			default-state="on";
+		};
+
+		led_green {
+			label = "sys:green";
+			gpios = <&pio 24 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "timer";
+			active-delay = <500>;
+			inactive-delay = <500>;
+			default-state="on";
+		};
+
+		led_red {
+			label = "sys:red";
+			gpios = <&pio 25 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "timer";
+			active-delay = <500>;
+			inactive-delay = <500>;
+			default-state="on";
+		};
+	};
+};
+
+&eth {
+	status = "okay";
+
+	gmac0: mac@0 {
+		compatible = "mediatek,eth-mac";
+		reg = <0>;
+		phy-mode = "2500base-x";
+
+		nvmem-cells = <&macaddr_factory_4>;
+		nvmem-cell-names = "mac-address";
+		mac-address-increment = <(-1)>;
+
+		fixed-link {
+			speed = <2500>;
+			full-duplex;
+			pause;
+		};
+	};
+	
+	gmac1: mac@1 {
+		compatible = "mediatek,eth-mac";
+		reg = <1>;
+		phy-mode = "gmii";
+		phy-handle = <&phy0>;
+	};	
+	
+};
+
+&mdio_bus {
+	phy0: ethernet-phy@0 {
+		compatible = "ethernet-phy-id03a2.9461";
+		reg = <0>;
+		phy-mode = "gmii";
+		nvmem-cells = <&phy_calibration>;
+		nvmem-cell-names = "phy-cal-data";
+	};
+	switch: switch@0 {
+		compatible = "mediatek,mt7531";
+		reg = <31>;
+		reset-gpios = <&pio 39 GPIO_ACTIVE_HIGH>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupt-parent = <&pio>;
+		interrupts = <38 IRQ_TYPE_LEVEL_HIGH>;
+	};
+};
+
+&switch {
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			label = "lan1";
+		};
+
+		port@1 {
+			reg = <1>;
+			label = "lan2";
+		};
+
+		port@2 {
+			reg = <2>;
+			label = "lan3";
+		};
+
+		port@6 {
+			reg = <6>;
+			label = "cpu";
+			ethernet = <&gmac0>;
+			phy-mode = "2500base-x";
+
+			fixed-link {
+				speed = <2500>;
+				full-duplex;
+				pause;
+			};
+		};
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_flash_pins>;
+	status = "okay";
+
+	spi_nand: flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-nand";
+		reg = <0>;
+
+		spi-max-frequency = <52000000>;
+		spi-tx-buswidth = <4>;
+		spi-rx-buswidth = <4>;
+
+		partitions: partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "BL2";
+				reg = <0x00 0x100000>;
+				read-only;
+			};
+
+			partition@100000 {
+				label = "u-boot-env";
+				reg = <0x0100000 0x0080000>;
+			};
+
+			factory: partition@180000 {
+				label = "Factory";
+				reg = <0x180000 0x200000>;
+				read-only;
+
+				compatible = "nvmem-cells";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				macaddr_factory_4: macaddr@4 {
+					reg = <0x4 0x6>;
+				};
+			};
+
+			partition@380000 {
+				label = "FIP";
+				reg = <0x380000 0x200000>;
+				read-only;
+			};
+
+			partition@580000 {
+				label = "ubi";
+				reg = <0x580000 0x6000000>;
+			};
+
+			partition@7580000 {
+				label = "devinfo";
+				reg = <0x6580000 0x00080000>;
+			};
+
+			partition@7600000 {
+				label ="certificates";
+				reg = <0x6600000 0x00080000>;
+			};
+		};
+	};
+};
+
+&pio {
+	i2c_pins: i2c-pins-g0 {
+		mux {
+			function = "i2c";
+			groups = "i2c0_1";
+		};
+	};
+	spi0_flash_pins: spi0-pins {
+		mux {
+			function = "spi";
+			groups = "spi0", "spi0_wp_hold";
+		};
+
+		conf-pu {
+			pins = "SPI0_CS", "SPI0_HOLD", "SPI0_WP";
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-up = <MTK_PUPD_SET_R1R0_11>;
+		};
+
+		conf-pd {
+			pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO";
+			drive-strength = <MTK_DRIVE_8mA>;
+			bias-pull-down = <MTK_PUPD_SET_R1R0_11>;
+		};
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c_pins>;
+	status = "okay";
+
+	tps23861@20 {
+		compatible = "ti,tps23861";
+		reg = <0x20>;
+		shunt-resistor-micro-ohms = <255000>;
+
+		port@0 {
+			reg = <0>;
+			mode = "auto";
+			enable = <1>;
+			power = <1>;
+			poe_plus = <1>;
+		};
+
+		port@1 {
+			reg = <1>;
+			mode = "off";
+			enable = <0>;
+			power = <0>;
+			poe_plus = <0>;
+		};
+
+
+		port@2 {
+			reg = <2>;
+			mode = "off";
+			enable = <0>;
+			power = <0>;
+			poe_plus = <0>;
+		};
+
+
+		port@3 {
+			reg = <3>;
+			mode = "off";
+			enable = <0>;
+			power = <0>;
+			poe_plus = <0>;
+		};
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	mediatek,mtd-eeprom = <&factory 0x0>;
+
+	power-limits {
+		r0 {
+			regdomain = "fcc";
+			txpower-2g {
+				r0 {
+					channels = <1 1>;
+					txs-delta = <0 0 0>;
+					rates-cck = <38 38 38 38>;
+					rates-ofdm = <37 37 37 37 37 37 37 37>;
+					rates-mcs =
+					<1 36 36 36 36 36 36 36 36 34 33>,
+					<3 34 34 34 34 34 34 34 34 34 33>;
+					rates-ru =
+					<4 36 36 36 36 36 36 36 36 34 33 32 32>,
+					<3 34 34 34 34 34 34 34 34 34 33 32 32>;
+				};
+				r1 {
+					channels = <2 3>;
+					txs-delta = <0 0 0>;
+					rates-cck = <38 38 38 38>;
+					rates-ofdm = <38 38 38 38 38 38 38 37>;
+					rates-mcs =
+					<1 38 38 38 38 38 38 37 36 34 33>,
+					<3 34 34 34 34 34 34 34 34 34 33>;
+					rates-ru =
+					<4 38 38 38 38 38 38 37 36 34 33 32 32>,
+					<3 34 34 34 34 34 34 34 34 34 33 32 32>;
+				};
+				r2 {
+					channels = <4 8>;
+					txs-delta = <0 0 0>;
+					rates-cck = <38 38 38 38>;
+					rates-ofdm = <38 38 38 38 38 38 38 37>;
+					rates-mcs =
+					<1 38 38 38 38 38 38 37 36 34 33>,
+					<3 36 36 36 36 36 36 36 36 34 33>;
+					rates-ru =
+					<4 38 38 38 38 38 38 37 36 34 33 32 32>,
+					<3 36 36 36 36 36 36 36 36 34 33 32 32>;
+				};
+				r3 {
+					channels = <9 14>;
+					txs-delta = <0 0 0>;
+					rates-cck = <38 38 38 38>;
+					rates-ofdm = <38 38 38 38 38 38 38 37>;
+					rates-mcs =
+					<1 38 38 38 38 38 38 37 36 34 33>,
+					<3 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<4 38 38 38 38 38 38 37 36 34 33 32 32>,
+					<3 32 32 32 32 32 32 32 32 32 32 32 32>;
+				};
+			};
+			txpower-5g {
+				r0 {
+					channels = <184 196>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs =
+					<2 40 40 40 40 40 39 38 36 35 34>,
+					<2 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<5 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r1 {
+					channels = <8 16>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs =
+					<2 40 40 40 40 40 39 38 36 35 34>,
+					<2 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<5 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r2 {
+					channels = <36 40>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs =
+					<1 40 40 40 40 40 39 38 36 35 34>,
+					<1 38 38 38 38 38 38 38 36 35 34>,
+					<2 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<4 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 38 38 38 38 38 38 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r3 {
+					channels = <44 44>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs =
+					<2 40 40 40 40 40 39 38 36 35 34>,
+					<2 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<5 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r4 {
+					channels = <48 48>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <39 39 39 39 39 39 39 38>;
+					rates-mcs =
+					<2 40 40 40 40 40 39 38 36 35 34>,
+					<2 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<5 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r5 {
+					channels = <52 96>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <36 36 36 36 36 36 36 36>;
+					rates-mcs =
+					<3 36 36 36 36 36 36 36 36 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<6 36 36 36 36 36 36 36 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r6 {
+					channels = <100 112>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <36 36 36 36 36 36 36 36>;
+					rates-mcs =
+					<2 36 36 36 36 36 36 36 36 35 34>,
+					<1 35 35 35 35 35 35 35 35 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<5 36 36 36 36 36 36 36 36 35 34 32 32>,
+					<1 35 35 35 35 35 35 35 35 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r7 {
+					channels = <116 144>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <36 36 36 36 36 36 36 36>;
+					rates-mcs =
+					<3 36 36 36 36 36 36 36 36 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<6 36 36 36 36 36 36 36 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r8 {
+					channels = <149 181>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs =
+					<3 40 40 40 40 40 39 38 36 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru =
+					<6 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+			};
+		};
+		r1 {
+			regdomain = "etsi";
+			txpower-2g {
+				r0 {
+					channels = <1 14>;
+					txs-delta = <0 0 0>;
+					rates-cck = <29 29 29 29>;
+					rates-ofdm = <30 30 30 30 30 30 30 30>;
+					rates-mcs = 
+					<4 28 28 28 28 28 28 28 28 28 28>;
+					rates-ru = 
+					<7 28 28 28 28 28 28 28 28 28 28 28 28>;
+				};
+			};
+			txpower-5g {
+				r0 {
+					channels = <184 196>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <33 33 33 33 33 33 33 33>;
+					rates-mcs = 
+					<4 33 33 33 33 33 33 33 33 33 33>;
+					rates-ru = 
+					<6 33 33 33 33 33 33 33 33 33 33 32 32>,
+					<1 33 33 33 33 33 33 33 33 33 33 30 30>;
+				};
+				r1 {
+					channels = <8 16>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <33 33 33 33 33 33 33 33>;
+					rates-mcs = 
+					<4 33 33 33 33 33 33 33 33 33 33>;
+					rates-ru = 
+					<6 33 33 33 33 33 33 33 33 33 33 32 32>,
+					<1 33 33 33 33 33 33 33 33 33 33 30 30>;
+				};
+				r2 {
+					channels = <36 48>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <33 33 33 33 33 33 33 33>;
+					rates-mcs = 
+					<4 33 33 33 33 33 33 33 33 33 33>;
+					rates-ru = 
+					<6 33 33 33 33 33 33 33 33 33 33 32 32>,
+					<1 33 33 33 33 33 33 33 33 33 33 30 30>;
+				};
+				r3 {
+					channels = <52 96>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <33 33 33 33 33 33 33 33>;
+					rates-mcs = 
+					<1 32 32 32 32 32 32 32 32 32 32>,
+					<3 33 33 33 33 33 33 33 33 33 33>;
+					rates-ru = 
+					<4 32 32 32 32 32 32 32 32 32 32 32 32>,
+					<2 33 33 33 33 33 33 33 33 33 33 32 32>,
+					<1 33 33 33 33 33 33 33 33 33 33 30 30>;
+				};
+				r4 {
+					channels = <100 128>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs = 
+					<3 40 40 40 40 40 39 38 36 35 34>,
+					<1 40 40 40 39 39 38 36 35 34 33>;
+					rates-ru = 
+					<6 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 40 40 40 39 39 38 36 35 34 33 30 30>;
+				};
+				r5 {
+					channels = <132 144>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs = 
+					<3 40 40 40 40 40 39 38 36 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru = 
+					<6 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+				r6 {
+					channels = <149 181>;
+					txs-delta = <0 0 0>;
+					rates-ofdm = <40 40 40 40 40 40 39 38>;
+					rates-mcs = 
+					<3 40 40 40 40 40 39 38 36 35 34>,
+					<1 32 32 32 32 32 32 32 32 32 32>;
+					rates-ru = 
+					<6 40 40 40 40 40 39 38 36 35 34 32 32>,
+					<1 32 32 32 32 32 32 32 32 32 32 30 30>;
+				};
+			};
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&watchdog {
+	status = "okay";
+};
+
+
+/ {
+	model = "CYBERTAN CAP630W-211G";
+	compatible = "cybertan,cap630w-211g", "mediatek,mt7981";
+};
+
+


--- a/package/boot/uboot-mediatek/Makefile	2023-12-19 15:45:51.700781623 +0800
+++ b/package/boot/uboot-mediatek/Makefile	2023-12-18 15:10:55.550676315 +0800
@@ -406,6 +406,18 @@ define U-Boot/mt7988_rfb-sd
   DEPENDS:=+trusted-firmware-a-mt7988-sdmmc-comb
 endef
 
+define U-Boot/mt7981_cybertan_cap630w_211g-nand
+  NAME:=CYBERTAN CAP630W-211G
+  BUILD_SUBTARGET:=filogic
+  BUILD_DEVICES:=cybertan_cap630w_211g
+  UBOOT_CONFIG:=mt7981_cybertan_cap630w_211g-nand
+  UBOOT_IMAGE:=u-boot.fip
+  BL2_BOOTDEV:=spim-nand
+  BL2_SOC:=mt7981
+  BL2_DDRTYPE:=ddr4
+  DEPENDS:=+trusted-firmware-a-mt7981-spim-nand-ddr4
+endef
+
 UBOOT_TARGETS := \
 	mt7620_mt7530_rfb \
 	mt7620_rfb \
@@ -427,6 +439,7 @@ UBOOT_TARGETS := \
 	mt7981_h3c_magic-nx30-pro \
 	mt7981_qihoo_360t7 \
 	mt7981_xiaomi_mi-router-wr30u \
+	mt7981_cybertan_cap630w_211g-nand \
 	mt7986_bananapi_bpi-r3-emmc \
 	mt7986_bananapi_bpi-r3-sdmmc \
 	mt7986_bananapi_bpi-r3-snand \
	
--- a/package/boot/arm-trusted-firmware-mediatek/Makefile	2023-12-19 15:45:51.700781623 +0800
+++ b/package/boot/arm-trusted-firmware-mediatek/Makefile	2023-12-18 15:31:21.245778442 +0800
@@ -94,6 +94,14 @@ define Trusted-Firmware-A/mt7622-sdmmc-2ddr
   DDR3_FLYBY:=1
 endef
 
+define Trusted-Firmware-A/mt7981-spim-nand-ddr4
+  NAME:=MediaTek MT7981 (SPI-NAND via SPIM, DDR4)
+  BOOT_DEVICE:=spim-nand
+  BUILD_SUBTARGET:=filogic
+  PLAT:=mt7981
+  DDR_TYPE:=ddr4
+endef
+
 define Trusted-Firmware-A/mt7981-nor-ddr3
   NAME:=MediaTek MT7981 (SPI-NOR, DDR3)
   BOOT_DEVICE:=nor
@@ -349,6 +357,7 @@ TFA_TARGETS:= \
 	mt7981-sdmmc-ddr3 \
 	mt7986-snand-ddr3 \
 	mt7981-spim-nand-ddr3 \
+	mt7981-spim-nand-ddr4 \
 	mt7986-emmc-ddr3 \
 	mt7986-nor-ddr3 \
 	mt7986-sdmmc-ddr3 \

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/package/boot/uboot-mediatek/patches/600-add-cybertan_cap630w_211g.patch	2023-12-18 15:10:37.986671651 +0800
@@ -0,0 +1,405 @@
+--- /dev/null
++++ b/configs/mt7981_cybertan_cap630w_211g-nand_defconfig
+@@ -0,0 +1,175 @@
++CONFIG_ARM=y
++CONFIG_POSITION_INDEPENDENT=y
++CONFIG_ARCH_MEDIATEK=y
++CONFIG_TARGET_MT7981=y
++CONFIG_TEXT_BASE=0x41e00000
++CONFIG_SYS_MALLOC_F_LEN=0x4000
++CONFIG_SYS_HAS_NONCACHED_MEMORY=y
++CONFIG_NR_DRAM_BANKS=1
++CONFIG_DEFAULT_DEVICE_TREE="mt7981-cybertan_cap630w_211g-nand"
++CONFIG_DEFAULT_ENV_FILE="cybertan_cap630w_211g-nand_env"
++CONFIG_DEFAULT_FDT_FILE="mediatek/mt7981-cybertan_cap630w_211g-nand.dtb"
++CONFIG_OF_LIBFDT_OVERLAY=y
++CONFIG_DEBUG_UART_BASE=0x11002000
++CONFIG_DEBUG_UART_CLOCK=40000000
++CONFIG_DEBUG_UART=y
++CONFIG_SYS_LOAD_ADDR=0x46000000
++CONFIG_SMBIOS_PRODUCT_NAME=""
++CONFIG_AUTOBOOT_KEYED=y
++CONFIG_BOOTDELAY=30
++CONFIG_AUTOBOOT_MENU_SHOW=y
++CONFIG_CFB_CONSOLE_ANSI=y
++CONFIG_BOARD_LATE_INIT=y
++CONFIG_BUTTON=y
++CONFIG_BUTTON_GPIO=y
++CONFIG_GPIO_HOG=y
++CONFIG_CMD_ENV_FLAGS=y
++CONFIG_FIT=y
++CONFIG_FIT_ENABLE_SHA256_SUPPORT=y
++CONFIG_LED=y
++CONFIG_LED_BLINK=y
++CONFIG_LED_GPIO=y
++CONFIG_LOGLEVEL=7
++CONFIG_LOG=y
++CONFIG_SYS_PROMPT="MT7981> "
++CONFIG_CMD_BOOTMENU=y
++CONFIG_CMD_BOOTP=y
++CONFIG_CMD_BUTTON=y
++CONFIG_CMD_CACHE=y
++CONFIG_CMD_CDP=y
++CONFIG_CMD_CPU=y
++CONFIG_CMD_DHCP=y
++CONFIG_CMD_DM=y
++CONFIG_CMD_DNS=y
++CONFIG_CMD_ECHO=y
++CONFIG_CMD_ENV_READMEM=y
++CONFIG_CMD_ERASEENV=y
++CONFIG_CMD_EXT4=y
++CONFIG_CMD_FAT=y
++CONFIG_CMD_FDT=y
++CONFIG_CMD_FS_GENERIC=y
++CONFIG_CMD_FS_UUID=y
++CONFIG_CMD_GPIO=y
++CONFIG_CMD_GPT=y
++CONFIG_CMD_HASH=y
++CONFIG_CMD_ITEST=y
++CONFIG_CMD_LED=y
++CONFIG_CMD_LICENSE=y
++CONFIG_CMD_LINK_LOCAL=y
++# CONFIG_CMD_MBR is not set
++CONFIG_CMD_PCI=y
++CONFIG_CMD_PSTORE=y
++CONFIG_CMD_PSTORE_MEM_ADDR=0x42ff0000
++CONFIG_CMD_SF_TEST=y
++CONFIG_CMD_PING=y
++CONFIG_CMD_PXE=y
++CONFIG_CMD_PWM=y
++CONFIG_CMD_SMC=y
++CONFIG_CMD_TFTPBOOT=y
++CONFIG_CMD_TFTPSRV=y
++CONFIG_CMD_UBI=y
++CONFIG_CMD_UBI_RENAME=y
++CONFIG_CMD_UBIFS=y
++CONFIG_CMD_ASKENV=y
++CONFIG_CMD_PART=y
++CONFIG_CMD_RARP=y
++CONFIG_CMD_SETEXPR=y
++CONFIG_CMD_SLEEP=y
++CONFIG_CMD_SNTP=y
++CONFIG_CMD_SOURCE=y
++CONFIG_CMD_STRINGS=y
++CONFIG_CMD_UUID=y
++CONFIG_DISPLAY_CPUINFO=y
++CONFIG_DM_MTD=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_REGULATOR_GPIO=y
++CONFIG_DM_PWM=y
++CONFIG_PWM_MTK=y
++CONFIG_HUSH_PARSER=y
++CONFIG_SYS_REDUNDAND_ENVIRONMENT=y
++CONFIG_SYS_RELOC_GD_ENV_ADDR=y
++CONFIG_VERSION_VARIABLE=y
++CONFIG_PARTITION_UUIDS=y
++CONFIG_NETCONSOLE=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_DM_GPIO=y
++CONFIG_DM_SCSI=y
++CONFIG_AHCI=y
++CONFIG_AHCI_PCI=y
++CONFIG_SCSI_AHCI=y
++CONFIG_SCSI=y
++CONFIG_CMD_SCSI=y
++CONFIG_PHY=y
++CONFIG_PHY_MTK_TPHY=y
++CONFIG_PHY_FIXED=y
++CONFIG_MTK_AHCI=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PCI=y
++# CONFIG_MMC is not set
++# CONFIG_DM_MMC is not set
++CONFIG_MTD=y
++CONFIG_MTD_UBI_FASTMAP=y
++CONFIG_DM_PCI=y
++CONFIG_PCIE_MEDIATEK=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7622=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_PRE_CONSOLE_BUFFER=y
++CONFIG_PRE_CON_BUF_ADDR=0x4007EF00
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_RAM=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_SPI=y
++CONFIG_DM_SPI=y
++CONFIG_MTK_SPI_NAND=y
++CONFIG_MTK_SPI_NAND_MTD=y
++CONFIG_SYSRESET_WATCHDOG=y
++CONFIG_WDT_MTK=y
++CONFIG_LZO=y
++CONFIG_ZSTD=y
++CONFIG_HEXDUMP=y
++CONFIG_RANDOM_UUID=y
++CONFIG_REGEX=y
++CONFIG_OF_EMBED=y
++CONFIG_ENV_OVERWRITE=y
++CONFIG_ENV_IS_IN_UBI=y
++CONFIG_ENV_UBI_PART="ubi"
++CONFIG_ENV_SIZE=0x1f000
++CONFIG_ENV_SIZE_REDUND=0x1f000
++CONFIG_ENV_UBI_VOLUME="ubootenv"
++CONFIG_ENV_UBI_VOLUME_REDUND="ubootenv2"
++CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
++CONFIG_NET_RANDOM_ETHADDR=y
++CONFIG_REGMAP=y
++CONFIG_SYSCON=y
++CONFIG_CLK=y
++CONFIG_PHY_FIXED=y
++CONFIG_DM_ETH=y
++CONFIG_MEDIATEK_ETH=y
++CONFIG_PINCTRL=y
++CONFIG_PINCONF=y
++CONFIG_PINCTRL_MT7981=y
++CONFIG_POWER_DOMAIN=y
++CONFIG_MTK_POWER_DOMAIN=y
++CONFIG_DM_REGULATOR=y
++CONFIG_DM_REGULATOR_FIXED=y
++CONFIG_DM_SERIAL=y
++CONFIG_MTK_SERIAL=y
++CONFIG_HEXDUMP=y
++CONFIG_USE_DEFAULT_ENV_FILE=y
++CONFIG_MTD_SPI_NAND=y
++CONFIG_MTK_SPIM=y
++CONFIG_CMD_MTD=y
++CONFIG_CMD_NAND=y
++CONFIG_CMD_NAND_TRIMFFS=y
++CONFIG_LMB_MAX_REGIONS=64
++CONFIG_USE_IPADDR=y
++CONFIG_IPADDR="192.168.1.1"
++CONFIG_USE_SERVERIP=y
++CONFIG_SERVERIP="192.168.1.254"
+--- /dev/null
++++ b/arch/arm/dts/mt7981-cybertan_cap630w_211g.dtsi
+@@ -0,0 +1,85 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2022 MediaTek Inc.
++ * Author: Sam Shih <sam.shih@mediatek.com>
++ */
++
++/dts-v1/;
++#include "mt7981.dtsi"
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/linux-event-codes.h>
++
++/ {
++	#address-cells = <1>;
++	#size-cells = <1>;
++	model = "CYBERTAN CAP630W-211G";
++	compatible = "mediatek,mt7981", "mediatek,mt7981-rfb";
++
++	chosen {
++		stdout-path = &uart0;
++		tick-timer = &timer0;
++	};
++
++	memory@40000000 {
++		device_type = "memory";
++		reg = <0x40000000 0x20000000>;
++	};
++
++	keys {
++		compatible = "gpio-keys";
++
++		button-reset {
++			label = "reset";
++			linux,code = <KEY_RESTART>;
++			gpios = <&gpio 1 GPIO_ACTIVE_LOW>;
++		};
++
++		button-mesh {
++			label = "mesh";
++			linux,code = <BTN_9>;
++			linux,input-type = <EV_SW>;
++			gpios = <&gpio 0 GPIO_ACTIVE_LOW>;
++		};
++	};
++
++	leds {
++		compatible = "gpio-leds";
++
++		led-0 {
++			label = "green:status";
++			gpios = <&gpio 9 GPIO_ACTIVE_LOW>;
++		};
++
++		led-1 {
++			label = "blue:status";
++			gpios = <&gpio 12 GPIO_ACTIVE_LOW>;
++		};
++
++		led-2 {
++			label = "red:status";
++			gpios = <&gpio 35 GPIO_ACTIVE_LOW>;
++		};
++	};
++};
++
++&eth {
++	status = "okay";
++	mediatek,gmac-id = <0>;
++	phy-mode = "2500base-x";
++	mediatek,switch = "mt7531";
++	reset-gpios = <&gpio 39 GPIO_ACTIVE_HIGH>;
++
++	fixed-link {
++		speed = <2500>;
++		full-duplex;
++	};
++};
++
++&uart0 {
++	mediatek,force-highspeed;
++	status = "okay";
++};
++
++&watchdog {
++	status = "disabled";
++};
+--- /dev/null
++++ b/arch/arm/dts/mt7981-cybertan_cap630w_211g-nand.dts
+@@ -0,0 +1,77 @@
++// SPDX-License-Identifier: GPL-2.0-only
++
++/dts-v1/;
++#include "mt7981-cybertan_cap630w_211g.dtsi"
++
++&pinctrl {
++	spi_flash_pins: spi0-pins-func-1 {
++		mux {
++			function = "flash";
++			groups = "spi0", "spi0_wp_hold";
++		};
++
++		conf-pu {
++			pins = "SPI0_CS", "SPI0_HOLD", "SPI0_WP";
++			drive-strength = <MTK_DRIVE_8mA>;
++			bias-pull-up = <MTK_PUPD_SET_R1R0_00>;
++		};
++
++		conf-pd {
++			pins = "SPI0_CLK", "SPI0_MOSI", "SPI0_MISO";
++			drive-strength = <MTK_DRIVE_8mA>;
++			bias-pull-down = <MTK_PUPD_SET_R1R0_00>;
++		};
++	};
++};
++
++&spi0 {
++	#address-cells = <1>;
++	#size-cells = <0>;
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi_flash_pins>;
++	status = "okay";
++	must_tx;
++	enhance_timing;
++	dma_ext;
++	ipm_design;
++	support_quad;
++	tick_dly = <2>;
++	sample_sel = <0>;
++
++	spi_nand@0 {
++		compatible = "spi-nand";
++		reg = <0>;
++		spi-max-frequency = <52000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "bl2";
++				reg = <0x0 0x100000>;
++			};
++
++			partition@100000 {
++				label = "orig-env";
++				reg = <0x100000 0x80000>;
++			};
++
++			partition@160000 {
++				label = "factory";
++				reg = <0x180000 0x200000>;
++			};
++
++			partition@380000 {
++				label = "fip";
++				reg = <0x380000 0x200000>;
++			};
++
++			partition@580000 {
++				label = "ubi";
++				reg = <0x580000 0x7200000>;
++			};
++		};
++	};
++};
+--- /dev/null
++++ b/cybertan_cap630w_211g-nand_env
+@@ -0,0 +1,56 @@
++ipaddr=192.168.1.1
++serverip=192.168.1.254
++loadaddr=0x46000000
++console=earlycon=uart8250,mmio32,0x11002000 console=ttyS0
++bootconf=config-1#mt7981b-cybertan_cap630w_211g-nand
++bootcmd=if pstore check ; then run boot_recovery ; else run boot_ubi ; fi
++bootdelay=0
++bootfile=openwrt-mediatek-filogic-cybertan_cap630w_211g-initramfs-recovery.itb
++bootfile_bl2=openwrt-mediatek-filogic-cybertan_cap630w_211g-nand-preloader.bin
++bootfile_fip=openwrt-mediatek-filogic-cybertan_cap630w_211g-nand-bl31-uboot.fip
++bootfile_upg=openwrt-mediatek-filogic-cybertan_cap630w_211g-squashfs-sysupgrade.itb
++bootled_pwr=red:status
++bootled_rec=blue:status
++bootmenu_confirm_return=askenv - Press ENTER to return to menu ; bootmenu 60
++bootmenu_default=0
++bootmenu_delay=0
++bootmenu_title=      [0;34m( ( ( [1;39mOpenWrt[0;34m ) ) )  [0;36m[SPI-NAND][0m
++bootmenu_0=Initialize environment.=run _firstboot
++bootmenu_0d=Run default boot command.=run boot_default
++bootmenu_1=Boot system via TFTP.=run boot_tftp ; run bootmenu_confirm_return
++bootmenu_2=Boot production system from NAND.=run boot_production ; run bootmenu_confirm_return
++bootmenu_3=Boot recovery system from NAND.=run boot_recovery ; run bootmenu_confirm_return
++bootmenu_4=Load production system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_production ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_5=Load recovery system via TFTP then write to NAND.=setenv noboot 1 ; setenv replacevol 1 ; run boot_tftp_recovery ; setenv noboot ; setenv replacevol ; run bootmenu_confirm_return
++bootmenu_6=[31mLoad BL31+U-Boot FIP via TFTP then write to NAND.[0m=run boot_tftp_write_fip ; run bootmenu_confirm_return
++bootmenu_7=[31mLoad BL2 preloader via TFTP then write to NAND.[0m=run boot_tftp_write_bl2 ; run bootmenu_confirm_return
++bootmenu_8=Reboot.=reset
++bootmenu_9=Reset all settings to factory defaults.=run reset_factory ; reset
++boot_first=if button reset ; then led $bootled_rec on ; run boot_tftp_recovery ; setenv flag_recover 1 ; run boot_default ; fi ; bootmenu
++boot_default=if env exists flag_recover ; then else run bootcmd ; fi ; run boot_recovery ; setenv replacevol 1 ; run boot_tftp_forever
++boot_production=led $bootled_pwr on ; run ubi_read_production && bootm $loadaddr#$bootconf ; led $bootled_pwr off
++boot_recovery=led $bootled_rec on ; run ubi_read_recovery && bootm $loadaddr#$bootconf ; led $bootled_rec off
++boot_ubi=run boot_production ; run boot_recovery ; run boot_tftp_forever
++boot_tftp_forever=led $bootled_rec on ; while true ; do run boot_tftp_recovery ; sleep 1 ; done
++boot_tftp_production=tftpboot $loadaddr $bootfile_upg && env exists replacevol && iminfo $loadaddr && run ubi_write_production ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp_recovery=tftpboot $loadaddr $bootfile && env exists replacevol && iminfo $loadaddr && run ubi_write_recovery ; if env exists noboot ; then else bootm $loadaddr#$bootconf ; fi
++boot_tftp=tftpboot $loadaddr $bootfile && bootm $loadaddr#$bootconf
++boot_tftp_write_fip=tftpboot $loadaddr $bootfile_fip && run mtd_write_fip && run reset_factory
++boot_tftp_write_bl2=tftpboot $loadaddr $bootfile_bl2 && run mtd_write_bl2
++part_default=production
++part_recovery=recovery
++reset_factory=ubi part ubi ; mw $loadaddr 0x0 0x800 ; ubi write $loadaddr ubootenv 0x800 ; ubi write $loadaddr ubootenv2 0x800
++mtd_write_fip=mtd erase fip && mtd write fip $loadaddr
++mtd_write_bl2=mtd erase bl2 && mtd write bl2 $loadaddr
++ubi_create_env=ubi check ubootenv || ubi create ubootenv 0x100000 dynamic 0 || run ubi_format ; ubi check ubootenv2 || ubi create ubootenv2 0x100000 dynamic 1 || run ubi_format
++ubi_format=ubi detach ; mtd erase ubi && ubi part ubi ; reset
++ubi_prepare_rootfs=if ubi check rootfs_data ; then else if env exists rootfs_data_max ; then ubi create rootfs_data $rootfs_data_max dynamic || ubi create rootfs_data - dynamic ; else ubi create rootfs_data - dynamic ; fi ; fi
++ubi_read_production=ubi read $loadaddr fit && iminfo $loadaddr && run ubi_prepare_rootfs
++ubi_read_recovery=ubi check recovery && ubi read $loadaddr recovery
++ubi_remove_rootfs=ubi check rootfs_data && ubi remove rootfs_data
++ubi_write_production=ubi check fit && ubi remove fit ; run ubi_remove_rootfs ; ubi create fit $filesize dynamic 2 && ubi write $loadaddr fit $filesize
++ubi_write_recovery=ubi check recovery && ubi remove recovery ; run ubi_remove_rootfs ; ubi create recovery $filesize dynamic 3 && ubi write $loadaddr recovery $filesize
++_init_env=setenv _init_env ; run ubi_create_env ; saveenv ; saveenv
++_firstboot=setenv _firstboot ; run _switch_to_menu ; run _init_env ; run boot_first
++_switch_to_menu=setenv _switch_to_menu ; setenv bootdelay 3 ; setenv bootmenu_delay 3 ; setenv bootmenu_0 $bootmenu_0d ; setenv bootmenu_0d ; run _bootmenu_update_title
++_bootmenu_update_title=setenv _bootmenu_update_title ; setenv bootmenu_title "$bootmenu_title       [33m$ver[0m"

--- a/package/kernel/mt76/Makefile	2023-12-19 15:45:51.700781623 +0800
+++ b/package/kernel/mt76/Makefile	2023-12-18 18:27:18.529424950 +0800
@@ -527,6 +527,7 @@
 
 define KernelPackage/mt7981-firmware/install
 	$(INSTALL_DIR) $(1)/lib/firmware/mediatek
+	$(CP) ./files/lib/firmware/mediatek/mt7981_eeprom_mt7976_dbdc.bin $(1)/lib/firmware/mediatek
 	cp \
 		$(PKG_BUILD_DIR)/firmware/mt7981_wa.bin \
 		$(PKG_BUILD_DIR)/firmware/mt7981_wm.bin \

--- a/package/utils/ucode/Makefile	2023-12-19 18:12:39.766678632 +0800
+++ b/package/utils/ucode/Makefile	2023-12-15 16:15:54.092337966 +0800
@@ -12,21 +12,31 @@
 
 PKG_SOURCE_PROTO:=git
 PKG_SOURCE_URL=https://github.com/jow-/ucode.git
-PKG_SOURCE_DATE:=2023-06-06
-PKG_SOURCE_VERSION:=c7d84aae09691a99ae3db427c0b2463732ef84f4
-PKG_MIRROR_HASH:=38826ae70d886d1d7ada3fc6591ac807169aa28107f60f7f2e617520083525fb
+PKG_SOURCE_DATE:=2023-11-07
+PKG_SOURCE_VERSION:=a6e75e02528e36f3610a7f0073453018336def2e
+PKG_MIRROR_HASH:=e1a0f98ba865ed5911d5db3bfca55a2f1b825992bf5f7c7e324928d9412d7ae2
 PKG_MAINTAINER:=Jo-Philipp Wich <jo@mein.io>
 PKG_LICENSE:=ISC
 
-PKG_ABI_VERSION:=20220812
+PKG_ABI_VERSION:=20230711
 
 include $(INCLUDE_DIR)/package.mk
 include $(INCLUDE_DIR)/host-build.mk
 include $(INCLUDE_DIR)/cmake.mk
 
 CMAKE_OPTIONS += -DSOVERSION=$(PKG_ABI_VERSION)
+
+ifeq ($(HOST_OS),Darwin)
+  CMAKE_HOST_OPTIONS += \
+	-DCMAKE_SKIP_RPATH=FALSE \
+	-DCMAKE_MACOSX_RPATH=1 \
+	-DCMAKE_INSTALL_RPATH="${STAGING_DIR_HOSTPKG}/lib"
+else
+  CMAKE_HOST_OPTIONS += \
+	-DSOVERSION=$(PKG_ABI_VERSION)
+endif
+
 CMAKE_HOST_OPTIONS += \
-	-DSOVERSION=$(PKG_ABI_VERSION) \
 	-DFS_SUPPORT=ON \
 	-DMATH_SUPPORT=ON \
 	-DNL80211_SUPPORT=OFF \
@@ -35,7 +45,9 @@
 	-DSTRUCT_SUPPORT=ON \
 	-DUBUS_SUPPORT=OFF \
 	-DUCI_SUPPORT=OFF \
-	-DULOOP_SUPPORT=OFF
+	-DULOOP_SUPPORT=OFF \
+	-DDEBUG_SUPPORT=ON \
+	-DLOG_SUPPORT=OFF
 
 
 define Package/ucode/default
@@ -70,112 +82,32 @@
  The libucode package provides the shared runtime library for the ucode interpreter.
 endef
 
-
-define Package/ucode-mod-fs
-  $(Package/ucode/default)
-  TITLE+= (filesystem module)
-  DEPENDS:=ucode
-endef
-
-define Package/ucode-mod-fs/description
- The filesystem plugin module allows interaction with the local file system.
+# 1: name
+# 2: cmake symbol
+# 3: depends
+# 4: description
+define UcodeModule
+  UCODE_MODULES += ucode-mod-$(strip $(1))
+  CMAKE_OPTIONS += -D$(strip $(2))=$(if $(CONFIG_PACKAGE_ucode-mod-$(strip $(1))),ON,OFF)
+  PKG_CONFIG_DEPENDS += CONFIG_PACKAGE_ucode-mod-$(strip $(1))
+
+ define Package/ucode-mod-$(strip $(1))
+  $(Package/ucode/default)
+  TITLE+= ($(strip $(1)) module)
+  DEPENDS:=+ucode $(3)
+ endef
+
+ define Package/ucode-mod-$(strip $(1))/description
+ $(strip $(4))
+ endef
+
+ define Package/ucode-mod-$(strip $(1))/install
+	$(INSTALL_DIR) $$(1)/usr/lib/ucode
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/$(strip $(1)).so $$(1)/usr/lib/ucode/
+ endef
 endef
 
 
-define Package/ucode-mod-math
-  $(Package/ucode/default)
-  TITLE+= (math module)
-  DEPENDS:=ucode
-endef
-
-define Package/ucode-mod-math/description
- The math plugin provides access to various <math.h> procedures.
-endef
-
-
-define Package/ucode-mod-nl80211
-  $(Package/ucode/default)
-  TITLE+= (nl80211 module)
-  DEPENDS:=ucode +libnl-tiny +libubox +kmod-mac80211
-endef
-
-define Package/ucode-mod-nl80211/description
- The nl80211 plugin provides access to the Linux wireless 802.11 netlink API.
-endef
-
-
-define Package/ucode-mod-resolv
-  $(Package/ucode/default)
-  TITLE+= (resolv module)
-  DEPENDS:=ucode
-endef
-
-define Package/ucode-mod-resolv/description
- The resolv plugin implements simple DNS resolving.
-endef
-
-
-define Package/ucode-mod-rtnl
-  $(Package/ucode/default)
-  TITLE+= (rtnl module)
-  DEPENDS:=ucode +libnl-tiny +libubox
-endef
-
-define Package/ucode-mod-rtnl/description
- The rtnl plugin provides access to the Linux routing netlink API.
-endef
-
-
-define Package/ucode-mod-struct
-  $(Package/ucode/default)
-  TITLE+= (struct module)
-  DEPENDS:=ucode
-endef
-
-define Package/ucode-mod-struct/description
- The struct plugin implements Python 3 compatible struct.pack/unpack functionality.
-endef
-
-
-define Package/ucode-mod-ubus
-  $(Package/ucode/default)
-  TITLE+= (ubus module)
-  DEPENDS:=ucode +libubus +libblobmsg-json
-endef
-
-define Package/ucode-mod-ubus/description
- The ubus module allows ucode template scripts to enumerate and invoke ubus
- procedures.
-endef
-
-
-define Package/ucode-mod-uci
-  $(Package/ucode/default)
-  TITLE+= (uci module)
-  DEPENDS:=ucode +libuci
-endef
-
-define Package/ucode-mod-uci/description
- The uci module allows templates to read and modify uci configuration.
-endef
-
-
-define Package/ucode-mod-uloop
-  $(Package/ucode/default)
-  TITLE+= (uloop module)
-  DEPENDS:=ucode +libubox
-endef
-
-define Package/ucode-mod-uloop/description
- The uloop module allows ucode scripts to interact with OpenWrt uloop event
- loop implementation.
-endef
-
-define Build/Prepare
-	$(Build/Prepare/Default)
-	$(CP) $(STAGING_DIR)/usr/include/mac80211/uapi/linux/nl80211.h $(PKG_BUILD_DIR)/nl80211_copy.h
-endef
-
 define Build/InstallDev
 	$(INSTALL_DIR) $(1)/usr/lib $(1)/usr/include/ucode
 	$(CP) $(PKG_INSTALL_DIR)/usr/include/ucode/*.h $(1)/usr/include/ucode/
@@ -193,60 +125,55 @@
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libucode.so.* $(1)/usr/lib/
 endef
 
-define Package/ucode-mod-fs/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/fs.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-math/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/math.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-nl80211/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/nl80211.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-resolv/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/resolv.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-rtnl/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/rtnl.so $(1)/usr/lib/ucode/
-endef
 
-define Package/ucode-mod-struct/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/struct.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-ubus/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/ubus.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-uci/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/uci.so $(1)/usr/lib/ucode/
-endef
-
-define Package/ucode-mod-uloop/install
-	$(INSTALL_DIR) $(1)/usr/lib/ucode
-	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/lib/ucode/uloop.so $(1)/usr/lib/ucode/
-endef
+$(eval $(call UcodeModule, \
+	debug, DEBUG_SUPPORT, +libubox +libucode, \
+	The debug plugin module provides runtime debugging and introspection facilities.))
+
+$(eval $(call UcodeModule, \
+	fs, FS_SUPPORT, , \
+	The filesystem plugin module allows interaction with the local file system.))
+
+$(eval $(call UcodeModule, \
+	log, LOG_SUPPORT, +libubox, \
+	The log plugin module provides access to the syslog and libubox ulog APIs.))
+
+$(eval $(call UcodeModule, \
+	math, MATH_SUPPORT, , \
+	The math plugin provides access to various <math.h> procedures.))
+
+$(eval $(call UcodeModule, \
+	nl80211, NL80211_SUPPORT, +libnl-tiny +libubox, \
+	The nl80211 plugin provides access to the Linux wireless 802.11 netlink API.))
+
+$(eval $(call UcodeModule, \
+	resolv, RESOLV_SUPPORT, , \
+	The resolv plugin implements simple DNS resolving.))
+
+$(eval $(call UcodeModule, \
+	rtnl, RTNL_SUPPORT, +libnl-tiny +libubox, \
+	The rtnl plugin provides access to the Linux routing netlink API.))
+
+$(eval $(call UcodeModule, \
+	struct, STRUCT_SUPPORT, , \
+	The struct plugin implements Python 3 compatible struct.pack/unpack functionality.))
+
+$(eval $(call UcodeModule, \
+	ubus, UBUS_SUPPORT, +libubus +libblobmsg-json, \
+	The ubus module allows ucode template scripts to enumerate and invoke ubus procedures.))
+
+$(eval $(call UcodeModule, \
+	uci, UCI_SUPPORT, +libuci, \
+	The uci module allows templates to read and modify uci configuration.))
+
+$(eval $(call UcodeModule, \
+	uloop, ULOOP_SUPPORT, +libubox, \
+	The uloop module allows ucode scripts to interact with OpenWrt uloop event loop implementation.))
 
 $(eval $(call BuildPackage,libucode))
 $(eval $(call BuildPackage,ucode))
-$(eval $(call BuildPackage,ucode-mod-fs))
-$(eval $(call BuildPackage,ucode-mod-math))
-$(eval $(call BuildPackage,ucode-mod-nl80211))
-$(eval $(call BuildPackage,ucode-mod-resolv))
-$(eval $(call BuildPackage,ucode-mod-rtnl))
-$(eval $(call BuildPackage,ucode-mod-struct))
-$(eval $(call BuildPackage,ucode-mod-ubus))
-$(eval $(call BuildPackage,ucode-mod-uci))
-$(eval $(call BuildPackage,ucode-mod-uloop))
+
+$(foreach mod,$(UCODE_MODULES), \
+	$(eval $(call BuildPackage,$(mod))))
+
 $(eval $(call HostBuild))

--- a/tools/Makefile
+++ b/tools/Makefile
@@ -68,6 +68,7 @@ tools-y += sstrip
 tools-y += zip
 tools-y += zlib
 tools-y += zstd
+tools-y += crc32sum
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS),y) += liblzo
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_B43_TOOLS),y) += b43-tools
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_BZIP2_TOOLS),y) += bzip2
 
--- a/target/linux/mediatek/filogic/base-files/lib/upgrade/platform.sh
+++ b/target/linux/mediatek/filogic/base-files/lib/upgrade/platform.sh
@@ -84,6 +84,9 @@ platform_do_upgrade() {
 	cudy,wr3000-v1)
 		default_do_upgrade "$1"
 		;;
+        cybertan,cap630w-211g)
+		ubi_do_upgrade "$1"
+		;;
 	mercusys,mr90x-v1)
 		CI_UBIPART="ubi0"
 		nand_do_upgrade "$1"
@@ -127,6 +130,13 @@ platform_check_image() {
 		}
 		return 0
 		;;
+        cybertan,cap630w-211g)
+		[ "$magic" != "73797375" ] && {
+			echo "Invalid image type."
+			return 1
+		}
+		return 0
+		;;
 	*)
 		nand_do_platform_check "$board" "$1"
 		return $?

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/tools/crc32sum/Makefile	2024-01-26 11:05:29.462920960 +0800
@@ -0,0 +1,23 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=crc32sum
+PKG_VERSION:=1.0
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Prepare
+	mkdir -p $(HOST_BUILD_DIR)
+	$(CP) -a ./src/* $(HOST_BUILD_DIR)/
+endef
+
+define Host/Install
+	$(INSTALL_BIN) $(HOST_BUILD_DIR)/crc32sum $(STAGING_DIR_HOST)/bin/
+endef
+
+$(eval $(call HostBuild))

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/tools/crc32sum/src/crc32sum.c	2024-01-26 11:05:29.462920960 +0800
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 MediaTek Inc. All Rights Reserved.
+ *
+ * Author: Weijie Gao <weijie.gao@mediatek.com>
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+
+#ifdef _WIN32
+#include <io.h>
+#include <fcntl.h>
+#define SET_BINARY_MODE(_f)		_setmode(_fileno(_f, O_BINARY)
+#else
+#define SET_BINARY_MODE(_f)		((void)0)
+#endif
+
+#define CRC32_LE_POLY_DEFAULT		0xedb88320
+#define CRC32_BE_POLY_DEFAULT		0x04c11db7
+#define CRC32_TABLE_ITEMS		256
+
+static uint32_t crc32_le_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)(crc ^ *data++)] ^ (crc >> 8);
+
+	return crc;
+}
+
+static void crc32_le_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i;
+
+		for (j = 0; j < 8; j++)
+			v = (v >> 1) ^ ((v & 1) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+static uint32_t crc32_be_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)((crc >> 24) ^ *data++)] ^ (crc << 8);
+
+	return crc;
+}
+
+static void crc32_be_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i << 24;
+
+		for (j = 0; j < 8; j++)
+			v = (v << 1) ^ ((v & (1 << 31)) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+struct crc_funcs {
+	uint32_t poly;
+
+	void (*init)(uint32_t *crc_table, uint32_t poly);
+	uint32_t (*calc)(uint32_t crc, const uint8_t *data, size_t length,
+			 const uint32_t *crc_table);
+};
+
+static const struct crc_funcs crc32_le = {
+	.poly = CRC32_LE_POLY_DEFAULT,
+	.init = crc32_le_init,
+	.calc = crc32_le_calc,
+};
+
+static const struct crc_funcs crc32_be = {
+	.poly = CRC32_BE_POLY_DEFAULT,
+	.init = crc32_be_init,
+	.calc = crc32_be_calc,
+};
+
+static const struct crc_funcs *crc32_algo = &crc32_le;
+static uint32_t crc32_poly;
+static uint32_t crc32_val;
+static const char *input_file;
+static bool output_decimal;
+static bool no_comp;
+
+static void err(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	fprintf(stderr, "Error: ");
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+}
+
+static void usage(FILE *con, const char *progname, int exitcode)
+{
+	const char *prog;
+	size_t len;
+
+	len = strlen(progname);
+	prog = progname + len - 1;
+
+	while (prog > progname) {
+		if (*prog == '\\' || *prog == '/') {
+			prog++;
+			break;
+		}
+
+		prog--;
+	}
+
+	fprintf(con, "CRC32 checksum tool\n");
+	fprintf(con, "\n");
+	fprintf(con, "Usage: %s [options] <input_file>\n", prog);
+	fprintf(con, "\n");
+	fprintf(con, "Options:\n");
+	fprintf(con, "\t-h         display help message\n");
+	fprintf(con, "\t-i <val>   crc value for incremental calculation\n");
+	fprintf(con, "\t           (default is 0)\n");
+	fprintf(con, "\t-p <val>   polynomial for calculation\n");
+	fprintf(con, "\t           (default is 0x%08x for LE, 0x%08x for BE)\n",
+		crc32_le.poly, crc32_be.poly);
+	fprintf(con, "\t-b         use big-endian mode\n");
+	fprintf(con, "\t-n         do not use one's complement\n");
+	fprintf(con, "\t-d         use decimal output\n");
+	fprintf(con, "\n");
+
+	exit(exitcode);
+}
+
+static int parse_args(int argc, char *argv[])
+{
+	int opt;
+
+	static const char *optstring = "i:p:bndh";
+
+	opterr = 0;
+
+	while ((opt = getopt(argc, argv, optstring)) >= 0) {
+		switch (opt) {
+		case 'i':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid crc value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_val = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'p':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid polynomial value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_poly = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'b':
+			crc32_algo = &crc32_be;
+			break;
+
+		case 'n':
+			no_comp = true;
+			break;
+
+		case 'd':
+			output_decimal = true;
+			break;
+
+		case 'h':
+			usage(stdout, argv[0], 0);
+			break;
+
+		default:
+			usage(stderr, argv[0], EXIT_FAILURE);
+		}
+	}
+
+	if (!crc32_poly)
+		crc32_poly = crc32_algo->poly;
+
+	if (optind >= argc)
+		input_file = "-";
+	else
+		input_file = argv[optind];
+
+	if (!input_file[0]) {
+		err("Input file must not be empty\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int crc32_calc(void)
+{
+	uint32_t crc_table[CRC32_TABLE_ITEMS];
+	bool using_stdin = false;
+	uint8_t buf[4096];
+	size_t size;
+	int ret, i;
+	FILE *f;
+
+	if (!strcmp(input_file, "-")) {
+		SET_BINARY_MODE(stdin);
+		using_stdin = true;
+		f = stdin;
+	} else {
+		f = fopen(input_file, "rb");
+	}
+
+	if (!f) {
+		err("Failed to open file '%s'\n", input_file);
+		return -EINVAL;
+	}
+
+	crc32_algo->init(crc_table, crc32_poly);
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	do {
+		size = fread(buf, 1, sizeof(buf), f);
+
+		if (size) {
+			crc32_val = crc32_algo->calc(crc32_val, buf, size,
+						     crc_table);
+		}
+
+		if (size < sizeof(buf)) {
+			ret = ferror(f);
+
+			if (!ret && feof(f))
+				break;
+
+			err("Error while reading file: %d\n", ret);
+			break;
+		}
+	} while (true);
+
+	if (!using_stdin)
+		fclose(f);
+
+	if (ret)
+		return ret;
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	if (output_decimal)
+		printf("%u\n", crc32_val);
+	else
+		printf("%08x\n", crc32_val);
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	if (parse_args(argc, argv))
+		return 1;
+
+	return crc32_calc();
+}

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/tools/crc32sum/src/Makefile	2024-01-26 11:05:29.462920960 +0800
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+all: crc32sum
+
+crc32sum: crc32sum.c
+	$(CC) $(CFLAGS) -O2 -ggdb -MD -o $@ $< $(LDFLAGS)
+
+clean:
+	rm -f crc32sum crc32sum.d
+
+.PHONY: clean
+
+-include crc32sum.d

--- a/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
+++ b/target/linux/mediatek/filogic/base-files/etc/board.d/02_network
@@ -2,11 +2,9 @@
 . /lib/functions.sh
 . /lib/functions/uci-defaults.sh
 . /lib/functions/system.sh
-
 mediatek_setup_interfaces()
 {
 	local board="$1"
-
 	case $board in
 	acer,predator-w6)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 game" eth1
@@ -55,6 +53,9 @@ mediatek_setup_interfaces()
 	tplink,tl-xdr6086)
 		ucidef_set_interfaces_lan_wan "lan1 lan2" eth1
 		;;
+        cybertan,cap630w-211g)
+		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3" eth1
+                ;;
 	xiaomi,mi-router-wr30u-112m-nmbm|\
 	xiaomi,mi-router-wr30u-stock|\
 	xiaomi,mi-router-wr30u-ubootmod|\
@@ -103,6 +104,15 @@ mediatek_setup_macs()
 		wan_mac=$(macaddr_add "$lan_mac" 1)
 		label_mac=$wan_mac
 		;;
+        cybertan,cap630w-211g)
+                mac=$(grep -i -m 1 hw_mac_addr= /dev/`cat /proc/mtd | grep devinfo | cut -d: -f1` | cut -d= -f2)
+                [ -z "$mac" ] && mac="C1:22:44:66:88:00"
+                wan_mac=$(macaddr_canonicalize $mac)
+                lan_mac=$(macaddr_add "$wan_mac" 1)
+                ucidef_set_network_device_mac eth1 $wan_mac
+                ucidef_set_network_device_mac eth0 $lan_mac
+                ucidef_set_label_macaddr $wan_mac
+                ;;
 	xiaomi,mi-router-wr30u-112m-nmbm|\
 	xiaomi,mi-router-wr30u-stock|\
 	xiaomi,mi-router-wr30u-ubootmod|\

--- a/scripts/mkits.sh
+++ b/scripts/mkits.sh
@@ -136,24 +136,22 @@ fi
 
 
 if [ -n "${ROOTFS}" ]; then
-	dd if="${ROOTFS}" of="${ROOTFS}.pagesync" bs=4096 conv=sync
+	ROOTFS_SIZE=$(stat -c %s ${ROOTFS})
+	ROOTFS_SHA1=$(sha1sum ${ROOTFS} | awk '{print "<0x"substr($0,1,8) " 0x"substr($0,9,8) " 0x"substr($0,17,8) " 0x"substr($0,25,8) " 0x"substr($0,33,8) ">"}')
+	ROOTFS_CRC32=$(crc32sum ${ROOTFS})
 	ROOTFS_NODE="
-		rootfs${REFERENCE_CHAR}$ROOTFSNUM {
-			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} rootfs\";
-			${COMPATIBLE_PROP}
-			data = /incbin/(\"${ROOTFS}.pagesync\");
-			type = \"filesystem\";
-			arch = \"${ARCH}\";
-			compression = \"none\";
-			hash${REFERENCE_CHAR}1 {
-				algo = \"crc32\";
-			};
-			hash${REFERENCE_CHAR}2 {
-				algo = \"${HASH}\";
+		rootfs {
+				size = <${ROOTFS_SIZE}>;
+				hash-1 {
+					value = <0x${ROOTFS_CRC32}>;
+					algo = \"crc32\";
+					};
+				hash-2 {
+					value = ${ROOTFS_SHA1};
+					algo = \"sha1\";
+					};
 			};
-		};
 "
-	LOADABLES="${LOADABLES:+$LOADABLES, }\"rootfs${REFERENCE_CHAR}${ROOTFSNUM}\""
 fi
 
 # add DT overlay blobs
@@ -219,9 +217,8 @@ DATA="/dts-v1/;
 ${INITRD_NODE}
 ${FDT_NODE}
 ${FDTOVERLAY_NODE}
-${ROOTFS_NODE}
 	};
-
+${ROOTFS_NODE}
 	configurations {
 		default = \"${CONFIG}\";
 		${CONFIG} {
@@ -238,3 +235,4 @@ ${ROOTFS_NODE}
 
 # Write .its file to disk
 echo "$DATA" > "${OUTPUT}"
+cp "${OUTPUT}" /home/yingwei.huang/tmp 

--- a/package/boot/uboot-envtools/files/mediatek_filogic
+++ b/package/boot/uboot-envtools/files/mediatek_filogic
@@ -9,6 +9,95 @@ touch /etc/config/ubootenv
 . /lib/uboot-envtools.sh
 . /lib/functions.sh
 
+CI_UBIPART=ubi
+
+ubi_mknod() {
+        local dir="$1"
+        local dev="/dev/$(basename $dir)"
+
+        [ -e "$dev" ] && return 0
+
+        local devid="$(cat $dir/dev)"
+        local major="${devid%%:*}"
+        local minor="${devid##*:}"
+        mknod "$dev" c $major $minor
+}
+
+get_boot_param()
+{
+	local cmdline_param=$(cat /proc/cmdline)
+	local name
+	for var in $cmdline_param
+	do
+		#echo "aaa---$var"
+		if [ $var == $1 ];
+		then
+			echo "Y"
+			return
+		else
+			name=$(echo $var | awk -F '=' '{print $1}')
+			#echo "$name"
+			if [ $name == $1 ];
+			then
+					echo $(echo $var | awk -F '=' '{print $2}')
+					return
+			fi
+		fi
+	done
+	echo "N"
+}
+
+block_dev_path() {
+	local dev_path
+
+	case "$1" in
+	/dev/mmcblk*)
+		dev_path="$1"
+		;;
+	PARTLABEL=* | PARTUUID=*)
+		dev_path=$(blkid -t "$1" -o device)
+		[ -z "${dev_path}" -o $? -ne 0 ] && return 1
+		;;
+	*)
+		return 1;
+		;;
+	esac
+
+	echo "${dev_path}"
+	return 0
+}
+
+nand_find_volume() {
+	local ubidevdir ubivoldir
+	ubidevdir="/sys/devices/virtual/ubi/$1"
+	[ ! -d "$ubidevdir" ] && return 1
+	for ubivoldir in $ubidevdir/${1}_*; do
+		[ ! -d "$ubivoldir" ] && continue
+		if [ "$( cat $ubivoldir/name )" = "$2" ]; then
+			basename $ubivoldir
+			ubi_mknod "$ubivoldir"
+			return 0
+		fi
+	done
+}
+
+nand_find_ubi() {
+	local ubidevdir ubidev mtdnum
+	mtdnum="$( find_mtd_index $1 )"
+	[ ! "$mtdnum" ] && return 1
+	for ubidevdir in /sys/devices/virtual/ubi/ubi*; do
+		[ ! -d "$ubidevdir" ] && continue
+		cmtdnum="$( cat $ubidevdir/mtd_num )"
+		[ ! "$mtdnum" ] && continue
+		if [ "$mtdnum" = "$cmtdnum" ]; then
+			ubidev=$( basename $ubidevdir )
+			ubi_mknod "$ubidevdir"
+			echo $ubidev
+			return 0
+		fi
+	done
+}
+
 board=$(board_name)
 
 case "$board" in
@@ -37,6 +126,29 @@ bananapi,bpi-r3)
 		;;
 	esac
 	;;
+cybertan,cap630w-211g)
+	#env_dev=$(cat /sys/module/boot_param/parameters/env_part 2>/dev/null)
+	env_dev=$(get_boot_param "boot_param.env_part")
+	if [ -n "$env_dev" ]; then
+		mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+		if [ ! "$mtdnum" ]; then
+			echo "cannot find ubi mtd partition $CI_UBIPART"
+			return 1
+		fi
+
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		if [ ! "$ubidev" ]; then
+			ubiattach -m "$mtdnum"
+			sync
+			ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		fi
+
+		env_ubivol="$( nand_find_volume "${ubidev}" ${env_dev} )"
+		if [ -n "${env_ubivol}" ]; then
+			ubootenv_add_uci_config "/dev/$env_ubivol" "0" "0x80000" "0x80000" 1
+		fi
+	fi
+	;;
 glinet,gl-mt3000)
 	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x80000" "0x20000"
 	;;
	
--- a/package/base-files/files/lib/upgrade/nand.sh
+++ b/package/base-files/files/lib/upgrade/nand.sh
@@ -3,17 +3,39 @@
 
 . /lib/functions.sh
 
-# 'kernel' partition or UBI volume on NAND contains the kernel
+# 'kernel' partition on NAND contains the kernel
 CI_KERNPART="${CI_KERNPART:-kernel}"
 
 # 'ubi' partition on NAND contains UBI
-# There are also CI_KERN_UBIPART and CI_ROOT_UBIPART if kernel
-# and rootfs are on separated UBIs.
 CI_UBIPART="${CI_UBIPART:-ubi}"
 
-# 'rootfs' UBI volume on NAND contains the rootfs
+# 'rootfs' partition on NAND contains the rootfs
 CI_ROOTPART="${CI_ROOTPART:-rootfs}"
 
+get_boot_param()
+{
+	local cmdline_param=$(cat /proc/cmdline)
+	local name
+	for var in $cmdline_param
+	do
+		#echo "aaa---$var"
+		if [ $var == $1 ];
+		then
+			echo "Y"
+			return
+		else
+			name=$(echo $var | awk -F '=' '{print $1}')
+			#echo "$name"
+			if [ $name == $1 ];
+			then
+					echo $(echo $var | awk -F '=' '{print $2}')
+					return
+			fi
+		fi
+	done
+	echo "N"
+}
+
 ubi_mknod() {
 	local dir="$1"
 	local dev="/dev/$(basename $dir)"
@@ -28,7 +50,7 @@ ubi_mknod() {
 
 nand_find_volume() {
 	local ubidevdir ubivoldir
-	ubidevdir="/sys/class/ubi/"
+	ubidevdir="/sys/devices/virtual/ubi/$1"
 	[ ! -d "$ubidevdir" ] && return 1
 	for ubivoldir in $ubidevdir/${1}_*; do
 		[ ! -d "$ubivoldir" ] && continue
@@ -41,12 +63,13 @@ nand_find_volume() {
 }
 
 nand_find_ubi() {
-	local ubidevdir ubidev mtdnum cmtdnum
+	local ubidevdir ubidev mtdnum
 	mtdnum="$( find_mtd_index $1 )"
 	[ ! "$mtdnum" ] && return 1
-	for ubidevdir in /sys/class/ubi/ubi*; do
-		[ ! -e "$ubidevdir/mtd_num" ] && continue
+	for ubidevdir in /sys/devices/virtual/ubi/ubi*; do
+		[ ! -d "$ubidevdir" ] && continue
 		cmtdnum="$( cat $ubidevdir/mtd_num )"
+		[ ! "$mtdnum" ] && continue
 		if [ "$mtdnum" = "$cmtdnum" ]; then
 			ubidev=$( basename $ubidevdir )
 			ubi_mknod "$ubidevdir"
@@ -57,426 +80,430 @@ nand_find_ubi() {
 }
 
 nand_get_magic_long() {
-	(${3}cat "$1" | dd bs=4 "skip=${2:-0}" count=1 | hexdump -v -n 4 -e '1/1 "%02x"') 2> /dev/null
+	dd if="$1" skip=$2 bs=4 count=1 2>/dev/null | hexdump -v -n 4 -e '1/1 "%02x"'
 }
 
 get_magic_long_tar() {
-	(tar xO${3}f "$1" "$2" | dd bs=4 count=1 | hexdump -v -n 4 -e '1/1 "%02x"') 2> /dev/null
+	( tar xf $1 $2 -O | dd bs=4 count=1 | hexdump -v -n 4 -e '1/1 "%02x"') 2> /dev/null
 }
 
-identify() {
-	identify_magic_long $(nand_get_magic_long "$@")
+identify_magic() {
+	local magic=$1
+	case "$magic" in
+		"55424923")
+			echo "ubi"
+			;;
+		"31181006")
+			echo "ubifs"
+			;;
+		"68737173")
+			echo "squashfs"
+			;;
+		"d00dfeed")
+			echo "fit"
+			;;
+		"4349"*)
+			echo "combined"
+			;;
+		*)
+			echo "unknown $magic"
+			;;
+	esac
 }
 
-identify_tar() {
-	identify_magic_long $(get_magic_long_tar "$@")
+
+identify() {
+	identify_magic $(nand_get_magic_long "$1" "${2:-0}")
 }
 
-identify_if_gzip() {
-	if [ "$(identify "$1")" = gzip ]; then echo -n z; fi
+identify_tar() {
+	identify_magic $(get_magic_long_tar "$1" "$2")
 }
 
 nand_restore_config() {
-	local ubidev=$( nand_find_ubi "${CI_ROOT_UBIPART:-$CI_UBIPART}" )
+	sync
+	local ubidev=$( nand_find_ubi $CI_UBIPART )
 	local ubivol="$( nand_find_volume $ubidev rootfs_data )"
-	if [ ! "$ubivol" ]; then
-		ubivol="$( nand_find_volume $ubidev "$CI_ROOTPART" )"
-		if [ ! "$ubivol" ]; then
-			echo "cannot find ubifs data volume"
-			return 1
-		fi
-	fi
+	[ ! "$ubivol" ] &&
+		ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
 	mkdir /tmp/new_root
 	if ! mount -t ubifs /dev/$ubivol /tmp/new_root; then
-		echo "cannot mount ubifs volume $ubivol"
+		echo "mounting ubifs $ubivol failed"
 		rmdir /tmp/new_root
 		return 1
 	fi
-	if mv "$1" "/tmp/new_root/$BACKUP_FILE"; then
-		if umount /tmp/new_root; then
-			echo "configuration saved"
-			rmdir /tmp/new_root
-			return 0
-		fi
-	else
-		umount /tmp/new_root
-	fi
-	echo "could not save configuration to ubifs volume $ubivol"
+	mv "$1" "/tmp/new_root/$BACKUP_FILE"
+	umount /tmp/new_root
+	sync
 	rmdir /tmp/new_root
-	return 1
-}
-
-nand_remove_ubiblock() {
-	local ubivol="$1"
-
-	local ubiblk="ubiblock${ubivol:3}"
-	if [ -e "/dev/$ubiblk" ]; then
-		umount "/dev/$ubiblk" && echo "unmounted /dev/$ubiblk" || :
-		if ! ubiblock -r "/dev/$ubivol"; then
-			echo "cannot remove $ubiblk"
-			return 1
-		fi
-	fi
 }
 
-nand_attach_ubi() {
-	local ubipart="$1"
-	local has_env="${2:-0}"
+nand_upgrade_prepare_ubi() {
+	local rootfs_length="$1"
+	local rootfs_type="$2"
+	local has_kernel="${3:-0}"
+	local has_env="${4:-0}"
 
-	local mtdnum="$( find_mtd_index "$ubipart" )"
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
 	if [ ! "$mtdnum" ]; then
-		>&2 echo "cannot find ubi mtd partition $ubipart"
+		echo "cannot find ubi mtd partition $CI_UBIPART"
 		return 1
 	fi
 
-	local ubidev="$( nand_find_ubi "$ubipart" )"
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
 	if [ ! "$ubidev" ]; then
-		>&2 ubiattach -m "$mtdnum"
-		ubidev="$( nand_find_ubi "$ubipart" )"
-
-		if [ ! "$ubidev" ]; then
-			>&2 ubiformat /dev/mtd$mtdnum -y
-			>&2 ubiattach -m "$mtdnum"
-			ubidev="$( nand_find_ubi "$ubipart" )"
-
-			if [ ! "$ubidev" ]; then
-				>&2 echo "cannot attach ubi mtd partition $ubipart"
-				return 1
-			fi
-
-			if [ "$has_env" -gt 0 ]; then
-				>&2 ubimkvol /dev/$ubidev -n 0 -N ubootenv -s 1MiB
-				>&2 ubimkvol /dev/$ubidev -n 1 -N ubootenv2 -s 1MiB
-			fi
-		fi
-	fi
-
-	echo "$ubidev"
-	return 0
-}
-
-nand_detach_ubi() {
-	local ubipart="$1"
-
-	local mtdnum="$( find_mtd_index "$ubipart" )"
-	if [ ! "$mtdnum" ]; then
-		echo "cannot find ubi mtd partition $ubipart"
-		return 1
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
 	fi
 
-	local ubidev="$( nand_find_ubi "$ubipart" )"
-	if [ "$ubidev" ]; then
-		for ubivol in $(find /dev -name "${ubidev}_*" -maxdepth 1 | sort); do
-			ubivol="${ubivol:5}"
-			nand_remove_ubiblock "$ubivol" || :
-			umount "/dev/$ubivol" && echo "unmounted /dev/$ubivol" || :
-		done
-		if ! ubidetach -m "$mtdnum"; then
-			echo "cannot detach ubi mtd partition $ubipart"
-			return 1
-		fi
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		[ "$has_env" -gt 0 ] && {
+			ubimkvol /dev/$ubidev -n 0 -N ubootenv -s 1MiB
+			ubimkvol /dev/$ubidev -n 1 -N ubootenv2 -s 1MiB
+		}
 	fi
-}
 
-nand_upgrade_prepare_ubi() {
-	local rootfs_length="$1"
-	local rootfs_type="$2"
-	local rootfs_data_max="$(fw_printenv -n rootfs_data_max 2> /dev/null)"
-	[ -n "$rootfs_data_max" ] && rootfs_data_max=$((rootfs_data_max))
+	local kern_ubivol="$( nand_find_volume $ubidev $CI_KERNPART )"
+	local root_ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+	local data_ubivol="$( nand_find_volume $ubidev rootfs_data )"
 
-	local kernel_length="$3"
-	local has_env="${4:-0}"
-	local kern_ubidev
-	local root_ubidev
-
-	[ -n "$rootfs_length" -o -n "$kernel_length" ] || return 1
-
-	if [ -n "$CI_KERN_UBIPART" -a -n "$CI_ROOT_UBIPART" ]; then
-		kern_ubidev="$( nand_attach_ubi "$CI_KERN_UBIPART" "$has_env" )"
-		[ -n "$kern_ubidev" ] || return 1
-		root_ubidev="$( nand_attach_ubi "$CI_ROOT_UBIPART" )"
-		[ -n "$root_ubidev" ] || return 1
-	else
-		kern_ubidev="$( nand_attach_ubi "$CI_UBIPART" "$has_env" )"
-		[ -n "$kern_ubidev" ] || return 1
-		root_ubidev="$kern_ubidev"
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
 	fi
 
-	local kern_ubivol="$( nand_find_volume $kern_ubidev "$CI_KERNPART" )"
-	local root_ubivol="$( nand_find_volume $root_ubidev "$CI_ROOTPART" )"
-	local data_ubivol="$( nand_find_volume $root_ubidev rootfs_data )"
-	[ "$root_ubivol" = "$kern_ubivol" ] && root_ubivol=
-
-	# remove ubiblocks
-	[ "$kern_ubivol" ] && { nand_remove_ubiblock $kern_ubivol || return 1; }
-	[ "$root_ubivol" ] && { nand_remove_ubiblock $root_ubivol || return 1; }
-	[ "$data_ubivol" ] && { nand_remove_ubiblock $data_ubivol || return 1; }
-
 	# kill volumes
-	[ "$kern_ubivol" ] && ubirmvol /dev/$kern_ubidev -N "$CI_KERNPART" || :
-	[ "$root_ubivol" ] && ubirmvol /dev/$root_ubidev -N "$CI_ROOTPART" || :
-	[ "$data_ubivol" ] && ubirmvol /dev/$root_ubidev -N rootfs_data || :
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_KERNPART || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_ROOTPART || true
+	[ "$data_ubivol" ] && ubirmvol /dev/$ubidev -N rootfs_data || true
 
-	# create kernel vol
-	if [ -n "$kernel_length" ]; then
-		if ! ubimkvol /dev/$kern_ubidev -N "$CI_KERNPART" -s $kernel_length; then
+	# update kernel
+	if [ "$has_kernel" = "1" ]; then
+		if ! ubimkvol /dev/$ubidev -N $CI_KERNPART -s $kernel_length; then
 			echo "cannot create kernel volume"
 			return 1;
 		fi
 	fi
 
-	# create rootfs vol
-	if [ -n "$rootfs_length" ]; then
-		local rootfs_size_param
-		if [ "$rootfs_type" = "ubifs" ]; then
-			rootfs_size_param="-m"
-		else
-			rootfs_size_param="-s $rootfs_length"
-		fi
-		if ! ubimkvol /dev/$root_ubidev -N "$CI_ROOTPART" $rootfs_size_param; then
-			echo "cannot create rootfs volume"
-			return 1;
-		fi
+	# update rootfs
+	local root_size_param
+	if [ "$rootfs_type" = "ubifs" ]; then
+		root_size_param="-m"
+	else
+		root_size_param="-s $rootfs_length"
+	fi
+	if ! ubimkvol /dev/$ubidev -N $CI_ROOTPART $root_size_param; then
+		echo "cannot create rootfs volume"
+		return 1;
 	fi
 
-	# create rootfs_data vol for non-ubifs rootfs
+	# create rootfs_data for non-ubifs rootfs
 	if [ "$rootfs_type" != "ubifs" ]; then
-		local rootfs_data_size_param="-m"
-		if [ -n "$rootfs_data_max" ]; then
-			rootfs_data_size_param="-s $rootfs_data_max"
-		fi
-		if ! ubimkvol /dev/$root_ubidev -N rootfs_data $rootfs_data_size_param; then
-			if ! ubimkvol /dev/$root_ubidev -N rootfs_data -m; then
-				echo "cannot initialize rootfs_data volume"
-				return 1
-			fi
+		if ! ubimkvol /dev/$ubidev -N rootfs_data -m; then
+			echo "cannot initialize rootfs_data volume"
+			return 1
 		fi
 	fi
-
+	sync
 	return 0
 }
 
-# Write the UBI image to MTD ubi partition
+nand_do_upgrade_success() {
+	local conf_tar="/tmp/sysupgrade.tgz"
+
+	sync
+	[ -f "$conf_tar" ] && nand_restore_config "$conf_tar"
+	echo "sysupgrade successful"
+	umount -a
+	reboot -f
+}
+
+# Flash the UBI image to MTD partition
 nand_upgrade_ubinized() {
 	local ubi_file="$1"
-	local gz="$2"
+	local mtdnum="$(find_mtd_index "$CI_UBIPART")"
 
-	local ubi_length=$( (${gz}cat "$ubi_file" | wc -c) 2> /dev/null)
+	[ ! "$mtdnum" ] && {
+		CI_UBIPART="rootfs"
+		mtdnum="$(find_mtd_index "$CI_UBIPART")"
+	}
 
-	nand_detach_ubi "$CI_UBIPART" || return 1
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find mtd device $CI_UBIPART"
+		umount -a
+		reboot -f
+	fi
 
-	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
-	${gz}cat "$ubi_file" | ubiformat "/dev/mtd$mtdnum" -S "$ubi_length" -y -f - && ubiattach -m "$mtdnum"
+	local mtddev="/dev/mtd${mtdnum}"
+	ubidetach -p "${mtddev}" || true
+	sync
+	ubiformat "${mtddev}" -y -f "${ubi_file}"
+	ubiattach -p "${mtddev}"
+	nand_do_upgrade_success
 }
 
-# Write the UBIFS image to UBI rootfs volume
+# Write the UBIFS image to UBI volume
 nand_upgrade_ubifs() {
-	local ubifs_file="$1"
-	local gz="$2"
+	local rootfs_length=$( (cat $1 | wc -c) 2> /dev/null)
 
-	local ubifs_length=$( (${gz}cat "$ubifs_file" | wc -c) 2> /dev/null)
-
-	nand_upgrade_prepare_ubi "$ubifs_length" "ubifs" "" "" || return 1
+	nand_upgrade_prepare_ubi "$rootfs_length" "ubifs" "0" "0"
 
 	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
-	local root_ubivol="$(nand_find_volume $ubidev "$CI_ROOTPART")"
-	${gz}cat "$ubifs_file" | ubiupdatevol /dev/$root_ubivol -s "$ubifs_length" -
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	ubiupdatevol /dev/$root_ubivol -s $rootfs_length $1
+
+	nand_do_upgrade_success
 }
 
-# Write the FIT image to UBI kernel volume
-nand_upgrade_fit() {
-	local fit_file="$1"
-	local gz="$2"
+nand_upgrade_tar() {
+	local tar_file="$1"
+	local kernel_mtd="$(find_mtd_index $CI_KERNPART)"
+
+	local board_dir=$(tar tf $tar_file | grep -m 1 '^sysupgrade-.*/$')
+	board_dir=${board_dir%/}
 
-	local fit_length=$( (${gz}cat "$fit_file" | wc -c) 2> /dev/null)
+	local kernel_length=$( (tar xf $tar_file ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf $tar_file ${board_dir}/root -O | wc -c) 2> /dev/null)
 
-	nand_upgrade_prepare_ubi "" "" "$fit_length" "1" || return 1
+	local rootfs_type="$(identify_tar "$tar_file" ${board_dir}/root)"
+
+	local has_kernel=1
+	local has_env=0
 
-	local fit_ubidev="$(nand_find_ubi "$CI_UBIPART")"
-	local fit_ubivol="$(nand_find_volume $fit_ubidev "$CI_KERNPART")"
-	${gz}cat "$fit_file" | ubiupdatevol /dev/$fit_ubivol -s "$fit_length" -
+	[ "$kernel_length" != 0 -a -n "$kernel_mtd" ] && {
+		tar xf $tar_file ${board_dir}/kernel -O | mtd write - $CI_KERNPART
+	}
+	[ "$kernel_length" = 0 -o ! -z "$kernel_mtd" ] && has_kernel=0
+
+	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "$has_kernel" "$has_env"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	[ "$has_kernel" = "1" ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev $CI_KERNPART)"
+		tar xf $tar_file ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/$kern_ubivol -s $kernel_length -
+	}
+
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	tar xf $tar_file ${board_dir}/root -O | \
+		ubiupdatevol /dev/$root_ubivol -s $rootfs_length -
+
+	nand_do_upgrade_success
 }
 
-# Write images in the TAR file to MTD partitions and/or UBI volumes as required
-nand_upgrade_tar() {
-	local tar_file="$1"
-	local gz="$2"
-	local jffs2_markers="${CI_JFFS2_CLEAN_MARKERS:-0}"
-
-	# WARNING: This fails if tar contains more than one 'sysupgrade-*' directory.
-	local board_dir="$(tar t${gz}f "$tar_file" | grep -m 1 '^sysupgrade-.*/$')"
-	board_dir="${board_dir%/}"
-
-	local kernel_mtd kernel_length
-	if [ "$CI_KERNPART" != "none" ]; then
-		kernel_mtd="$(find_mtd_index "$CI_KERNPART")"
-		kernel_length=$( (tar xO${gz}f "$tar_file" "$board_dir/kernel" | wc -c) 2> /dev/null)
-		[ "$kernel_length" = 0 ] && kernel_length=
-	fi
-	local rootfs_length=$( (tar xO${gz}f "$tar_file" "$board_dir/root" | wc -c) 2> /dev/null)
-	[ "$rootfs_length" = 0 ] && rootfs_length=
-	local rootfs_type
-	[ "$rootfs_length" ] && rootfs_type="$(identify_tar "$tar_file" "$board_dir/root" "$gz")"
-
-	local ubi_kernel_length
-	if [ "$kernel_length" ]; then
-		if [ "$kernel_mtd" ]; then
-			# On some devices, the raw kernel and ubi partitions overlap.
-			# These devices brick if the kernel partition is erased.
-			# Hence only invalidate kernel for now.
-			dd if=/dev/zero bs=4096 count=1 2> /dev/null | \
-				mtd write - "$CI_KERNPART"
-		else
-			ubi_kernel_length="$kernel_length"
-		fi
-	fi
+# Recognize type of passed file and start the upgrade process
+nand_do_upgrade() {
+	local file_type=$(identify $1)
 
-	local has_env=0
-	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "$ubi_kernel_length" "$has_env" || return 1
+	[ ! "$(find_mtd_index "$CI_UBIPART")" ] && CI_UBIPART="rootfs"
 
-	if [ "$rootfs_length" ]; then
-		local ubidev="$( nand_find_ubi "${CI_ROOT_UBIPART:-$CI_UBIPART}" )"
-		local root_ubivol="$( nand_find_volume $ubidev "$CI_ROOTPART" )"
-		tar xO${gz}f "$tar_file" "$board_dir/root" | \
-			ubiupdatevol /dev/$root_ubivol -s "$rootfs_length" -
-	fi
-	if [ "$kernel_length" ]; then
-		if [ "$kernel_mtd" ]; then
-			if [ "$jffs2_markers" = 1 ]; then
-				flash_erase -j "/dev/mtd${kernel_mtd}" 0 0
-				tar xO${gz}f "$tar_file" "$board_dir/kernel" | \
-					nandwrite "/dev/mtd${kernel_mtd}" -
-			else
-				tar xO${gz}f "$tar_file" "$board_dir/kernel" | \
-					mtd write - "$CI_KERNPART"
-			fi
-		else
-			local ubidev="$( nand_find_ubi "${CI_KERN_UBIPART:-$CI_UBIPART}" )"
-			local kern_ubivol="$( nand_find_volume $ubidev "$CI_KERNPART" )"
-			tar xO${gz}f "$tar_file" "$board_dir/kernel" | \
-				ubiupdatevol /dev/$kern_ubivol -s "$kernel_length" -
-		fi
-	fi
+	case "$file_type" in
+		"ubi")		nand_upgrade_ubinized $1;;
+		"ubifs")	nand_upgrade_ubifs $1;;
+		*)		nand_upgrade_tar $1;;
+	esac
+}
+
+# Check if passed file is a valid one for NAND sysupgrade. Currently it accepts
+# 3 types of files:
+# 1) UBI - should contain an ubinized image, header is checked for the proper
+#    MAGIC
+# 2) UBIFS - should contain UBIFS partition that will replace "rootfs" volume,
+#    header is checked for the proper MAGIC
+# 3) TAR - archive has to include "sysupgrade-BOARD" directory with a non-empty
+#    "CONTROL" file (at this point its content isn't verified)
+#
+# You usually want to call this function in platform_check_image.
+#
+# $(1): board name, used in case of passing TAR file
+# $(2): file to be checked
+nand_do_platform_check() {
+	local board_name="$1"
+	local tar_file="$2"
+	local control_length=$( (tar xf $tar_file sysupgrade-$board_name/CONTROL -O | wc -c) 2> /dev/null)
+	local file_type="$(identify $2)"
+
+	[ "$control_length" = 0 -a "$file_type" != "ubi" -a "$file_type" != "ubifs" ] && {
+		echo "Invalid sysupgrade file."
+		return 1
+	}
 
 	return 0
 }
 
-nand_verify_if_gzip_file() {
-	local file="$1"
-	local gz="$2"
+dual_boot_upgrade_prepare_ubi() {
+	local kernel_vol_name="$1"
+	local rootfs_vol_name="$2"
+	local kernel_length="$3"
+	local rootfs_length="$4"
+	local reserve_rootfs_data="$5"
+	local conf_tar="/tmp/sysupgrade.tgz"
 
-	if [ "$gz" = z ]; then
-		echo "verifying compressed sysupgrade file integrity"
-		if ! gzip -t "$file"; then
-			echo "corrupted compressed sysupgrade file"
-			return 1
-		fi
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition $CI_UBIPART"
+		return 1
 	fi
-}
 
-nand_verify_tar_file() {
-	local file="$1"
-	local gz="$2"
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	if [ ! "$ubidev" ]; then
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	fi
 
-	echo "verifying sysupgrade tar file integrity"
-	if ! tar xO${gz}f "$file" > /dev/null; then
-		echo "corrupted sysupgrade tar file"
-		return 1
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		ubimkvol /dev/$ubidev -n 0 -N u-boot-env -s 512KiB
 	fi
-}
 
-nand_do_flash_file() {
-	local file="$1"
+	#local rootfs_data_vol_name=$(cat /sys/module/boot_param/parameters/rootfs_data_part 2>/dev/null)
+	local rootfs_data_vol_name=$(get_boot_param "boot_param.rootfs_data_part")
+	
+	local kern_ubivol="$( nand_find_volume $ubidev $kernel_vol_name )"
+	local root_ubivol="$( nand_find_volume $ubidev $rootfs_vol_name )"
+	local data_ubivol="$( nand_find_volume $ubidev $rootfs_data_vol_name )"
+
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
+	fi
 
-	local gz="$(identify_if_gzip "$file")"
-	local file_type="$(identify "$file" "" "$gz")"
+	# kill volumes
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $kernel_vol_name || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $rootfs_vol_name || true
 
-	[ ! "$(find_mtd_index "$CI_UBIPART")" ] && CI_UBIPART=rootfs
+	# update kernel
+	if ! ubimkvol /dev/$ubidev -N $kernel_vol_name -s $kernel_length; then
+		echo "cannot create kernel volume"
+		return 1;
+	fi
 
-	case "$file_type" in
-		"fit")
-			nand_verify_if_gzip_file "$file" "$gz" || return 1
-			nand_upgrade_fit "$file" "$gz"
-			;;
-		"ubi")
-			nand_verify_if_gzip_file "$file" "$gz" || return 1
-			nand_upgrade_ubinized "$file" "$gz"
-			;;
-		"ubifs")
-			nand_verify_if_gzip_file "$file" "$gz" || return 1
-			nand_upgrade_ubifs "$file" "$gz"
-			;;
-		*)
-			nand_verify_tar_file "$file" "$gz" || return 1
-			nand_upgrade_tar "$file" "$gz"
-			;;
-	esac
-}
+	# update rootfs
+	if ! ubimkvol /dev/$ubidev -N $rootfs_vol_name -s $rootfs_length; then
+		echo "cannot create rootfs volume"
+		return 1;
+	fi
 
-nand_do_restore_config() {
-	local conf_tar="/tmp/sysupgrade.tgz"
-	[ ! -f "$conf_tar" ] || nand_restore_config "$conf_tar"
-}
+	if [ x"${reserve_rootfs_data}" = xY ] && [ -f "$conf_tar" ]; then
+		# Do not touch rootfs_data
+		sync
+		return 0
+	fi
 
-# Recognize type of passed file and start the upgrade process
-nand_do_upgrade() {
-	local file="$1"
+	# 'format' rootfs_data volume
+	[ "$data_ubivol" ] && {
+		local rootfs_data_length=$(cat /sys/class/ubi/$data_ubivol/data_bytes)
+
+		# kill rootfs_data volume
+		ubirmvol /dev/$ubidev -N $rootfs_data_vol_name || true
+
+		# update rootfs_data
+		if ! ubimkvol /dev/$ubidev -N $rootfs_data_vol_name -s $rootfs_data_length; then
+			echo "cannot create $rootfs_data_vol_name volume"
+		fi
+	}
 
 	sync
-	nand_do_flash_file "$file" && nand_do_upgrade_success
-	nand_do_upgrade_failed
+	return 0
 }
 
-nand_do_upgrade_success() {
-	if nand_do_restore_config && sync; then
-		echo "sysupgrade successful"
-		umount -a
-		reboot -f
+ubi_dual_boot_upgrade_tar() {
+	local tar_file="$1"
+	local board_dir=$(tar tf ${tar_file} | grep -m 1 '^sysupgrade-.*/$')
+	#local reserve_rootfs_data=$(cat /sys/module/boot_param/parameters/reserve_rootfs_data 2>/dev/null)
+	local reserve_rootfs_data=$(get_boot_param "boot_param.reserve_rootfs_data")
+	board_dir=${board_dir%/}
+
+	#kernel_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_kernel_part 2>/dev/null)
+	kernel_vol_name=$(get_boot_param "boot_param.upgrade_kernel_part")
+	[ -z "${kernel_vol_name}" -o $? -ne 0 ] && return 1
+
+	#rootfs_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_rootfs_part 2>/dev/null)
+	rootfs_vol_name=$(get_boot_param "boot_param.upgrade_rootfs_part")
+	[ -z "${rootfs_vol_name}" -o $? -ne 0 ] && return 1
+
+	local kernel_length=$( (tar xf ${tar_file} ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf ${tar_file} ${board_dir}/root -O | wc -c) 2> /dev/null)
+	echo "kernel_vol_name=$kernel_vol_name,rootfs_vol_name=$rootfs_vol_name,kernel_length=$kernel_length,rootfs_length=$rootfs_length,reserve_rootfs_data=$reserve_rootfs_data"
+	dual_boot_upgrade_prepare_ubi "${kernel_vol_name}" "${rootfs_vol_name}" \
+				      "${kernel_length}" "${rootfs_length}" \
+				      "${reserve_rootfs_data}"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+
+	[ "${kernel_length}" != 0 ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev ${kernel_vol_name})"
+		tar xf ${tar_file} ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/${kern_ubivol} -s ${kernel_length} -
+	}
+
+	[ "${rootfs_length}" != 0 ] && {
+		local root_ubivol="$(nand_find_volume $ubidev ${rootfs_vol_name})"
+		tar xf ${tar_file} ${board_dir}/root -O | \
+			ubiupdatevol /dev/${root_ubivol} -s ${rootfs_length} -
+	}
+
+	#upgrade_image_slot=$(cat /sys/module/boot_param/parameters/upgrade_image_slot 2>/dev/null)
+	upgrade_image_slot=$(get_boot_param "boot_param.upgrade_image_slot")
+	[ -n "${upgrade_image_slot}" ] && {
+		v "Set new boot image slot to ${upgrade_image_slot}"
+		# Force the creation of fw_printenv.lock
+		mkdir -p /var/lock
+		touch /var/lock/fw_printenv.lock
+		fw_setenv "dual_boot.current_slot" "${upgrade_image_slot}"
+		fw_setenv "dual_boot.slot_${upgrade_image_slot}_invalid" "0"
+	}
+
+	if [ x"${reserve_rootfs_data}" != xY ]; then
+		# do normal upgrade flow
+		nand_do_upgrade_success
 	fi
-	nand_do_upgrade_failed
-}
 
-nand_do_upgrade_failed() {
+	# Do not touch rootfs_data
 	sync
-	echo "sysupgrade failed"
-	# Should we reboot or bring up some failsafe mode instead?
+
+	echo "sysupgrade successful"
 	umount -a
 	reboot -f
 }
 
-# Check if passed file is a valid one for NAND sysupgrade.
-# Currently it accepts 4 types of files:
-# 1) UBI: a ubinized image containing required UBI volumes.
-# 2) UBIFS: a UBIFS rootfs volume image.
-# 3) FIT: a FIT image containing kernel and rootfs.
-# 4) TAR: an archive that includes directory "sysupgrade-${BOARD_NAME}" containing
-#         a non-empty "CONTROL" file and required partition and/or volume images.
-#
-# You usually want to call this function in platform_check_image.
-#
-# $(1): board name, used in case of passing TAR file
-# $(2): file to be checked
-nand_do_platform_check() {
-	local board_name="$1"
-	local file="$2"
-
-	local gz="$(identify_if_gzip "$file")"
-	local file_type="$(identify "$file" "" "$gz")"
-	local control_length=$( (tar xO${gz}f "$file" "sysupgrade-${board_name//,/_}/CONTROL" | wc -c) 2> /dev/null)
+ubi_do_upgrade() {
+	#local dual_boot=$(cat /sys/module/boot_param/parameters/dual_boot 2>/dev/null)
+	local dual_boot=$(get_boot_param "boot_param.dual_boot")
+	local file_type=$(identify $1)
 
-	if [ "$control_length" = 0 ]; then
-		control_length=$( (tar xO${gz}f "$file" "sysupgrade-${board_name//_/,}/CONTROL" | wc -c) 2> /dev/null)
+	if [ -b /dev/dm-0 ]; then
+		v "Detach all device mapper devices"
+		dmsetup remove_all
 	fi
-
-	if [ "$control_length" != 0 ]; then
-		nand_verify_tar_file "$file" "$gz" || return 1
-	else
-		nand_verify_if_gzip_file "$file" "$gz" || return 1
-		if [ "$file_type" != "fit" -a "$file_type" != "ubi" -a "$file_type" != "ubifs" ]; then
-			echo "invalid sysupgrade file"
-			return 1
-		fi
+	echo "dual_boot=$dual_boot file_type=$file_type"
+	if [ x"${dual_boot}" != xY ]; then
+		nand_do_upgrade "$1"
+		return
 	fi
 
-	return 0
+	case "$file_type" in
+		"ubi")		v "Unsupported firmware type: ubinized";;
+		"ubifs")	v "Unsupported firmware type: ubifs";;
+		*)		ubi_dual_boot_upgrade_tar $1;;
+	esac
 }

--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -310,7 +310,8 @@ define Build/fit
 		$(if $(DEVICE_DTS_LOADADDR),-s $(DEVICE_DTS_LOADADDR)) \
 		$(if $(DEVICE_DTS_OVERLAY),$(foreach dtso,$(DEVICE_DTS_OVERLAY), -O $(dtso):$(KERNEL_BUILD_DIR)/image-$(dtso).dtbo)) \
 		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config-1") \
-		-A $(LINUX_KARCH) -v $(LINUX_VERSION)
+		-A $(LINUX_KARCH) -v $(LINUX_VERSION) \
+		$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),-r $(ROOTFS/squashfs/$(DEVICE_NAME)))
 	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage $(if $(findstring external,$(word 3,$(1))),\
 		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
 	@mv $@.new $@

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/mediatek/patches-5.15/500-ubi-add-configurable-rootdev.patch	2024-02-06 18:05:39.712888069 +0800
@@ -0,0 +1,35 @@
+--- a/drivers/mtd/ubi/block.c
++++ b/drivers/mtd/ubi/block.c
+@@ -97,6 +97,12 @@ static DEFINE_IDR(ubiblock_minor_idr);
+ static DEFINE_MUTEX(devices_mutex);
+ static int ubiblock_major;
+ 
++static char rootfs_volume[256] = "rootfs";
++module_param_string(rootfs_volume, rootfs_volume, sizeof(rootfs_volume), 0444);
++
++static bool no_default_rootdev;
++module_param(no_default_rootdev, bool, 0444);
++
+ static int __init ubiblock_set_param(const char *val,
+ 				     const struct kernel_param *kp)
+ {
+@@ -460,8 +466,9 @@ int ubiblock_create(struct ubi_volume_in
+ 		 dev->ubi_num, dev->vol_id, vi->name);
+ 	mutex_unlock(&devices_mutex);
+ 
+-	if (!strcmp(vi->name, "rootfs") &&
++	if (!strcmp(vi->name, rootfs_volume) &&
+ 	    IS_ENABLED(CONFIG_MTD_ROOTFS_ROOT_DEV) &&
++	    !no_default_rootdev &&
+ 	    ROOT_DEV == 0) {
+ 		pr_notice("ubiblock: device ubiblock%d_%d (%s) set to be root filesystem\n",
+ 			  dev->ubi_num, dev->vol_id, vi->name);
+@@ -681,7 +688,7 @@ static void __init ubiblock_create_auto_
+ 	struct ubi_volume_info vi;
+ 
+ 	for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) {
+-		desc = ubi_open_volume_nm(ubi_num, "rootfs", UBI_READONLY);
++		desc = ubi_open_volume_nm(ubi_num, rootfs_volume, UBI_READONLY);
+ 		if (IS_ERR(desc))
+ 			continue;
+ 

--- /dev/null	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/mediatek/patches-5.15/930-cmdline-boot-parameters.patch	2024-02-06 18:33:58.268721401 +0800
@@ -0,0 +1,59 @@
+--- a/kernel/Makefile
++++ b/kernel/Makefile
+@@ -12,6 +12,8 @@
+ 	    notifier.o ksysfs.o cred.o reboot.o \
+ 	    async.o range.o smpboot.o ucount.o regset.o
+ 
+++obj-y += boot_param.o
++
+ obj-$(CONFIG_USERMODE_DRIVER) += usermode_driver.o
+ obj-$(CONFIG_MODULES) += kmod.o
+ obj-$(CONFIG_MULTIUSER) += groups.o
+
+--- a/kernel/boot_param.c
++++ b/kernel/boot_param.c
+@@ -0,0 +1,44 @@
++/* SPDX-License-Identifier: BSD-3-Clause */
++/*
++* Copyright (C) 2022 MediaTek Inc. All rights reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include <linux/kernel.h>
++#include <linux/moduleparam.h>
++
++#define BOOT_PARAM_STR_MAX_LEN			256
++
++static bool dual_boot;
++module_param(dual_boot, bool, 0444);
++
++static bool no_split_rootfs_data;
++module_param(no_split_rootfs_data, bool, 0444);
++
++static bool reserve_rootfs_data;
++module_param(reserve_rootfs_data, bool, 0444);
++
++static uint boot_image_slot;
++module_param(boot_image_slot, uint, 0444);
++
++static uint upgrade_image_slot;
++module_param(upgrade_image_slot, uint, 0444);
++
++static char rootfs_data_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(rootfs_data_part, rootfs_data_part, BOOT_PARAM_STR_MAX_LEN, 0644);
++
++static char boot_kernel_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(boot_kernel_part, boot_kernel_part, BOOT_PARAM_STR_MAX_LEN, 0444);
++
++static char boot_rootfs_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(boot_rootfs_part, boot_rootfs_part, BOOT_PARAM_STR_MAX_LEN, 0444);
++
++static char upgrade_kernel_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(upgrade_kernel_part, upgrade_kernel_part, BOOT_PARAM_STR_MAX_LEN, 0444);
++
++static char upgrade_rootfs_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(upgrade_rootfs_part, upgrade_rootfs_part, BOOT_PARAM_STR_MAX_LEN, 0444);
++
++static char env_part[BOOT_PARAM_STR_MAX_LEN];
++module_param_string(env_part, env_part, BOOT_PARAM_STR_MAX_LEN, 0444);

--- a/package/network/services/hostapd/files/hostapd.uc	2024-03-04 18:01:21.825439392 +0800
+++ b/package/network/services/hostapd/files/hostapd.uc	2024-03-11 17:41:30.661390391 +0800
@@ -26,6 +26,7 @@
 	if (!cfg || !cfg.bss || !cfg.bss[0] || !cfg.bss[0].ifname)
 		return;
 
+	hostapd.remove_iface(cfg.bss[0].ifname);
 	for (let bss in cfg.bss)
 		wdev_remove(bss.ifname);
 }
@@ -94,14 +95,14 @@
 	let config_inline = iface_gen_config(phy, config, !!phy_status);
 
 	let bss = config.bss[0];
-	let ret = hostapd.add_iface(`bss_config=${phy}:${config_inline}`);
+	let ret = hostapd.add_iface(`bss_config=${bss.ifname}:${config_inline}`);
 	if (ret < 0)
 		return false;
 
 	if (!phy_status)
 		return true;
 
-	let iface = hostapd.interfaces[phy];
+	let iface = hostapd.interfaces[bss.ifname];
 	if (!iface)
 		return false;
 
@@ -122,19 +123,10 @@
 	return macaddr_list;
 }
 
-function iface_update_supplicant_macaddr(phy, config)
-{
-	let macaddr_list = [];
-	for (let i = 0; i < length(config.bss); i++)
-		push(macaddr_list, config.bss[i].bssid);
-	ubus.call("wpa_supplicant", "phy_set_macaddr_list", { phy: phy, macaddr: macaddr_list });
-}
-
 function iface_restart(phydev, config, old_config)
 {
 	let phy = phydev.name;
 
-	hostapd.remove_iface(phy);
 	iface_remove(old_config);
 	iface_remove(config);
 
@@ -150,8 +142,6 @@
 			bss.bssid = phydev.macaddr_next();
 	}
 
-	iface_update_supplicant_macaddr(phy, config);
-
 	let bss = config.bss[0];
 	let err = wdev_create(phy, bss.ifname, { mode: "ap" });
 	if (err)
@@ -277,13 +267,13 @@
 	if (!old_config.bss || !old_config.bss[0])
 		return false;
 
-	let iface = hostapd.interfaces[phy];
+	let iface_name = old_config.bss[0].ifname;
+	let iface = hostapd.interfaces[iface_name];
 	if (!iface) {
 		hostapd.printf(`Could not find previous interface ${iface_name}`);
 		return false;
 	}
 
-	let iface_name = old_config.bss[0].ifname;
 	let first_bss = hostapd.bss[iface_name];
 	if (!first_bss) {
 		hostapd.printf(`Could not find bss of previous interface ${iface_name}`);
@@ -508,16 +498,22 @@
 	return true;
 }
 
+function iface_update_supplicant_macaddr(phy, config)
+{
+	let macaddr_list = [];
+	for (let i = 0; i < length(config.bss); i++)
+		push(macaddr_list, config.bss[i].bssid);
+	ubus.call("wpa_supplicant", "phy_set_macaddr_list", { phy: phy, macaddr: macaddr_list });
+}
+
 function iface_set_config(phy, config)
 {
 	let old_config = hostapd.data.config[phy];
 
 	hostapd.data.config[phy] = config;
 
-	if (!config) {
-		hostapd.remove_iface(phy);
+	if (!config)
 		return iface_remove(old_config);
-	}
 
 	let phydev = phy_open(phy);
 	if (!phydev) {
@@ -538,6 +534,7 @@
 
 	hostapd.printf(`Restart interface for phy ${phy}`);
 	let ret = iface_restart(phydev, config, old_config);
+	iface_update_supplicant_macaddr(phy, config);
 
 	return ret;
 }
@@ -670,7 +667,7 @@
 			if (!config || !config.bss || !config.bss[0] || !config.bss[0].ifname)
 				return 0;
 
-			let iface = hostapd.interfaces[phy];
+			let iface = hostapd.interfaces[config.bss[0].ifname];
 			if (!iface)
 				return 0;
 
