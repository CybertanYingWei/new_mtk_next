--- a/interfaces/opensync_stats.proto
+++ b/interfaces/opensync_stats.proto
@@ -146,6 +146,13 @@ enum DiffType {
     REMOVED                                 = 1;
 }
 
+enum StreamingVideoType {
+	UNKNOWN = 0;
+	NETFLIX = 1;
+	YOUTUBE = 2;
+	PLEX = 3;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //
 // Neighbor report: Report contains OBSS neighbor nodes/beacons retreived from
@@ -543,6 +550,120 @@ message NetworkProbe {
     repeated RADIUSMetrics  radius_probe = 3;
     optional uint64         timestamp_ms = 4;
 }
+
+////////////////////////////////////////////////////////////////////////////////
+//
+// Voice and Video Stats
+//
+// - Contains voice/video detection information
+//
+////////////////////////////////////////////////////////////////////////////////
+message RtpFlowStats {
+	enum RtpFlowDirection {
+		RTP_UPSTREAM = 0;
+		RTP_DOWNSTREAM = 1;
+	}
+
+	enum RtpFlowType {
+		RTP_VOICE = 0;
+		RTP_VIDEO = 1;
+	}
+
+	optional RtpFlowDirection direction = 1;
+	optional RtpFlowType rtp_flow_type = 2;
+	optional uint32 latency = 3;
+	optional uint32 jitter = 4;
+	optional uint32 packet_loss_percent = 5;
+	optional uint32 packet_loss_consec = 6;
+	optional uint32 codec = 7;
+	optional uint32 mosx_100 = 8;
+	optional bytes block_codecs = 9;
+	optional uint32 total_packets_sent = 10;
+	optional uint32 total_packets_lost = 11;
+	optional uint32 rtp_seq_first = 12;
+	optional uint32 rtp_seq_last = 13;
+	optional uint32 stats_idx = 14;
+}
+
+message CallStart {
+	optional uint64 session_id = 1;
+	optional uint64 wifi_session_id = 2;
+	optional bytes client_mac = 3;
+	repeated string codecs = 4;
+	optional string provider_domain = 5;
+	optional string device_info = 6;
+}
+
+message CallStop {
+	enum CallStopReason {
+		BYE_OK = 0;
+		CALL_DROPPED = 1;
+	}
+
+	optional uint64 session_id = 1;
+	optional uint64 wifi_session_id = 2;
+	optional bytes client_mac = 3;
+	optional CallStopReason reason = 4;
+	optional uint32 call_duration = 5;
+	repeated RtpFlowStats stats = 6;
+}
+
+message CallReport {
+	enum CallReportReason {
+		ROAMED_FROM = 0;
+		ROAMED_TO = 1;
+		GOT_PUBLISH = 2;
+	}
+
+	optional uint64 session_id = 1;
+	optional uint64 wifi_session_id = 2;
+	optional bytes client_mac = 3;
+	repeated RtpFlowStats stats = 4;
+	optional CallReportReason reason = 5;
+}
+
+message StreamingVideoDetectPattern {
+	optional string dns_lookup_pattern = 1; // DNS name pattern for detection (like *.nflxvideo.net)
+	optional StreamingVideoType video_type = 2;
+}
+
+message StreamingVideoSessionStart {
+	optional uint64 video_session_id = 1;
+	optional uint64 session_id = 2;
+	optional bytes client_mac = 3;
+	optional bytes server_ip = 4;
+	optional StreamingVideoType streaming_video_type = 5;
+}
+
+message StreamingVideoServerDetected {
+	optional uint64 video_session_id = 1;
+	optional uint64 session_id = 2;
+	optional bytes client_mac = 3;
+	optional bytes server_ip = 4;
+	optional string server_dns_name = 5;
+	optional StreamingVideoType streaming_video_type = 6;
+}
+
+message StreamingVideoStop {
+	optional uint64 video_session_id = 1;
+	optional uint64 session_id = 2;
+	optional bytes client_mac = 3;
+	optional bytes server_ip = 4;
+	optional uint64 total_bytes = 5;
+	optional StreamingVideoType streaming_video_type = 6;
+	optional uint32 duration_sec = 7;
+}
+
+message VideoVoiceReport {
+	optional CallStart call_start = 1;
+	optional CallStop call_stop = 2;
+	optional CallReport call_report = 3;
+	optional StreamingVideoStop stream_video_stop = 4;
+	optional StreamingVideoServerDetected stream_video_server = 5;
+	optional StreamingVideoSessionStart stream_video_session_start = 6;
+	optional uint64 timestamp_ms = 7;
+}
+
 ////////////////////////////////////////////////////////////////////////////////
 //
 // Overall report that might contain all individual stats reports
@@ -557,5 +678,6 @@ message Report {
     repeated Device         device          = 6;
     repeated BSReport       bs_report       = 7;
     repeated RssiReport     rssi_report     = 8;
+    repeated VideoVoiceReport video_voice_report = 9;
     repeated NetworkProbe   network_probe   = 101;
 }
--- a/src/lib/datapipeline/inc/opensync_stats.pb-c.h
+++ b/src/lib/datapipeline/inc/opensync_stats.pb-c.h
@@ -10,7 +10,7 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1003003 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
@@ -52,6 +52,15 @@ typedef struct _Sts__DNSProbeMetric Sts_
 typedef struct _Sts__VLANMetrics Sts__VLANMetrics;
 typedef struct _Sts__RADIUSMetrics Sts__RADIUSMetrics;
 typedef struct _Sts__NetworkProbe Sts__NetworkProbe;
+typedef struct _Sts__RtpFlowStats Sts__RtpFlowStats;
+typedef struct _Sts__CallStart Sts__CallStart;
+typedef struct _Sts__CallStop Sts__CallStop;
+typedef struct _Sts__CallReport Sts__CallReport;
+typedef struct _Sts__StreamingVideoDetectPattern Sts__StreamingVideoDetectPattern;
+typedef struct _Sts__StreamingVideoSessionStart Sts__StreamingVideoSessionStart;
+typedef struct _Sts__StreamingVideoServerDetected Sts__StreamingVideoServerDetected;
+typedef struct _Sts__StreamingVideoStop Sts__StreamingVideoStop;
+typedef struct _Sts__VideoVoiceReport Sts__VideoVoiceReport;
 typedef struct _Sts__Report Sts__Report;
 
 
@@ -63,6 +72,27 @@ typedef enum _Sts__RssiPeer__RssiSource
   STS__RSSI_PEER__RSSI_SOURCE__NEIGHBOR = 2
     PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__RSSI_PEER__RSSI_SOURCE)
 } Sts__RssiPeer__RssiSource;
+typedef enum _Sts__RtpFlowStats__RtpFlowDirection {
+  STS__RTP_FLOW_STATS__RTP_FLOW_DIRECTION__RTP_UPSTREAM = 0,
+  STS__RTP_FLOW_STATS__RTP_FLOW_DIRECTION__RTP_DOWNSTREAM = 1
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__RTP_FLOW_STATS__RTP_FLOW_DIRECTION)
+} Sts__RtpFlowStats__RtpFlowDirection;
+typedef enum _Sts__RtpFlowStats__RtpFlowType {
+  STS__RTP_FLOW_STATS__RTP_FLOW_TYPE__RTP_VOICE = 0,
+  STS__RTP_FLOW_STATS__RTP_FLOW_TYPE__RTP_VIDEO = 1
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__RTP_FLOW_STATS__RTP_FLOW_TYPE)
+} Sts__RtpFlowStats__RtpFlowType;
+typedef enum _Sts__CallStop__CallStopReason {
+  STS__CALL_STOP__CALL_STOP_REASON__BYE_OK = 0,
+  STS__CALL_STOP__CALL_STOP_REASON__CALL_DROPPED = 1
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__CALL_STOP__CALL_STOP_REASON)
+} Sts__CallStop__CallStopReason;
+typedef enum _Sts__CallReport__CallReportReason {
+  STS__CALL_REPORT__CALL_REPORT_REASON__ROAMED_FROM = 0,
+  STS__CALL_REPORT__CALL_REPORT_REASON__ROAMED_TO = 1,
+  STS__CALL_REPORT__CALL_REPORT_REASON__GOT_PUBLISH = 2
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__CALL_REPORT__CALL_REPORT_REASON)
+} Sts__CallReport__CallReportReason;
 typedef enum _Sts__RadioBandType {
   STS__RADIO_BAND_TYPE__BAND2G = 0,
   STS__RADIO_BAND_TYPE__BAND5G = 1,
@@ -174,6 +204,13 @@ typedef enum _Sts__DiffType {
   STS__DIFF_TYPE__REMOVED = 1
     PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__DIFF_TYPE)
 } Sts__DiffType;
+typedef enum _Sts__StreamingVideoType {
+  STS__STREAMING_VIDEO_TYPE__UNKNOWN = 0,
+  STS__STREAMING_VIDEO_TYPE__NETFLIX = 1,
+  STS__STREAMING_VIDEO_TYPE__YOUTUBE = 2,
+  STS__STREAMING_VIDEO_TYPE__PLEX = 3
+    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(STS__STREAMING_VIDEO_TYPE)
+} Sts__StreamingVideoType;
 /*
  * //////////////////////////////////////////////////////////////////////////////
  * Network probe parameters
@@ -201,7 +238,7 @@ struct  _Sts__AvgType
 };
 #define STS__AVG_TYPE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__avg_type__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0 }
+    , 0, 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Neighbor__NeighborBss
@@ -221,7 +258,7 @@ struct  _Sts__Neighbor__NeighborBss
 };
 #define STS__NEIGHBOR__NEIGHBOR_BSS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__neighbor__neighbor_bss__descriptor) \
-    , NULL, NULL, 0, 0, 0, 0, 0, STS__CHAN_WIDTH__CHAN_WIDTH_UNKNOWN, 0, 0, STS__DIFF_TYPE__ADDED }
+    , NULL, NULL, 0,0, 0,0, 0,0, 0, 0,0 }
 
 
 /*
@@ -247,7 +284,7 @@ struct  _Sts__Neighbor
 };
 #define STS__NEIGHBOR__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__neighbor__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, STS__NEIGHBOR_TYPE__ONCHAN_SCAN, 0, 0, 0,NULL, 0, STS__REPORT_TYPE__RAW }
+    , 0, 0, 0,0, 0,NULL, 0,0 }
 
 
 struct  _Sts__Client__Stats
@@ -278,7 +315,7 @@ struct  _Sts__Client__Stats
 };
 #define STS__CLIENT__STATS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__stats__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Client__RxStats__ChainRSSI
@@ -294,7 +331,7 @@ struct  _Sts__Client__RxStats__ChainRSSI
 };
 #define STS__CLIENT__RX_STATS__CHAIN_RSSI__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__rx_stats__chain_rssi__descriptor) \
-    , 0, 0, 0, 0 }
+    , 0, 0, 0,0 }
 
 
 struct  _Sts__Client__RxStats
@@ -322,7 +359,7 @@ struct  _Sts__Client__RxStats
 };
 #define STS__CLIENT__RX_STATS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__rx_stats__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL }
+    , 0, 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,NULL }
 
 
 struct  _Sts__Client__TxStats
@@ -346,7 +383,7 @@ struct  _Sts__Client__TxStats
 };
 #define STS__CLIENT__TX_STATS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__tx_stats__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+    , 0, 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Client__TidStats__Sojourn
@@ -378,7 +415,7 @@ struct  _Sts__Client__TidStats__Sojourn
 };
 #define STS__CLIENT__TID_STATS__SOJOURN__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__tid_stats__sojourn__descriptor) \
-    , STS__WMM_AC__WMM_AC_VO, 0, 0, 0, 0, 0, 0, 0 }
+    , 0, 0, 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Client__TidStats
@@ -391,7 +428,7 @@ struct  _Sts__Client__TidStats
 };
 #define STS__CLIENT__TID_STATS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__tid_stats__descriptor) \
-    , 0,NULL, 0, 0 }
+    , 0,NULL, 0,0 }
 
 
 /*
@@ -426,7 +463,7 @@ struct  _Sts__Client__ConnectionEvent
 };
 #define STS__CLIENT__CONNECTION_EVENT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__connection_event__descriptor) \
-    , STS__CONNECTION_EVENT_TYPE__CLIENT_ASSOC, NULL, 0, 0, NULL, 0, STS__RADIO_BAND_TYPE__BAND2G, 0, STS__ASSOC_TYPE__ASSOC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+    , 0, NULL, 0,0, NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }
 
 
 /*
@@ -467,7 +504,7 @@ struct  _Sts__Client
 };
 #define STS__CLIENT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client__descriptor) \
-    , NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL, 0,NULL, 0,NULL, 0,NULL, 0, 0, 0,NULL }
+    , NULL, NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, NULL, 0,NULL, 0,NULL, 0,NULL, 0,0, 0,NULL }
 
 
 struct  _Sts__ClientReport
@@ -482,7 +519,7 @@ struct  _Sts__ClientReport
 };
 #define STS__CLIENT_REPORT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__client_report__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, 0, 0, 0,NULL, 0 }
+    , 0, 0,0, 0,NULL, 0 }
 
 
 struct  _Sts__Survey__SurveySample
@@ -527,7 +564,7 @@ struct  _Sts__Survey__SurveySample
 };
 #define STS__SURVEY__SURVEY_SAMPLE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__survey__survey_sample__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+    , 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Survey__SurveyAvg
@@ -585,7 +622,7 @@ struct  _Sts__Survey
 };
 #define STS__SURVEY__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__survey__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, STS__SURVEY_TYPE__ON_CHANNEL, 0, 0, 0,NULL, 0,NULL, 0, STS__REPORT_TYPE__RAW }
+    , 0, 0, 0,0, 0,NULL, 0,NULL, 0,0 }
 
 
 struct  _Sts__Capacity__QueueSample
@@ -632,7 +669,7 @@ struct  _Sts__Capacity__QueueSample
 };
 #define STS__CAPACITY__QUEUE_SAMPLE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__capacity__queue_sample__descriptor) \
-    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 }
 
 
 /*
@@ -651,7 +688,7 @@ struct  _Sts__Capacity
 };
 #define STS__CAPACITY__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__capacity__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, 0, 0, 0,NULL }
+    , 0, 0,0, 0,NULL }
 
 
 struct  _Sts__Device__LoadAvg
@@ -666,7 +703,7 @@ struct  _Sts__Device__LoadAvg
 };
 #define STS__DEVICE__LOAD_AVG__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__load_avg__descriptor) \
-    , 0, 0, 0, 0, 0, 0 }
+    , 0,0, 0,0, 0,0 }
 
 
 struct  _Sts__Device__RadioTemp
@@ -679,7 +716,7 @@ struct  _Sts__Device__RadioTemp
 };
 #define STS__DEVICE__RADIO_TEMP__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__radio_temp__descriptor) \
-    , 0, STS__RADIO_BAND_TYPE__BAND2G, 0, 0 }
+    , 0,0, 0,0 }
 
 
 struct  _Sts__Device__Thermal__RadioTxChainMask
@@ -692,7 +729,7 @@ struct  _Sts__Device__Thermal__RadioTxCh
 };
 #define STS__DEVICE__THERMAL__RADIO_TX_CHAIN_MASK__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__thermal__radio_tx_chain_mask__descriptor) \
-    , 0, STS__RADIO_BAND_TYPE__BAND2G, 0, 0 }
+    , 0,0, 0,0 }
 
 
 struct  _Sts__Device__Thermal
@@ -707,7 +744,7 @@ struct  _Sts__Device__Thermal
 };
 #define STS__DEVICE__THERMAL__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__thermal__descriptor) \
-    , 0,NULL, 0, 0, 0, 0 }
+    , 0,NULL, 0,0, 0,0 }
 
 
 /*
@@ -725,7 +762,7 @@ struct  _Sts__Device__MemUtil
 };
 #define STS__DEVICE__MEM_UTIL__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__mem_util__descriptor) \
-    , 0, 0, 0, 0, 0, 0 }
+    , 0, 0, 0,0, 0,0 }
 
 
 /*
@@ -740,7 +777,7 @@ struct  _Sts__Device__FsUtil
 };
 #define STS__DEVICE__FS_UTIL__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__fs_util__descriptor) \
-    , STS__FS_TYPE__FS_TYPE_ROOTFS, 0, 0 }
+    , 0, 0, 0 }
 
 
 /*
@@ -754,7 +791,7 @@ struct  _Sts__Device__CpuUtil
 };
 #define STS__DEVICE__CPU_UTIL__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__cpu_util__descriptor) \
-    , 0, 0 }
+    , 0,0 }
 
 
 /*
@@ -806,7 +843,7 @@ struct  _Sts__Device
 };
 #define STS__DEVICE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__device__descriptor) \
-    , NULL, 0,NULL, 0, 0, 0, 0, 0,NULL, NULL, 0,NULL, NULL, 0,NULL, 0,NULL }
+    , NULL, 0,NULL, 0,0, 0,0, 0,NULL, NULL, 0,NULL, NULL, 0,NULL, 0,NULL }
 
 
 struct  _Sts__BSClient__BSEvent
@@ -875,7 +912,7 @@ struct  _Sts__BSClient__BSEvent
 };
 #define STS__BSCLIENT__BSEVENT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__bsclient__bsevent__descriptor) \
-    , STS__BSEVENT_TYPE__PROBE, 0, 0, 0, 0, 0, 0, 0, 0, STS__DISCONNECT_SRC__LOCAL, 0, STS__DISCONNECT_TYPE__DISASSOC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0,NULL} }
+    , 0, 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,{0,NULL} }
 
 
 struct  _Sts__BSClient__BSBandReport
@@ -914,7 +951,7 @@ struct  _Sts__BSClient__BSBandReport
 };
 #define STS__BSCLIENT__BSBAND_REPORT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__bsclient__bsband_report__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL, NULL }
+    , 0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,NULL, NULL }
 
 
 /*
@@ -957,7 +994,7 @@ struct  _Sts__RssiPeer__RssiSample
 };
 #define STS__RSSI_PEER__RSSI_SAMPLE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__rssi_peer__rssi_sample__descriptor) \
-    , 0, 0, 0 }
+    , 0, 0,0 }
 
 
 /*
@@ -983,7 +1020,7 @@ struct  _Sts__RssiPeer
 };
 #define STS__RSSI_PEER__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__rssi_peer__descriptor) \
-    , NULL, 0, STS__RSSI_PEER__RSSI_SOURCE__CLIENT, 0,NULL, NULL, 0, 0, 0, 0 }
+    , NULL, 0,0, 0,NULL, NULL, 0,0, 0,0 }
 
 
 struct  _Sts__RssiReport
@@ -998,7 +1035,7 @@ struct  _Sts__RssiReport
 };
 #define STS__RSSI_REPORT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__rssi_report__descriptor) \
-    , STS__RADIO_BAND_TYPE__BAND2G, STS__REPORT_TYPE__RAW, 0, 0, 0,NULL }
+    , 0, 0, 0,0, 0,NULL }
 
 
 struct  _Sts__DNSProbeMetric
@@ -1018,7 +1055,7 @@ struct  _Sts__DNSProbeMetric
 };
 #define STS__DNSPROBE_METRIC__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__dnsprobe_metric__descriptor) \
-    , NULL, 0, STS__STATE_UP_DOWN__SUD_down, 0, 0 }
+    , NULL, 0,0, 0,0 }
 
 
 struct  _Sts__VLANMetrics
@@ -1038,7 +1075,7 @@ struct  _Sts__VLANMetrics
 };
 #define STS__VLANMETRICS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__vlanmetrics__descriptor) \
-    , NULL, 0, STS__STATE_UP_DOWN__SUD_down, 0, 0 }
+    , NULL, 0,0, 0,0 }
 
 
 struct  _Sts__RADIUSMetrics
@@ -1052,7 +1089,7 @@ struct  _Sts__RADIUSMetrics
 };
 #define STS__RADIUSMETRICS__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__radiusmetrics__descriptor) \
-    , NULL, 0, STS__STATE_UP_DOWN__SUD_down, 0, 0 }
+    , NULL, 0,0, 0,0 }
 
 
 struct  _Sts__NetworkProbe
@@ -1067,7 +1104,203 @@ struct  _Sts__NetworkProbe
 };
 #define STS__NETWORK_PROBE__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__network_probe__descriptor) \
-    , NULL, NULL, 0,NULL, 0, 0 }
+    , NULL, NULL, 0,NULL, 0,0 }
+
+
+/*
+ * //////////////////////////////////////////////////////////////////////////////
+ * Voice and Video Stats
+ * - Contains voice/video detection information
+ * //////////////////////////////////////////////////////////////////////////////
+ */
+struct  _Sts__RtpFlowStats
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_direction;
+  Sts__RtpFlowStats__RtpFlowDirection direction;
+  protobuf_c_boolean has_rtp_flow_type;
+  Sts__RtpFlowStats__RtpFlowType rtp_flow_type;
+  protobuf_c_boolean has_latency;
+  uint32_t latency;
+  protobuf_c_boolean has_jitter;
+  uint32_t jitter;
+  protobuf_c_boolean has_packet_loss_percent;
+  uint32_t packet_loss_percent;
+  protobuf_c_boolean has_packet_loss_consec;
+  uint32_t packet_loss_consec;
+  protobuf_c_boolean has_codec;
+  uint32_t codec;
+  protobuf_c_boolean has_mosx_100;
+  uint32_t mosx_100;
+  protobuf_c_boolean has_block_codecs;
+  ProtobufCBinaryData block_codecs;
+  protobuf_c_boolean has_total_packets_sent;
+  uint32_t total_packets_sent;
+  protobuf_c_boolean has_total_packets_lost;
+  uint32_t total_packets_lost;
+  protobuf_c_boolean has_rtp_seq_first;
+  uint32_t rtp_seq_first;
+  protobuf_c_boolean has_rtp_seq_last;
+  uint32_t rtp_seq_last;
+  protobuf_c_boolean has_stats_idx;
+  uint32_t stats_idx;
+};
+#define STS__RTP_FLOW_STATS__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__rtp_flow_stats__descriptor) \
+    , 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,{0,NULL}, 0,0, 0,0, 0,0, 0,0, 0,0 }
+
+
+struct  _Sts__CallStart
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_wifi_session_id;
+  uint64_t wifi_session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  size_t n_codecs;
+  char **codecs;
+  char *provider_domain;
+  char *device_info;
+};
+#define STS__CALL_START__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__call_start__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,NULL, NULL, NULL }
+
+
+struct  _Sts__CallStop
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_wifi_session_id;
+  uint64_t wifi_session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  protobuf_c_boolean has_reason;
+  Sts__CallStop__CallStopReason reason;
+  protobuf_c_boolean has_call_duration;
+  uint32_t call_duration;
+  size_t n_stats;
+  Sts__RtpFlowStats **stats;
+};
+#define STS__CALL_STOP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__call_stop__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,0, 0,0, 0,NULL }
+
+
+struct  _Sts__CallReport
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_wifi_session_id;
+  uint64_t wifi_session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  size_t n_stats;
+  Sts__RtpFlowStats **stats;
+  protobuf_c_boolean has_reason;
+  Sts__CallReport__CallReportReason reason;
+};
+#define STS__CALL_REPORT__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__call_report__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,NULL, 0,0 }
+
+
+struct  _Sts__StreamingVideoDetectPattern
+{
+  ProtobufCMessage base;
+  /*
+   * DNS name pattern for detection (like *.nflxvideo.net)
+   */
+  char *dns_lookup_pattern;
+  protobuf_c_boolean has_video_type;
+  Sts__StreamingVideoType video_type;
+};
+#define STS__STREAMING_VIDEO_DETECT_PATTERN__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__streaming_video_detect_pattern__descriptor) \
+    , NULL, 0,0 }
+
+
+struct  _Sts__StreamingVideoSessionStart
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_video_session_id;
+  uint64_t video_session_id;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  protobuf_c_boolean has_server_ip;
+  ProtobufCBinaryData server_ip;
+  protobuf_c_boolean has_streaming_video_type;
+  Sts__StreamingVideoType streaming_video_type;
+};
+#define STS__STREAMING_VIDEO_SESSION_START__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__streaming_video_session_start__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,{0,NULL}, 0,0 }
+
+
+struct  _Sts__StreamingVideoServerDetected
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_video_session_id;
+  uint64_t video_session_id;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  protobuf_c_boolean has_server_ip;
+  ProtobufCBinaryData server_ip;
+  char *server_dns_name;
+  protobuf_c_boolean has_streaming_video_type;
+  Sts__StreamingVideoType streaming_video_type;
+};
+#define STS__STREAMING_VIDEO_SERVER_DETECTED__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__streaming_video_server_detected__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,{0,NULL}, NULL, 0,0 }
+
+
+struct  _Sts__StreamingVideoStop
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_video_session_id;
+  uint64_t video_session_id;
+  protobuf_c_boolean has_session_id;
+  uint64_t session_id;
+  protobuf_c_boolean has_client_mac;
+  ProtobufCBinaryData client_mac;
+  protobuf_c_boolean has_server_ip;
+  ProtobufCBinaryData server_ip;
+  protobuf_c_boolean has_total_bytes;
+  uint64_t total_bytes;
+  protobuf_c_boolean has_streaming_video_type;
+  Sts__StreamingVideoType streaming_video_type;
+  protobuf_c_boolean has_duration_sec;
+  uint32_t duration_sec;
+};
+#define STS__STREAMING_VIDEO_STOP__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__streaming_video_stop__descriptor) \
+    , 0,0, 0,0, 0,{0,NULL}, 0,{0,NULL}, 0,0, 0,0, 0,0 }
+
+
+struct  _Sts__VideoVoiceReport
+{
+  ProtobufCMessage base;
+  Sts__CallStart *call_start;
+  Sts__CallStop *call_stop;
+  Sts__CallReport *call_report;
+  Sts__StreamingVideoStop *stream_video_stop;
+  Sts__StreamingVideoServerDetected *stream_video_server;
+  Sts__StreamingVideoSessionStart *stream_video_session_start;
+  protobuf_c_boolean has_timestamp_ms;
+  uint64_t timestamp_ms;
+};
+#define STS__VIDEO_VOICE_REPORT__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&sts__video_voice_report__descriptor) \
+    , NULL, NULL, NULL, NULL, NULL, NULL, 0,0 }
 
 
 /*
@@ -1093,12 +1326,14 @@ struct  _Sts__Report
   Sts__BSReport **bs_report;
   size_t n_rssi_report;
   Sts__RssiReport **rssi_report;
+  size_t n_video_voice_report;
+  Sts__VideoVoiceReport **video_voice_report;
   size_t n_network_probe;
   Sts__NetworkProbe **network_probe;
 };
 #define STS__REPORT__INIT \
  { PROTOBUF_C_MESSAGE_INIT (&sts__report__descriptor) \
-    , NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }
+    , NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL, 0,NULL }
 
 
 /* Sts__AvgType methods */
@@ -1452,6 +1687,177 @@ Sts__NetworkProbe *
 void   sts__network_probe__free_unpacked
                      (Sts__NetworkProbe *message,
                       ProtobufCAllocator *allocator);
+/* Sts__RtpFlowStats methods */
+void   sts__rtp_flow_stats__init
+                     (Sts__RtpFlowStats         *message);
+size_t sts__rtp_flow_stats__get_packed_size
+                     (const Sts__RtpFlowStats   *message);
+size_t sts__rtp_flow_stats__pack
+                     (const Sts__RtpFlowStats   *message,
+                      uint8_t             *out);
+size_t sts__rtp_flow_stats__pack_to_buffer
+                     (const Sts__RtpFlowStats   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__RtpFlowStats *
+       sts__rtp_flow_stats__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__rtp_flow_stats__free_unpacked
+                     (Sts__RtpFlowStats *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__CallStart methods */
+void   sts__call_start__init
+                     (Sts__CallStart         *message);
+size_t sts__call_start__get_packed_size
+                     (const Sts__CallStart   *message);
+size_t sts__call_start__pack
+                     (const Sts__CallStart   *message,
+                      uint8_t             *out);
+size_t sts__call_start__pack_to_buffer
+                     (const Sts__CallStart   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__CallStart *
+       sts__call_start__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__call_start__free_unpacked
+                     (Sts__CallStart *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__CallStop methods */
+void   sts__call_stop__init
+                     (Sts__CallStop         *message);
+size_t sts__call_stop__get_packed_size
+                     (const Sts__CallStop   *message);
+size_t sts__call_stop__pack
+                     (const Sts__CallStop   *message,
+                      uint8_t             *out);
+size_t sts__call_stop__pack_to_buffer
+                     (const Sts__CallStop   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__CallStop *
+       sts__call_stop__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__call_stop__free_unpacked
+                     (Sts__CallStop *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__CallReport methods */
+void   sts__call_report__init
+                     (Sts__CallReport         *message);
+size_t sts__call_report__get_packed_size
+                     (const Sts__CallReport   *message);
+size_t sts__call_report__pack
+                     (const Sts__CallReport   *message,
+                      uint8_t             *out);
+size_t sts__call_report__pack_to_buffer
+                     (const Sts__CallReport   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__CallReport *
+       sts__call_report__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__call_report__free_unpacked
+                     (Sts__CallReport *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__StreamingVideoDetectPattern methods */
+void   sts__streaming_video_detect_pattern__init
+                     (Sts__StreamingVideoDetectPattern         *message);
+size_t sts__streaming_video_detect_pattern__get_packed_size
+                     (const Sts__StreamingVideoDetectPattern   *message);
+size_t sts__streaming_video_detect_pattern__pack
+                     (const Sts__StreamingVideoDetectPattern   *message,
+                      uint8_t             *out);
+size_t sts__streaming_video_detect_pattern__pack_to_buffer
+                     (const Sts__StreamingVideoDetectPattern   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__StreamingVideoDetectPattern *
+       sts__streaming_video_detect_pattern__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__streaming_video_detect_pattern__free_unpacked
+                     (Sts__StreamingVideoDetectPattern *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__StreamingVideoSessionStart methods */
+void   sts__streaming_video_session_start__init
+                     (Sts__StreamingVideoSessionStart         *message);
+size_t sts__streaming_video_session_start__get_packed_size
+                     (const Sts__StreamingVideoSessionStart   *message);
+size_t sts__streaming_video_session_start__pack
+                     (const Sts__StreamingVideoSessionStart   *message,
+                      uint8_t             *out);
+size_t sts__streaming_video_session_start__pack_to_buffer
+                     (const Sts__StreamingVideoSessionStart   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__StreamingVideoSessionStart *
+       sts__streaming_video_session_start__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__streaming_video_session_start__free_unpacked
+                     (Sts__StreamingVideoSessionStart *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__StreamingVideoServerDetected methods */
+void   sts__streaming_video_server_detected__init
+                     (Sts__StreamingVideoServerDetected         *message);
+size_t sts__streaming_video_server_detected__get_packed_size
+                     (const Sts__StreamingVideoServerDetected   *message);
+size_t sts__streaming_video_server_detected__pack
+                     (const Sts__StreamingVideoServerDetected   *message,
+                      uint8_t             *out);
+size_t sts__streaming_video_server_detected__pack_to_buffer
+                     (const Sts__StreamingVideoServerDetected   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__StreamingVideoServerDetected *
+       sts__streaming_video_server_detected__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__streaming_video_server_detected__free_unpacked
+                     (Sts__StreamingVideoServerDetected *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__StreamingVideoStop methods */
+void   sts__streaming_video_stop__init
+                     (Sts__StreamingVideoStop         *message);
+size_t sts__streaming_video_stop__get_packed_size
+                     (const Sts__StreamingVideoStop   *message);
+size_t sts__streaming_video_stop__pack
+                     (const Sts__StreamingVideoStop   *message,
+                      uint8_t             *out);
+size_t sts__streaming_video_stop__pack_to_buffer
+                     (const Sts__StreamingVideoStop   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__StreamingVideoStop *
+       sts__streaming_video_stop__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__streaming_video_stop__free_unpacked
+                     (Sts__StreamingVideoStop *message,
+                      ProtobufCAllocator *allocator);
+/* Sts__VideoVoiceReport methods */
+void   sts__video_voice_report__init
+                     (Sts__VideoVoiceReport         *message);
+size_t sts__video_voice_report__get_packed_size
+                     (const Sts__VideoVoiceReport   *message);
+size_t sts__video_voice_report__pack
+                     (const Sts__VideoVoiceReport   *message,
+                      uint8_t             *out);
+size_t sts__video_voice_report__pack_to_buffer
+                     (const Sts__VideoVoiceReport   *message,
+                      ProtobufCBuffer     *buffer);
+Sts__VideoVoiceReport *
+       sts__video_voice_report__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   sts__video_voice_report__free_unpacked
+                     (Sts__VideoVoiceReport *message,
+                      ProtobufCAllocator *allocator);
 /* Sts__Report methods */
 void   sts__report__init
                      (Sts__Report         *message);
@@ -1584,6 +1990,33 @@ typedef void (*Sts__RADIUSMetrics_Closur
 typedef void (*Sts__NetworkProbe_Closure)
                  (const Sts__NetworkProbe *message,
                   void *closure_data);
+typedef void (*Sts__RtpFlowStats_Closure)
+                 (const Sts__RtpFlowStats *message,
+                  void *closure_data);
+typedef void (*Sts__CallStart_Closure)
+                 (const Sts__CallStart *message,
+                  void *closure_data);
+typedef void (*Sts__CallStop_Closure)
+                 (const Sts__CallStop *message,
+                  void *closure_data);
+typedef void (*Sts__CallReport_Closure)
+                 (const Sts__CallReport *message,
+                  void *closure_data);
+typedef void (*Sts__StreamingVideoDetectPattern_Closure)
+                 (const Sts__StreamingVideoDetectPattern *message,
+                  void *closure_data);
+typedef void (*Sts__StreamingVideoSessionStart_Closure)
+                 (const Sts__StreamingVideoSessionStart *message,
+                  void *closure_data);
+typedef void (*Sts__StreamingVideoServerDetected_Closure)
+                 (const Sts__StreamingVideoServerDetected *message,
+                  void *closure_data);
+typedef void (*Sts__StreamingVideoStop_Closure)
+                 (const Sts__StreamingVideoStop *message,
+                  void *closure_data);
+typedef void (*Sts__VideoVoiceReport_Closure)
+                 (const Sts__VideoVoiceReport *message,
+                  void *closure_data);
 typedef void (*Sts__Report_Closure)
                  (const Sts__Report *message,
                   void *closure_data);
@@ -1606,6 +2039,7 @@ extern const ProtobufCEnumDescriptor
 extern const ProtobufCEnumDescriptor    sts__report_type__descriptor;
 extern const ProtobufCEnumDescriptor    sts__fs_type__descriptor;
 extern const ProtobufCEnumDescriptor    sts__diff_type__descriptor;
+extern const ProtobufCEnumDescriptor    sts__streaming_video_type__descriptor;
 extern const ProtobufCEnumDescriptor    sts__state_up_down__descriptor;
 extern const ProtobufCMessageDescriptor sts__avg_type__descriptor;
 extern const ProtobufCMessageDescriptor sts__neighbor__descriptor;
@@ -1645,6 +2079,19 @@ extern const ProtobufCMessageDescriptor
 extern const ProtobufCMessageDescriptor sts__vlanmetrics__descriptor;
 extern const ProtobufCMessageDescriptor sts__radiusmetrics__descriptor;
 extern const ProtobufCMessageDescriptor sts__network_probe__descriptor;
+extern const ProtobufCMessageDescriptor sts__rtp_flow_stats__descriptor;
+extern const ProtobufCEnumDescriptor    sts__rtp_flow_stats__rtp_flow_direction__descriptor;
+extern const ProtobufCEnumDescriptor    sts__rtp_flow_stats__rtp_flow_type__descriptor;
+extern const ProtobufCMessageDescriptor sts__call_start__descriptor;
+extern const ProtobufCMessageDescriptor sts__call_stop__descriptor;
+extern const ProtobufCEnumDescriptor    sts__call_stop__call_stop_reason__descriptor;
+extern const ProtobufCMessageDescriptor sts__call_report__descriptor;
+extern const ProtobufCEnumDescriptor    sts__call_report__call_report_reason__descriptor;
+extern const ProtobufCMessageDescriptor sts__streaming_video_detect_pattern__descriptor;
+extern const ProtobufCMessageDescriptor sts__streaming_video_session_start__descriptor;
+extern const ProtobufCMessageDescriptor sts__streaming_video_server_detected__descriptor;
+extern const ProtobufCMessageDescriptor sts__streaming_video_stop__descriptor;
+extern const ProtobufCMessageDescriptor sts__video_voice_report__descriptor;
 extern const ProtobufCMessageDescriptor sts__report__descriptor;
 
 PROTOBUF_C__END_DECLS
--- a/src/lib/datapipeline/src/opensync_stats.pb-c.c
+++ b/src/lib/datapipeline/src/opensync_stats.pb-c.c
@@ -10,7 +10,7 @@
 void   sts__avg_type__init
                      (Sts__AvgType         *message)
 {
-  static const Sts__AvgType init_value = STS__AVG_TYPE__INIT;
+  static Sts__AvgType init_value = STS__AVG_TYPE__INIT;
   *message = init_value;
 }
 size_t sts__avg_type__get_packed_size
@@ -47,21 +47,19 @@ void   sts__avg_type__free_unpacked
                      (Sts__AvgType *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__avg_type__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__neighbor__neighbor_bss__init
                      (Sts__Neighbor__NeighborBss         *message)
 {
-  static const Sts__Neighbor__NeighborBss init_value = STS__NEIGHBOR__NEIGHBOR_BSS__INIT;
+  static Sts__Neighbor__NeighborBss init_value = STS__NEIGHBOR__NEIGHBOR_BSS__INIT;
   *message = init_value;
 }
 void   sts__neighbor__init
                      (Sts__Neighbor         *message)
 {
-  static const Sts__Neighbor init_value = STS__NEIGHBOR__INIT;
+  static Sts__Neighbor init_value = STS__NEIGHBOR__INIT;
   *message = init_value;
 }
 size_t sts__neighbor__get_packed_size
@@ -98,57 +96,55 @@ void   sts__neighbor__free_unpacked
                      (Sts__Neighbor *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__neighbor__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__client__stats__init
                      (Sts__Client__Stats         *message)
 {
-  static const Sts__Client__Stats init_value = STS__CLIENT__STATS__INIT;
+  static Sts__Client__Stats init_value = STS__CLIENT__STATS__INIT;
   *message = init_value;
 }
 void   sts__client__rx_stats__chain_rssi__init
                      (Sts__Client__RxStats__ChainRSSI         *message)
 {
-  static const Sts__Client__RxStats__ChainRSSI init_value = STS__CLIENT__RX_STATS__CHAIN_RSSI__INIT;
+  static Sts__Client__RxStats__ChainRSSI init_value = STS__CLIENT__RX_STATS__CHAIN_RSSI__INIT;
   *message = init_value;
 }
 void   sts__client__rx_stats__init
                      (Sts__Client__RxStats         *message)
 {
-  static const Sts__Client__RxStats init_value = STS__CLIENT__RX_STATS__INIT;
+  static Sts__Client__RxStats init_value = STS__CLIENT__RX_STATS__INIT;
   *message = init_value;
 }
 void   sts__client__tx_stats__init
                      (Sts__Client__TxStats         *message)
 {
-  static const Sts__Client__TxStats init_value = STS__CLIENT__TX_STATS__INIT;
+  static Sts__Client__TxStats init_value = STS__CLIENT__TX_STATS__INIT;
   *message = init_value;
 }
 void   sts__client__tid_stats__sojourn__init
                      (Sts__Client__TidStats__Sojourn         *message)
 {
-  static const Sts__Client__TidStats__Sojourn init_value = STS__CLIENT__TID_STATS__SOJOURN__INIT;
+  static Sts__Client__TidStats__Sojourn init_value = STS__CLIENT__TID_STATS__SOJOURN__INIT;
   *message = init_value;
 }
 void   sts__client__tid_stats__init
                      (Sts__Client__TidStats         *message)
 {
-  static const Sts__Client__TidStats init_value = STS__CLIENT__TID_STATS__INIT;
+  static Sts__Client__TidStats init_value = STS__CLIENT__TID_STATS__INIT;
   *message = init_value;
 }
 void   sts__client__connection_event__init
                      (Sts__Client__ConnectionEvent         *message)
 {
-  static const Sts__Client__ConnectionEvent init_value = STS__CLIENT__CONNECTION_EVENT__INIT;
+  static Sts__Client__ConnectionEvent init_value = STS__CLIENT__CONNECTION_EVENT__INIT;
   *message = init_value;
 }
 void   sts__client__init
                      (Sts__Client         *message)
 {
-  static const Sts__Client init_value = STS__CLIENT__INIT;
+  static Sts__Client init_value = STS__CLIENT__INIT;
   *message = init_value;
 }
 size_t sts__client__get_packed_size
@@ -185,15 +181,13 @@ void   sts__client__free_unpacked
                      (Sts__Client *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__client__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__client_report__init
                      (Sts__ClientReport         *message)
 {
-  static const Sts__ClientReport init_value = STS__CLIENT_REPORT__INIT;
+  static Sts__ClientReport init_value = STS__CLIENT_REPORT__INIT;
   *message = init_value;
 }
 size_t sts__client_report__get_packed_size
@@ -230,27 +224,25 @@ void   sts__client_report__free_unpacked
                      (Sts__ClientReport *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__client_report__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__survey__survey_sample__init
                      (Sts__Survey__SurveySample         *message)
 {
-  static const Sts__Survey__SurveySample init_value = STS__SURVEY__SURVEY_SAMPLE__INIT;
+  static Sts__Survey__SurveySample init_value = STS__SURVEY__SURVEY_SAMPLE__INIT;
   *message = init_value;
 }
 void   sts__survey__survey_avg__init
                      (Sts__Survey__SurveyAvg         *message)
 {
-  static const Sts__Survey__SurveyAvg init_value = STS__SURVEY__SURVEY_AVG__INIT;
+  static Sts__Survey__SurveyAvg init_value = STS__SURVEY__SURVEY_AVG__INIT;
   *message = init_value;
 }
 void   sts__survey__init
                      (Sts__Survey         *message)
 {
-  static const Sts__Survey init_value = STS__SURVEY__INIT;
+  static Sts__Survey init_value = STS__SURVEY__INIT;
   *message = init_value;
 }
 size_t sts__survey__get_packed_size
@@ -287,21 +279,19 @@ void   sts__survey__free_unpacked
                      (Sts__Survey *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__survey__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__capacity__queue_sample__init
                      (Sts__Capacity__QueueSample         *message)
 {
-  static const Sts__Capacity__QueueSample init_value = STS__CAPACITY__QUEUE_SAMPLE__INIT;
+  static Sts__Capacity__QueueSample init_value = STS__CAPACITY__QUEUE_SAMPLE__INIT;
   *message = init_value;
 }
 void   sts__capacity__init
                      (Sts__Capacity         *message)
 {
-  static const Sts__Capacity init_value = STS__CAPACITY__INIT;
+  static Sts__Capacity init_value = STS__CAPACITY__INIT;
   *message = init_value;
 }
 size_t sts__capacity__get_packed_size
@@ -338,63 +328,61 @@ void   sts__capacity__free_unpacked
                      (Sts__Capacity *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__capacity__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__device__load_avg__init
                      (Sts__Device__LoadAvg         *message)
 {
-  static const Sts__Device__LoadAvg init_value = STS__DEVICE__LOAD_AVG__INIT;
+  static Sts__Device__LoadAvg init_value = STS__DEVICE__LOAD_AVG__INIT;
   *message = init_value;
 }
 void   sts__device__radio_temp__init
                      (Sts__Device__RadioTemp         *message)
 {
-  static const Sts__Device__RadioTemp init_value = STS__DEVICE__RADIO_TEMP__INIT;
+  static Sts__Device__RadioTemp init_value = STS__DEVICE__RADIO_TEMP__INIT;
   *message = init_value;
 }
 void   sts__device__thermal__radio_tx_chain_mask__init
                      (Sts__Device__Thermal__RadioTxChainMask         *message)
 {
-  static const Sts__Device__Thermal__RadioTxChainMask init_value = STS__DEVICE__THERMAL__RADIO_TX_CHAIN_MASK__INIT;
+  static Sts__Device__Thermal__RadioTxChainMask init_value = STS__DEVICE__THERMAL__RADIO_TX_CHAIN_MASK__INIT;
   *message = init_value;
 }
 void   sts__device__thermal__init
                      (Sts__Device__Thermal         *message)
 {
-  static const Sts__Device__Thermal init_value = STS__DEVICE__THERMAL__INIT;
+  static Sts__Device__Thermal init_value = STS__DEVICE__THERMAL__INIT;
   *message = init_value;
 }
 void   sts__device__mem_util__init
                      (Sts__Device__MemUtil         *message)
 {
-  static const Sts__Device__MemUtil init_value = STS__DEVICE__MEM_UTIL__INIT;
+  static Sts__Device__MemUtil init_value = STS__DEVICE__MEM_UTIL__INIT;
   *message = init_value;
 }
 void   sts__device__fs_util__init
                      (Sts__Device__FsUtil         *message)
 {
-  static const Sts__Device__FsUtil init_value = STS__DEVICE__FS_UTIL__INIT;
+  static Sts__Device__FsUtil init_value = STS__DEVICE__FS_UTIL__INIT;
   *message = init_value;
 }
 void   sts__device__cpu_util__init
                      (Sts__Device__CpuUtil         *message)
 {
-  static const Sts__Device__CpuUtil init_value = STS__DEVICE__CPU_UTIL__INIT;
+  static Sts__Device__CpuUtil init_value = STS__DEVICE__CPU_UTIL__INIT;
   *message = init_value;
 }
 void   sts__device__per_process_util__init
                      (Sts__Device__PerProcessUtil         *message)
 {
-  static const Sts__Device__PerProcessUtil init_value = STS__DEVICE__PER_PROCESS_UTIL__INIT;
+  static Sts__Device__PerProcessUtil init_value = STS__DEVICE__PER_PROCESS_UTIL__INIT;
   *message = init_value;
 }
 void   sts__device__init
                      (Sts__Device         *message)
 {
-  static const Sts__Device init_value = STS__DEVICE__INIT;
+  static Sts__Device init_value = STS__DEVICE__INIT;
   *message = init_value;
 }
 size_t sts__device__get_packed_size
@@ -431,27 +419,25 @@ void   sts__device__free_unpacked
                      (Sts__Device *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__device__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__bsclient__bsevent__init
                      (Sts__BSClient__BSEvent         *message)
 {
-  static const Sts__BSClient__BSEvent init_value = STS__BSCLIENT__BSEVENT__INIT;
+  static Sts__BSClient__BSEvent init_value = STS__BSCLIENT__BSEVENT__INIT;
   *message = init_value;
 }
 void   sts__bsclient__bsband_report__init
                      (Sts__BSClient__BSBandReport         *message)
 {
-  static const Sts__BSClient__BSBandReport init_value = STS__BSCLIENT__BSBAND_REPORT__INIT;
+  static Sts__BSClient__BSBandReport init_value = STS__BSCLIENT__BSBAND_REPORT__INIT;
   *message = init_value;
 }
 void   sts__bsclient__init
                      (Sts__BSClient         *message)
 {
-  static const Sts__BSClient init_value = STS__BSCLIENT__INIT;
+  static Sts__BSClient init_value = STS__BSCLIENT__INIT;
   *message = init_value;
 }
 size_t sts__bsclient__get_packed_size
@@ -488,15 +474,13 @@ void   sts__bsclient__free_unpacked
                      (Sts__BSClient *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__bsclient__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__bsreport__init
                      (Sts__BSReport         *message)
 {
-  static const Sts__BSReport init_value = STS__BSREPORT__INIT;
+  static Sts__BSReport init_value = STS__BSREPORT__INIT;
   *message = init_value;
 }
 size_t sts__bsreport__get_packed_size
@@ -533,21 +517,19 @@ void   sts__bsreport__free_unpacked
                      (Sts__BSReport *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__bsreport__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__rssi_peer__rssi_sample__init
                      (Sts__RssiPeer__RssiSample         *message)
 {
-  static const Sts__RssiPeer__RssiSample init_value = STS__RSSI_PEER__RSSI_SAMPLE__INIT;
+  static Sts__RssiPeer__RssiSample init_value = STS__RSSI_PEER__RSSI_SAMPLE__INIT;
   *message = init_value;
 }
 void   sts__rssi_peer__init
                      (Sts__RssiPeer         *message)
 {
-  static const Sts__RssiPeer init_value = STS__RSSI_PEER__INIT;
+  static Sts__RssiPeer init_value = STS__RSSI_PEER__INIT;
   *message = init_value;
 }
 size_t sts__rssi_peer__get_packed_size
@@ -584,15 +566,13 @@ void   sts__rssi_peer__free_unpacked
                      (Sts__RssiPeer *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__rssi_peer__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__rssi_report__init
                      (Sts__RssiReport         *message)
 {
-  static const Sts__RssiReport init_value = STS__RSSI_REPORT__INIT;
+  static Sts__RssiReport init_value = STS__RSSI_REPORT__INIT;
   *message = init_value;
 }
 size_t sts__rssi_report__get_packed_size
@@ -629,15 +609,13 @@ void   sts__rssi_report__free_unpacked
                      (Sts__RssiReport *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__rssi_report__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__dnsprobe_metric__init
                      (Sts__DNSProbeMetric         *message)
 {
-  static const Sts__DNSProbeMetric init_value = STS__DNSPROBE_METRIC__INIT;
+  static Sts__DNSProbeMetric init_value = STS__DNSPROBE_METRIC__INIT;
   *message = init_value;
 }
 size_t sts__dnsprobe_metric__get_packed_size
@@ -674,15 +652,13 @@ void   sts__dnsprobe_metric__free_unpack
                      (Sts__DNSProbeMetric *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__dnsprobe_metric__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__vlanmetrics__init
                      (Sts__VLANMetrics         *message)
 {
-  static const Sts__VLANMetrics init_value = STS__VLANMETRICS__INIT;
+  static Sts__VLANMetrics init_value = STS__VLANMETRICS__INIT;
   *message = init_value;
 }
 size_t sts__vlanmetrics__get_packed_size
@@ -719,15 +695,13 @@ void   sts__vlanmetrics__free_unpacked
                      (Sts__VLANMetrics *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__vlanmetrics__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__radiusmetrics__init
                      (Sts__RADIUSMetrics         *message)
 {
-  static const Sts__RADIUSMetrics init_value = STS__RADIUSMETRICS__INIT;
+  static Sts__RADIUSMetrics init_value = STS__RADIUSMETRICS__INIT;
   *message = init_value;
 }
 size_t sts__radiusmetrics__get_packed_size
@@ -764,15 +738,13 @@ void   sts__radiusmetrics__free_unpacked
                      (Sts__RADIUSMetrics *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__radiusmetrics__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
 void   sts__network_probe__init
                      (Sts__NetworkProbe         *message)
 {
-  static const Sts__NetworkProbe init_value = STS__NETWORK_PROBE__INIT;
+  static Sts__NetworkProbe init_value = STS__NETWORK_PROBE__INIT;
   *message = init_value;
 }
 size_t sts__network_probe__get_packed_size
@@ -809,15 +781,400 @@ void   sts__network_probe__free_unpacked
                      (Sts__NetworkProbe *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__network_probe__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
+void   sts__rtp_flow_stats__init
+                     (Sts__RtpFlowStats         *message)
+{
+  static Sts__RtpFlowStats init_value = STS__RTP_FLOW_STATS__INIT;
+  *message = init_value;
+}
+size_t sts__rtp_flow_stats__get_packed_size
+                     (const Sts__RtpFlowStats *message)
+{
+  assert(message->base.descriptor == &sts__rtp_flow_stats__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__rtp_flow_stats__pack
+                     (const Sts__RtpFlowStats *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__rtp_flow_stats__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__rtp_flow_stats__pack_to_buffer
+                     (const Sts__RtpFlowStats *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__rtp_flow_stats__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__RtpFlowStats *
+       sts__rtp_flow_stats__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__RtpFlowStats *)
+     protobuf_c_message_unpack (&sts__rtp_flow_stats__descriptor,
+                                allocator, len, data);
+}
+void   sts__rtp_flow_stats__free_unpacked
+                     (Sts__RtpFlowStats *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__rtp_flow_stats__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__call_start__init
+                     (Sts__CallStart         *message)
+{
+  static Sts__CallStart init_value = STS__CALL_START__INIT;
+  *message = init_value;
+}
+size_t sts__call_start__get_packed_size
+                     (const Sts__CallStart *message)
+{
+  assert(message->base.descriptor == &sts__call_start__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__call_start__pack
+                     (const Sts__CallStart *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__call_start__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__call_start__pack_to_buffer
+                     (const Sts__CallStart *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__call_start__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__CallStart *
+       sts__call_start__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__CallStart *)
+     protobuf_c_message_unpack (&sts__call_start__descriptor,
+                                allocator, len, data);
+}
+void   sts__call_start__free_unpacked
+                     (Sts__CallStart *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__call_start__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__call_stop__init
+                     (Sts__CallStop         *message)
+{
+  static Sts__CallStop init_value = STS__CALL_STOP__INIT;
+  *message = init_value;
+}
+size_t sts__call_stop__get_packed_size
+                     (const Sts__CallStop *message)
+{
+  assert(message->base.descriptor == &sts__call_stop__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__call_stop__pack
+                     (const Sts__CallStop *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__call_stop__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__call_stop__pack_to_buffer
+                     (const Sts__CallStop *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__call_stop__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__CallStop *
+       sts__call_stop__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__CallStop *)
+     protobuf_c_message_unpack (&sts__call_stop__descriptor,
+                                allocator, len, data);
+}
+void   sts__call_stop__free_unpacked
+                     (Sts__CallStop *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__call_stop__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__call_report__init
+                     (Sts__CallReport         *message)
+{
+  static Sts__CallReport init_value = STS__CALL_REPORT__INIT;
+  *message = init_value;
+}
+size_t sts__call_report__get_packed_size
+                     (const Sts__CallReport *message)
+{
+  assert(message->base.descriptor == &sts__call_report__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__call_report__pack
+                     (const Sts__CallReport *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__call_report__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__call_report__pack_to_buffer
+                     (const Sts__CallReport *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__call_report__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__CallReport *
+       sts__call_report__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__CallReport *)
+     protobuf_c_message_unpack (&sts__call_report__descriptor,
+                                allocator, len, data);
+}
+void   sts__call_report__free_unpacked
+                     (Sts__CallReport *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__call_report__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__streaming_video_detect_pattern__init
+                     (Sts__StreamingVideoDetectPattern         *message)
+{
+  static Sts__StreamingVideoDetectPattern init_value = STS__STREAMING_VIDEO_DETECT_PATTERN__INIT;
+  *message = init_value;
+}
+size_t sts__streaming_video_detect_pattern__get_packed_size
+                     (const Sts__StreamingVideoDetectPattern *message)
+{
+  assert(message->base.descriptor == &sts__streaming_video_detect_pattern__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__streaming_video_detect_pattern__pack
+                     (const Sts__StreamingVideoDetectPattern *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__streaming_video_detect_pattern__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__streaming_video_detect_pattern__pack_to_buffer
+                     (const Sts__StreamingVideoDetectPattern *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__streaming_video_detect_pattern__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__StreamingVideoDetectPattern *
+       sts__streaming_video_detect_pattern__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__StreamingVideoDetectPattern *)
+     protobuf_c_message_unpack (&sts__streaming_video_detect_pattern__descriptor,
+                                allocator, len, data);
+}
+void   sts__streaming_video_detect_pattern__free_unpacked
+                     (Sts__StreamingVideoDetectPattern *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__streaming_video_detect_pattern__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__streaming_video_session_start__init
+                     (Sts__StreamingVideoSessionStart         *message)
+{
+  static Sts__StreamingVideoSessionStart init_value = STS__STREAMING_VIDEO_SESSION_START__INIT;
+  *message = init_value;
+}
+size_t sts__streaming_video_session_start__get_packed_size
+                     (const Sts__StreamingVideoSessionStart *message)
+{
+  assert(message->base.descriptor == &sts__streaming_video_session_start__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__streaming_video_session_start__pack
+                     (const Sts__StreamingVideoSessionStart *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__streaming_video_session_start__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__streaming_video_session_start__pack_to_buffer
+                     (const Sts__StreamingVideoSessionStart *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__streaming_video_session_start__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__StreamingVideoSessionStart *
+       sts__streaming_video_session_start__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__StreamingVideoSessionStart *)
+     protobuf_c_message_unpack (&sts__streaming_video_session_start__descriptor,
+                                allocator, len, data);
+}
+void   sts__streaming_video_session_start__free_unpacked
+                     (Sts__StreamingVideoSessionStart *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__streaming_video_session_start__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__streaming_video_server_detected__init
+                     (Sts__StreamingVideoServerDetected         *message)
+{
+  static Sts__StreamingVideoServerDetected init_value = STS__STREAMING_VIDEO_SERVER_DETECTED__INIT;
+  *message = init_value;
+}
+size_t sts__streaming_video_server_detected__get_packed_size
+                     (const Sts__StreamingVideoServerDetected *message)
+{
+  assert(message->base.descriptor == &sts__streaming_video_server_detected__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__streaming_video_server_detected__pack
+                     (const Sts__StreamingVideoServerDetected *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__streaming_video_server_detected__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__streaming_video_server_detected__pack_to_buffer
+                     (const Sts__StreamingVideoServerDetected *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__streaming_video_server_detected__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__StreamingVideoServerDetected *
+       sts__streaming_video_server_detected__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__StreamingVideoServerDetected *)
+     protobuf_c_message_unpack (&sts__streaming_video_server_detected__descriptor,
+                                allocator, len, data);
+}
+void   sts__streaming_video_server_detected__free_unpacked
+                     (Sts__StreamingVideoServerDetected *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__streaming_video_server_detected__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__streaming_video_stop__init
+                     (Sts__StreamingVideoStop         *message)
+{
+  static Sts__StreamingVideoStop init_value = STS__STREAMING_VIDEO_STOP__INIT;
+  *message = init_value;
+}
+size_t sts__streaming_video_stop__get_packed_size
+                     (const Sts__StreamingVideoStop *message)
+{
+  assert(message->base.descriptor == &sts__streaming_video_stop__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__streaming_video_stop__pack
+                     (const Sts__StreamingVideoStop *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__streaming_video_stop__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__streaming_video_stop__pack_to_buffer
+                     (const Sts__StreamingVideoStop *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__streaming_video_stop__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__StreamingVideoStop *
+       sts__streaming_video_stop__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__StreamingVideoStop *)
+     protobuf_c_message_unpack (&sts__streaming_video_stop__descriptor,
+                                allocator, len, data);
+}
+void   sts__streaming_video_stop__free_unpacked
+                     (Sts__StreamingVideoStop *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__streaming_video_stop__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   sts__video_voice_report__init
+                     (Sts__VideoVoiceReport         *message)
+{
+  static Sts__VideoVoiceReport init_value = STS__VIDEO_VOICE_REPORT__INIT;
+  *message = init_value;
+}
+size_t sts__video_voice_report__get_packed_size
+                     (const Sts__VideoVoiceReport *message)
+{
+  assert(message->base.descriptor == &sts__video_voice_report__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t sts__video_voice_report__pack
+                     (const Sts__VideoVoiceReport *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &sts__video_voice_report__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t sts__video_voice_report__pack_to_buffer
+                     (const Sts__VideoVoiceReport *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &sts__video_voice_report__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Sts__VideoVoiceReport *
+       sts__video_voice_report__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Sts__VideoVoiceReport *)
+     protobuf_c_message_unpack (&sts__video_voice_report__descriptor,
+                                allocator, len, data);
+}
+void   sts__video_voice_report__free_unpacked
+                     (Sts__VideoVoiceReport *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &sts__video_voice_report__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
 void   sts__report__init
                      (Sts__Report         *message)
 {
-  static const Sts__Report init_value = STS__REPORT__INIT;
+  static Sts__Report init_value = STS__REPORT__INIT;
   *message = init_value;
 }
 size_t sts__report__get_packed_size
@@ -854,8 +1211,6 @@ void   sts__report__free_unpacked
                      (Sts__Report *message,
                       ProtobufCAllocator *allocator)
 {
-  if(!message)
-    return;
   assert(message->base.descriptor == &sts__report__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
@@ -4817,26 +5172,1119 @@ const ProtobufCMessageDescriptor sts__ne
   (ProtobufCMessageInit) sts__network_probe__init,
   NULL,NULL,NULL    /* reserved[123] */
 };
-static const ProtobufCFieldDescriptor sts__report__field_descriptors[9] =
+static const ProtobufCEnumValue sts__rtp_flow_stats__rtp_flow_direction__enum_values_by_number[2] =
+{
+  { "RTP_UPSTREAM", "STS__RTP_FLOW_STATS__RTP_FLOW_DIRECTION__RTP_UPSTREAM", 0 },
+  { "RTP_DOWNSTREAM", "STS__RTP_FLOW_STATS__RTP_FLOW_DIRECTION__RTP_DOWNSTREAM", 1 },
+};
+static const ProtobufCIntRange sts__rtp_flow_stats__rtp_flow_direction__value_ranges[] = {
+{0, 0},{0, 2}
+};
+static const ProtobufCEnumValueIndex sts__rtp_flow_stats__rtp_flow_direction__enum_values_by_name[2] =
+{
+  { "RTP_DOWNSTREAM", 1 },
+  { "RTP_UPSTREAM", 0 },
+};
+const ProtobufCEnumDescriptor sts__rtp_flow_stats__rtp_flow_direction__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "sts.RtpFlowStats.RtpFlowDirection",
+  "RtpFlowDirection",
+  "Sts__RtpFlowStats__RtpFlowDirection",
+  "sts",
+  2,
+  sts__rtp_flow_stats__rtp_flow_direction__enum_values_by_number,
+  2,
+  sts__rtp_flow_stats__rtp_flow_direction__enum_values_by_name,
+  1,
+  sts__rtp_flow_stats__rtp_flow_direction__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCEnumValue sts__rtp_flow_stats__rtp_flow_type__enum_values_by_number[2] =
+{
+  { "RTP_VOICE", "STS__RTP_FLOW_STATS__RTP_FLOW_TYPE__RTP_VOICE", 0 },
+  { "RTP_VIDEO", "STS__RTP_FLOW_STATS__RTP_FLOW_TYPE__RTP_VIDEO", 1 },
+};
+static const ProtobufCIntRange sts__rtp_flow_stats__rtp_flow_type__value_ranges[] = {
+{0, 0},{0, 2}
+};
+static const ProtobufCEnumValueIndex sts__rtp_flow_stats__rtp_flow_type__enum_values_by_name[2] =
+{
+  { "RTP_VIDEO", 1 },
+  { "RTP_VOICE", 0 },
+};
+const ProtobufCEnumDescriptor sts__rtp_flow_stats__rtp_flow_type__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "sts.RtpFlowStats.RtpFlowType",
+  "RtpFlowType",
+  "Sts__RtpFlowStats__RtpFlowType",
+  "sts",
+  2,
+  sts__rtp_flow_stats__rtp_flow_type__enum_values_by_number,
+  2,
+  sts__rtp_flow_stats__rtp_flow_type__enum_values_by_name,
+  1,
+  sts__rtp_flow_stats__rtp_flow_type__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCFieldDescriptor sts__rtp_flow_stats__field_descriptors[14] =
 {
   {
-    "nodeID",
+    "direction",
     1,
-    PROTOBUF_C_LABEL_REQUIRED,
-    PROTOBUF_C_TYPE_STRING,
-    0,   /* quantifier_offset */
-    offsetof(Sts__Report, nodeid),
-    NULL,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__RtpFlowStats, has_direction),
+    offsetof(Sts__RtpFlowStats, direction),
+    &sts__rtp_flow_stats__rtp_flow_direction__descriptor,
     NULL,
     0,             /* flags */
     0,NULL,NULL    /* reserved1,reserved2, etc */
   },
   {
-    "survey",
+    "rtp_flow_type",
     2,
-    PROTOBUF_C_LABEL_REPEATED,
-    PROTOBUF_C_TYPE_MESSAGE,
-    offsetof(Sts__Report, n_survey),
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__RtpFlowStats, has_rtp_flow_type),
+    offsetof(Sts__RtpFlowStats, rtp_flow_type),
+    &sts__rtp_flow_stats__rtp_flow_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "latency",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_latency),
+    offsetof(Sts__RtpFlowStats, latency),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "jitter",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_jitter),
+    offsetof(Sts__RtpFlowStats, jitter),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "packet_loss_percent",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_packet_loss_percent),
+    offsetof(Sts__RtpFlowStats, packet_loss_percent),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "packet_loss_consec",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_packet_loss_consec),
+    offsetof(Sts__RtpFlowStats, packet_loss_consec),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "codec",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_codec),
+    offsetof(Sts__RtpFlowStats, codec),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "mosx_100",
+    8,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_mosx_100),
+    offsetof(Sts__RtpFlowStats, mosx_100),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "block_codecs",
+    9,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__RtpFlowStats, has_block_codecs),
+    offsetof(Sts__RtpFlowStats, block_codecs),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "total_packets_sent",
+    10,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_total_packets_sent),
+    offsetof(Sts__RtpFlowStats, total_packets_sent),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "total_packets_lost",
+    11,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_total_packets_lost),
+    offsetof(Sts__RtpFlowStats, total_packets_lost),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "rtp_seq_first",
+    12,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_rtp_seq_first),
+    offsetof(Sts__RtpFlowStats, rtp_seq_first),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "rtp_seq_last",
+    13,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_rtp_seq_last),
+    offsetof(Sts__RtpFlowStats, rtp_seq_last),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stats_idx",
+    14,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__RtpFlowStats, has_stats_idx),
+    offsetof(Sts__RtpFlowStats, stats_idx),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__rtp_flow_stats__field_indices_by_name[] = {
+  8,   /* field[8] = block_codecs */
+  6,   /* field[6] = codec */
+  0,   /* field[0] = direction */
+  3,   /* field[3] = jitter */
+  2,   /* field[2] = latency */
+  7,   /* field[7] = mosx_100 */
+  5,   /* field[5] = packet_loss_consec */
+  4,   /* field[4] = packet_loss_percent */
+  1,   /* field[1] = rtp_flow_type */
+  11,   /* field[11] = rtp_seq_first */
+  12,   /* field[12] = rtp_seq_last */
+  13,   /* field[13] = stats_idx */
+  10,   /* field[10] = total_packets_lost */
+  9,   /* field[9] = total_packets_sent */
+};
+static const ProtobufCIntRange sts__rtp_flow_stats__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 14 }
+};
+const ProtobufCMessageDescriptor sts__rtp_flow_stats__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.RtpFlowStats",
+  "RtpFlowStats",
+  "Sts__RtpFlowStats",
+  "sts",
+  sizeof(Sts__RtpFlowStats),
+  14,
+  sts__rtp_flow_stats__field_descriptors,
+  sts__rtp_flow_stats__field_indices_by_name,
+  1,  sts__rtp_flow_stats__number_ranges,
+  (ProtobufCMessageInit) sts__rtp_flow_stats__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__call_start__field_descriptors[6] =
+{
+  {
+    "session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallStart, has_session_id),
+    offsetof(Sts__CallStart, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "wifi_session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallStart, has_wifi_session_id),
+    offsetof(Sts__CallStart, wifi_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__CallStart, has_client_mac),
+    offsetof(Sts__CallStart, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "codecs",
+    4,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_STRING,
+    offsetof(Sts__CallStart, n_codecs),
+    offsetof(Sts__CallStart, codecs),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "provider_domain",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(Sts__CallStart, provider_domain),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "device_info",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(Sts__CallStart, device_info),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__call_start__field_indices_by_name[] = {
+  2,   /* field[2] = client_mac */
+  3,   /* field[3] = codecs */
+  5,   /* field[5] = device_info */
+  4,   /* field[4] = provider_domain */
+  0,   /* field[0] = session_id */
+  1,   /* field[1] = wifi_session_id */
+};
+static const ProtobufCIntRange sts__call_start__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 6 }
+};
+const ProtobufCMessageDescriptor sts__call_start__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.CallStart",
+  "CallStart",
+  "Sts__CallStart",
+  "sts",
+  sizeof(Sts__CallStart),
+  6,
+  sts__call_start__field_descriptors,
+  sts__call_start__field_indices_by_name,
+  1,  sts__call_start__number_ranges,
+  (ProtobufCMessageInit) sts__call_start__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCEnumValue sts__call_stop__call_stop_reason__enum_values_by_number[2] =
+{
+  { "BYE_OK", "STS__CALL_STOP__CALL_STOP_REASON__BYE_OK", 0 },
+  { "CALL_DROPPED", "STS__CALL_STOP__CALL_STOP_REASON__CALL_DROPPED", 1 },
+};
+static const ProtobufCIntRange sts__call_stop__call_stop_reason__value_ranges[] = {
+{0, 0},{0, 2}
+};
+static const ProtobufCEnumValueIndex sts__call_stop__call_stop_reason__enum_values_by_name[2] =
+{
+  { "BYE_OK", 0 },
+  { "CALL_DROPPED", 1 },
+};
+const ProtobufCEnumDescriptor sts__call_stop__call_stop_reason__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "sts.CallStop.CallStopReason",
+  "CallStopReason",
+  "Sts__CallStop__CallStopReason",
+  "sts",
+  2,
+  sts__call_stop__call_stop_reason__enum_values_by_number,
+  2,
+  sts__call_stop__call_stop_reason__enum_values_by_name,
+  1,
+  sts__call_stop__call_stop_reason__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCFieldDescriptor sts__call_stop__field_descriptors[6] =
+{
+  {
+    "session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallStop, has_session_id),
+    offsetof(Sts__CallStop, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "wifi_session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallStop, has_wifi_session_id),
+    offsetof(Sts__CallStop, wifi_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__CallStop, has_client_mac),
+    offsetof(Sts__CallStop, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "reason",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__CallStop, has_reason),
+    offsetof(Sts__CallStop, reason),
+    &sts__call_stop__call_stop_reason__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "call_duration",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__CallStop, has_call_duration),
+    offsetof(Sts__CallStop, call_duration),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stats",
+    6,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Sts__CallStop, n_stats),
+    offsetof(Sts__CallStop, stats),
+    &sts__rtp_flow_stats__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__call_stop__field_indices_by_name[] = {
+  4,   /* field[4] = call_duration */
+  2,   /* field[2] = client_mac */
+  3,   /* field[3] = reason */
+  0,   /* field[0] = session_id */
+  5,   /* field[5] = stats */
+  1,   /* field[1] = wifi_session_id */
+};
+static const ProtobufCIntRange sts__call_stop__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 6 }
+};
+const ProtobufCMessageDescriptor sts__call_stop__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.CallStop",
+  "CallStop",
+  "Sts__CallStop",
+  "sts",
+  sizeof(Sts__CallStop),
+  6,
+  sts__call_stop__field_descriptors,
+  sts__call_stop__field_indices_by_name,
+  1,  sts__call_stop__number_ranges,
+  (ProtobufCMessageInit) sts__call_stop__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCEnumValue sts__call_report__call_report_reason__enum_values_by_number[3] =
+{
+  { "ROAMED_FROM", "STS__CALL_REPORT__CALL_REPORT_REASON__ROAMED_FROM", 0 },
+  { "ROAMED_TO", "STS__CALL_REPORT__CALL_REPORT_REASON__ROAMED_TO", 1 },
+  { "GOT_PUBLISH", "STS__CALL_REPORT__CALL_REPORT_REASON__GOT_PUBLISH", 2 },
+};
+static const ProtobufCIntRange sts__call_report__call_report_reason__value_ranges[] = {
+{0, 0},{0, 3}
+};
+static const ProtobufCEnumValueIndex sts__call_report__call_report_reason__enum_values_by_name[3] =
+{
+  { "GOT_PUBLISH", 2 },
+  { "ROAMED_FROM", 0 },
+  { "ROAMED_TO", 1 },
+};
+const ProtobufCEnumDescriptor sts__call_report__call_report_reason__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "sts.CallReport.CallReportReason",
+  "CallReportReason",
+  "Sts__CallReport__CallReportReason",
+  "sts",
+  3,
+  sts__call_report__call_report_reason__enum_values_by_number,
+  3,
+  sts__call_report__call_report_reason__enum_values_by_name,
+  1,
+  sts__call_report__call_report_reason__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
+static const ProtobufCFieldDescriptor sts__call_report__field_descriptors[5] =
+{
+  {
+    "session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallReport, has_session_id),
+    offsetof(Sts__CallReport, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "wifi_session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__CallReport, has_wifi_session_id),
+    offsetof(Sts__CallReport, wifi_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__CallReport, has_client_mac),
+    offsetof(Sts__CallReport, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stats",
+    4,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Sts__CallReport, n_stats),
+    offsetof(Sts__CallReport, stats),
+    &sts__rtp_flow_stats__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "reason",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__CallReport, has_reason),
+    offsetof(Sts__CallReport, reason),
+    &sts__call_report__call_report_reason__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__call_report__field_indices_by_name[] = {
+  2,   /* field[2] = client_mac */
+  4,   /* field[4] = reason */
+  0,   /* field[0] = session_id */
+  3,   /* field[3] = stats */
+  1,   /* field[1] = wifi_session_id */
+};
+static const ProtobufCIntRange sts__call_report__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 5 }
+};
+const ProtobufCMessageDescriptor sts__call_report__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.CallReport",
+  "CallReport",
+  "Sts__CallReport",
+  "sts",
+  sizeof(Sts__CallReport),
+  5,
+  sts__call_report__field_descriptors,
+  sts__call_report__field_indices_by_name,
+  1,  sts__call_report__number_ranges,
+  (ProtobufCMessageInit) sts__call_report__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__streaming_video_detect_pattern__field_descriptors[2] =
+{
+  {
+    "dns_lookup_pattern",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(Sts__StreamingVideoDetectPattern, dns_lookup_pattern),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "video_type",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__StreamingVideoDetectPattern, has_video_type),
+    offsetof(Sts__StreamingVideoDetectPattern, video_type),
+    &sts__streaming_video_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__streaming_video_detect_pattern__field_indices_by_name[] = {
+  0,   /* field[0] = dns_lookup_pattern */
+  1,   /* field[1] = video_type */
+};
+static const ProtobufCIntRange sts__streaming_video_detect_pattern__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 2 }
+};
+const ProtobufCMessageDescriptor sts__streaming_video_detect_pattern__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.StreamingVideoDetectPattern",
+  "StreamingVideoDetectPattern",
+  "Sts__StreamingVideoDetectPattern",
+  "sts",
+  sizeof(Sts__StreamingVideoDetectPattern),
+  2,
+  sts__streaming_video_detect_pattern__field_descriptors,
+  sts__streaming_video_detect_pattern__field_indices_by_name,
+  1,  sts__streaming_video_detect_pattern__number_ranges,
+  (ProtobufCMessageInit) sts__streaming_video_detect_pattern__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__streaming_video_session_start__field_descriptors[5] =
+{
+  {
+    "video_session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoSessionStart, has_video_session_id),
+    offsetof(Sts__StreamingVideoSessionStart, video_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoSessionStart, has_session_id),
+    offsetof(Sts__StreamingVideoSessionStart, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoSessionStart, has_client_mac),
+    offsetof(Sts__StreamingVideoSessionStart, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "server_ip",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoSessionStart, has_server_ip),
+    offsetof(Sts__StreamingVideoSessionStart, server_ip),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "streaming_video_type",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__StreamingVideoSessionStart, has_streaming_video_type),
+    offsetof(Sts__StreamingVideoSessionStart, streaming_video_type),
+    &sts__streaming_video_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__streaming_video_session_start__field_indices_by_name[] = {
+  2,   /* field[2] = client_mac */
+  3,   /* field[3] = server_ip */
+  1,   /* field[1] = session_id */
+  4,   /* field[4] = streaming_video_type */
+  0,   /* field[0] = video_session_id */
+};
+static const ProtobufCIntRange sts__streaming_video_session_start__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 5 }
+};
+const ProtobufCMessageDescriptor sts__streaming_video_session_start__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.StreamingVideoSessionStart",
+  "StreamingVideoSessionStart",
+  "Sts__StreamingVideoSessionStart",
+  "sts",
+  sizeof(Sts__StreamingVideoSessionStart),
+  5,
+  sts__streaming_video_session_start__field_descriptors,
+  sts__streaming_video_session_start__field_indices_by_name,
+  1,  sts__streaming_video_session_start__number_ranges,
+  (ProtobufCMessageInit) sts__streaming_video_session_start__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__streaming_video_server_detected__field_descriptors[6] =
+{
+  {
+    "video_session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoServerDetected, has_video_session_id),
+    offsetof(Sts__StreamingVideoServerDetected, video_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoServerDetected, has_session_id),
+    offsetof(Sts__StreamingVideoServerDetected, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoServerDetected, has_client_mac),
+    offsetof(Sts__StreamingVideoServerDetected, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "server_ip",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoServerDetected, has_server_ip),
+    offsetof(Sts__StreamingVideoServerDetected, server_ip),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "server_dns_name",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(Sts__StreamingVideoServerDetected, server_dns_name),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "streaming_video_type",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__StreamingVideoServerDetected, has_streaming_video_type),
+    offsetof(Sts__StreamingVideoServerDetected, streaming_video_type),
+    &sts__streaming_video_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__streaming_video_server_detected__field_indices_by_name[] = {
+  2,   /* field[2] = client_mac */
+  4,   /* field[4] = server_dns_name */
+  3,   /* field[3] = server_ip */
+  1,   /* field[1] = session_id */
+  5,   /* field[5] = streaming_video_type */
+  0,   /* field[0] = video_session_id */
+};
+static const ProtobufCIntRange sts__streaming_video_server_detected__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 6 }
+};
+const ProtobufCMessageDescriptor sts__streaming_video_server_detected__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.StreamingVideoServerDetected",
+  "StreamingVideoServerDetected",
+  "Sts__StreamingVideoServerDetected",
+  "sts",
+  sizeof(Sts__StreamingVideoServerDetected),
+  6,
+  sts__streaming_video_server_detected__field_descriptors,
+  sts__streaming_video_server_detected__field_indices_by_name,
+  1,  sts__streaming_video_server_detected__number_ranges,
+  (ProtobufCMessageInit) sts__streaming_video_server_detected__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__streaming_video_stop__field_descriptors[7] =
+{
+  {
+    "video_session_id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoStop, has_video_session_id),
+    offsetof(Sts__StreamingVideoStop, video_session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "session_id",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoStop, has_session_id),
+    offsetof(Sts__StreamingVideoStop, session_id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "client_mac",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoStop, has_client_mac),
+    offsetof(Sts__StreamingVideoStop, client_mac),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "server_ip",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Sts__StreamingVideoStop, has_server_ip),
+    offsetof(Sts__StreamingVideoStop, server_ip),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "total_bytes",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__StreamingVideoStop, has_total_bytes),
+    offsetof(Sts__StreamingVideoStop, total_bytes),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "streaming_video_type",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_ENUM,
+    offsetof(Sts__StreamingVideoStop, has_streaming_video_type),
+    offsetof(Sts__StreamingVideoStop, streaming_video_type),
+    &sts__streaming_video_type__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "duration_sec",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Sts__StreamingVideoStop, has_duration_sec),
+    offsetof(Sts__StreamingVideoStop, duration_sec),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__streaming_video_stop__field_indices_by_name[] = {
+  2,   /* field[2] = client_mac */
+  6,   /* field[6] = duration_sec */
+  3,   /* field[3] = server_ip */
+  1,   /* field[1] = session_id */
+  5,   /* field[5] = streaming_video_type */
+  4,   /* field[4] = total_bytes */
+  0,   /* field[0] = video_session_id */
+};
+static const ProtobufCIntRange sts__streaming_video_stop__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 7 }
+};
+const ProtobufCMessageDescriptor sts__streaming_video_stop__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.StreamingVideoStop",
+  "StreamingVideoStop",
+  "Sts__StreamingVideoStop",
+  "sts",
+  sizeof(Sts__StreamingVideoStop),
+  7,
+  sts__streaming_video_stop__field_descriptors,
+  sts__streaming_video_stop__field_indices_by_name,
+  1,  sts__streaming_video_stop__number_ranges,
+  (ProtobufCMessageInit) sts__streaming_video_stop__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__video_voice_report__field_descriptors[7] =
+{
+  {
+    "call_start",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, call_start),
+    &sts__call_start__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "call_stop",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, call_stop),
+    &sts__call_stop__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "call_report",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, call_report),
+    &sts__call_report__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stream_video_stop",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, stream_video_stop),
+    &sts__streaming_video_stop__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stream_video_server",
+    5,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, stream_video_server),
+    &sts__streaming_video_server_detected__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "stream_video_session_start",
+    6,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Sts__VideoVoiceReport, stream_video_session_start),
+    &sts__streaming_video_session_start__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "timestamp_ms",
+    7,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT64,
+    offsetof(Sts__VideoVoiceReport, has_timestamp_ms),
+    offsetof(Sts__VideoVoiceReport, timestamp_ms),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned sts__video_voice_report__field_indices_by_name[] = {
+  2,   /* field[2] = call_report */
+  0,   /* field[0] = call_start */
+  1,   /* field[1] = call_stop */
+  4,   /* field[4] = stream_video_server */
+  5,   /* field[5] = stream_video_session_start */
+  3,   /* field[3] = stream_video_stop */
+  6,   /* field[6] = timestamp_ms */
+};
+static const ProtobufCIntRange sts__video_voice_report__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 7 }
+};
+const ProtobufCMessageDescriptor sts__video_voice_report__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "sts.VideoVoiceReport",
+  "VideoVoiceReport",
+  "Sts__VideoVoiceReport",
+  "sts",
+  sizeof(Sts__VideoVoiceReport),
+  7,
+  sts__video_voice_report__field_descriptors,
+  sts__video_voice_report__field_indices_by_name,
+  1,  sts__video_voice_report__number_ranges,
+  (ProtobufCMessageInit) sts__video_voice_report__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor sts__report__field_descriptors[10] =
+{
+  {
+    "nodeID",
+    1,
+    PROTOBUF_C_LABEL_REQUIRED,
+    PROTOBUF_C_TYPE_STRING,
+    0,   /* quantifier_offset */
+    offsetof(Sts__Report, nodeid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "survey",
+    2,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Sts__Report, n_survey),
     offsetof(Sts__Report, survey),
     &sts__survey__descriptor,
     NULL,
@@ -4916,6 +6364,18 @@ static const ProtobufCFieldDescriptor st
     0,NULL,NULL    /* reserved1,reserved2, etc */
   },
   {
+    "video_voice_report",
+    9,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Sts__Report, n_video_voice_report),
+    offsetof(Sts__Report, video_voice_report),
+    &sts__video_voice_report__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
     "network_probe",
     101,
     PROTOBUF_C_LABEL_REPEATED,
@@ -4934,16 +6394,17 @@ static const unsigned sts__report__field
   4,   /* field[4] = clients */
   5,   /* field[5] = device */
   3,   /* field[3] = neighbors */
-  8,   /* field[8] = network_probe */
+  9,   /* field[9] = network_probe */
   0,   /* field[0] = nodeID */
   7,   /* field[7] = rssi_report */
   1,   /* field[1] = survey */
+  8,   /* field[8] = video_voice_report */
 };
 static const ProtobufCIntRange sts__report__number_ranges[2 + 1] =
 {
   { 1, 0 },
-  { 101, 8 },
-  { 0, 9 }
+  { 101, 9 },
+  { 0, 10 }
 };
 const ProtobufCMessageDescriptor sts__report__descriptor =
 {
@@ -4953,7 +6414,7 @@ const ProtobufCMessageDescriptor sts__re
   "Sts__Report",
   "sts",
   sizeof(Sts__Report),
-  9,
+  10,
   sts__report__field_descriptors,
   sts__report__field_indices_by_name,
   2,  sts__report__number_ranges,
@@ -5416,6 +6877,38 @@ const ProtobufCEnumDescriptor sts__diff_
   sts__diff_type__value_ranges,
   NULL,NULL,NULL,NULL   /* reserved[1234] */
 };
+static const ProtobufCEnumValue sts__streaming_video_type__enum_values_by_number[4] =
+{
+  { "UNKNOWN", "STS__STREAMING_VIDEO_TYPE__UNKNOWN", 0 },
+  { "NETFLIX", "STS__STREAMING_VIDEO_TYPE__NETFLIX", 1 },
+  { "YOUTUBE", "STS__STREAMING_VIDEO_TYPE__YOUTUBE", 2 },
+  { "PLEX", "STS__STREAMING_VIDEO_TYPE__PLEX", 3 },
+};
+static const ProtobufCIntRange sts__streaming_video_type__value_ranges[] = {
+{0, 0},{0, 4}
+};
+static const ProtobufCEnumValueIndex sts__streaming_video_type__enum_values_by_name[4] =
+{
+  { "NETFLIX", 1 },
+  { "PLEX", 3 },
+  { "UNKNOWN", 0 },
+  { "YOUTUBE", 2 },
+};
+const ProtobufCEnumDescriptor sts__streaming_video_type__descriptor =
+{
+  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
+  "sts.StreamingVideoType",
+  "StreamingVideoType",
+  "Sts__StreamingVideoType",
+  "sts",
+  4,
+  sts__streaming_video_type__enum_values_by_number,
+  4,
+  sts__streaming_video_type__enum_values_by_name,
+  1,
+  sts__streaming_video_type__value_ranges,
+  NULL,NULL,NULL,NULL   /* reserved[1234] */
+};
 static const ProtobufCEnumValue sts__state_up_down__enum_values_by_number[3] =
 {
   { "SUD_down", "STS__STATE_UP_DOWN__SUD_down", 0 },
--- a/src/lib/datapipeline/inc/dpp_types.h
+++ b/src/lib/datapipeline/inc/dpp_types.h
@@ -464,4 +464,30 @@ typedef enum
     RSSI_SOURCE_NEIGHBOR
 } rssi_source_t;
 
+typedef enum
+{
+    BYE_OK = 0,
+    CALL_DROPPED = 1
+} sipcall_stopreason_t;
+
+typedef enum
+{
+    RTP_UPSTREAM = 0,
+    RTP_DOWNSTREAM = 1
+} rtp_flow_direction_t;
+
+typedef enum
+{
+    RTP_VOICE = 0,
+    RTP_VIDEO = 1
+} rtp_flow_type_t;
+
+typedef enum
+{
+    ROAMED_FROM = 0,
+    ROAMED_TO = 1,
+    GOT_PUBLISH = 2
+} sip_call_report_reason_t;
+
+
 #endif /* DPP_TYPES_H_INCLUDED */
--- /dev/null
+++ b/src/lib/datapipeline/inc/dpp_ucc.h
@@ -0,0 +1,83 @@
+/* SPDX-License-Identifier BSD-3-Clause */
+
+#ifndef DPP_UCC_H_INCLUDED
+#define DPP_UCC_H_INCLUDED
+
+#include "ds.h"
+#include "ds_dlist.h"
+
+#include "dpp_types.h"
+
+#define PKT_TYPE_CALL_START         103
+#define PKT_TYPE_CALL_STOP          104
+#define PKT_TYPE_CALL_REPORT        105
+
+typedef struct
+{
+    rtp_flow_direction_t direction;
+    rtp_flow_type_t type;
+    uint32_t latency;
+    uint32_t jitter;
+    uint32_t packet_loss_percent;    // percentage of lost packets
+    uint32_t packet_loss_consec;    // consecutive packet lost
+    uint32_t codec;    // reference to Codec type in Start. 7 bits PT value (RFC3550)
+    uint32_t MOSx100;    // in case MOS is provided by the application
+    char BlockCodecs[10];    // Each byte contains F and block PT, only use when Codec is redundant (RFC2198)
+    uint32_t total_packets_sent;   // ver=401
+    uint32_t total_packets_lost;   // ver=401
+    uint32_t rtp_seq_first;   // ver=401
+    uint32_t rtp_seq_last;   // ver=401
+    uint32_t stats_idx;   // ver=401, indexing stats for the same sessionId and wifiSessionId
+} rtp_flow_stats_t;
+
+
+
+typedef struct
+{
+    uint64_t session_id;
+    uint64_t wifi_session_id;
+    char clt_mac[6];
+    char codecs[15][30];
+    char provider_domain[50];
+    char device_info[10];
+} dpp_ucc_sipcall_start_t;
+
+
+typedef struct
+{
+    uint64_t session_id;
+    uint64_t wifi_session_id;
+    char clt_mac[6];
+    sipcall_stopreason_t reason;
+    uint32_t call_duration;  // call duration in seconds
+    rtp_flow_stats_t stats;
+} dpp_ucc_sipcall_stop_t;
+
+
+typedef struct
+{
+    uint64_t session_id;
+    uint64_t wifi_session_id;
+    char clt_mac[6];
+    rtp_flow_stats_t stats;
+    sip_call_report_reason_t reason;
+} dpp_ucc_sipcall_report_t;
+
+typedef struct
+{
+    dpp_ucc_sipcall_start_t            sip_call_start;
+    dpp_ucc_sipcall_stop_t            sip_call_stop;
+    dpp_ucc_sipcall_report_t          sip_call_report;
+
+} dpp_ucc_record_t;
+
+
+typedef struct
+{
+    dpp_ucc_record_t             record;
+    uint64_t                        timestamp_ms;
+    ds_dlist_t                      list;
+    uint32_t                     type;
+} dpp_ucc_report_data_t;
+
+#endif /* DPP_UCC_H_INCLUDED */
--- a/src/lib/datapipeline/inc/dppline.h
+++ b/src/lib/datapipeline/inc/dppline.h
@@ -46,6 +46,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_bs_client.h"
 #include "dpp_rssi.h"
 #include "dpp_network_probe.h"
+#include "dpp_ucc.h"
 
 #ifdef CONFIG_MANAGER_QM
 // QM does queue-ing of reports when offline on it's own, so dpp needs
@@ -107,6 +108,13 @@ bool dpp_put_bs_client(dpp_bs_client_rep
 bool dpp_put_rssi(dpp_rssi_report_data_t *rpt);
 
 /*
+ * Insert UCC stats into dpp internal queue
+ */
+bool dpp_put_ucc(dpp_ucc_report_data_t * rpt);
+
+
+
+/*
  * Get the protobuf packed buffer
  *
  * This buffer is ready to be send using MQTT
--- a/src/lib/datapipeline/src/dppline.c
+++ b/src/lib/datapipeline/src/dppline.c
@@ -43,6 +43,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_device.h"
 #include "dpp_capacity.h"
 #include "dpp_bs_client.h"
+#include "dpp_ucc.h"
 
 #ifndef TARGET_NATIVE
 #include "os_types.h"
@@ -64,6 +65,7 @@ typedef enum
     DPP_T_BS_CLIENT = 6,
     DPP_T_RSSI      = 7,
     DPP_T_NETWORK_PROBE =8,
+    DPP_T_UCC       = 9,
 } DPP_STS_TYPE;
 
 uint32_t queue_depth;
@@ -162,6 +164,16 @@ typedef struct dpp_rssi_stats
     uint64_t                        timestamp_ms;
 } dppline_rssi_stats_t;
 
+typedef struct dpp_ucc_stats
+{
+    dpp_ucc_record_t             record;
+    uint32_t                        qty;
+    uint64_t                        timestamp_ms;
+    uint32_t                     type;
+} dppline_ucc_stats_t;
+
+
+
 /* DPP stats type, used as element in internal double ds */
 typedef struct dpp_stats
 {
@@ -178,6 +190,7 @@ typedef struct dpp_stats
         dppline_bs_client_stats_t   bs_client;
         dppline_rssi_stats_t        rssi;
         dppline_network_probe_stats_t        network_probe;
+        dppline_ucc_stats_t      ucc;
     } u;
 } dppline_stats_t;
 
@@ -234,6 +247,9 @@ static void dppline_free_stat(dppline_st
             case DPP_T_NETWORK_PROBE:
                 free(s->u.network_probe.list);
                 break;
+            case DPP_T_UCC:
+                free(&s->u.ucc.record);
+                break;
             default:;
         }
 
@@ -682,6 +698,19 @@ static bool dppline_copysts(dppline_stat
 
            }
            break;
+        case DPP_T_UCC:
+            {
+                dpp_ucc_report_data_t        *report_data = sts;
+
+                memcpy(&dst->u.ucc.record, &report_data->record,
+                       sizeof(dpp_ucc_record_t));
+
+                dst->u.ucc.timestamp_ms = report_data->timestamp_ms;
+                dst->u.ucc.type = report_data->type;
+		size = sizeof(dpp_ucc_record_t);
+            }
+            break;
+
         default:
             LOG(ERR, "Failed to copy %d stats", dst->type);
             /* do nothing */
@@ -1931,6 +1960,154 @@ static void dppline_add_stat_bs_client(S
     }
 }
 
+static void dppline_add_stat_ucc(Sts__Report *r, dppline_stats_t *s)
+{
+    Sts__VideoVoiceReport *sr = NULL;
+    int size = 0;
+    uint32_t i;
+    dppline_ucc_stats_t *ucc = &s->u.ucc;
+
+
+    // increase the number of vivo report
+    r->n_video_voice_report++;
+
+    // allocate or extend the size of vivo
+    r->video_voice_report = realloc(r->video_voice_report,
+            r->n_video_voice_report * sizeof(Sts__VideoVoiceReport*));
+    size += sizeof(Sts__VideoVoiceReport*);
+
+    // allocate new buffer Sts__VideoVoiceReport
+    sr = malloc(sizeof(Sts__VideoVoiceReport));
+    size += sizeof(Sts__VideoVoiceReport);
+    assert(sr);
+    r->video_voice_report[r->n_video_voice_report - 1] = sr;
+    sts__video_voice_report__init(sr);
+
+    sr->timestamp_ms = ucc->timestamp_ms;
+    sr->has_timestamp_ms = true;
+
+    switch (ucc->type)
+    {
+    case PKT_TYPE_CALL_START:
+        /* Call Start report */
+        sr->call_start = malloc(sizeof(*sr->call_start));
+        size += sizeof(*sr->call_start);
+        assert(sr->call_start);
+
+        sts__call_start__init(sr->call_start);
+
+        sr->call_start->session_id = ucc->record.sip_call_start.session_id;
+        sr->call_start->has_session_id = true;
+        sr->call_start->wifi_session_id =
+                                    ucc->record.sip_call_start.wifi_session_id;
+        sr->call_start->has_wifi_session_id = true;
+        sr->call_start->client_mac.data =
+                            malloc(sizeof(ucc->record.sip_call_start.clt_mac));
+
+        size += sizeof(ucc->record.sip_call_start.clt_mac);
+        assert(sr->call_start->client_mac.data);
+        memcpy(sr->call_start->client_mac.data,
+    		&ucc->record.sip_call_start.clt_mac[0],
+    		sizeof(ucc->record.sip_call_start.clt_mac));
+
+        sr->call_start->client_mac.len =
+    		sizeof(ucc->record.sip_call_start.clt_mac);
+        sr->call_start->has_client_mac = true;
+
+        sr->call_start->codecs = malloc(15 * sizeof(*sr->call_start->codecs));
+
+        for (i = 0; i < 15; i++){
+    	sr->call_start->codecs[i] =
+                    malloc(30 * sizeof(**sr->call_start->codecs));
+    	memcpy(sr->call_start->codecs[i],
+                   &ucc->record.sip_call_start.codecs[i][0], 30);
+        }
+
+        size += (15 * sizeof(*sr->call_start->codecs)) +
+    		(30 * sizeof(**sr->call_start->codecs));
+
+        sr->call_start->n_codecs = 15;
+
+        sr->call_start->provider_domain =
+                    malloc(sizeof(ucc->record.sip_call_start.provider_domain));
+
+        size += sizeof(ucc->record.sip_call_start.provider_domain);
+        assert(sr->call_start->provider_domain);
+
+        memcpy(sr->call_start->provider_domain,
+               ucc->record.sip_call_start.provider_domain,
+               sizeof(ucc->record.sip_call_start.provider_domain));
+            break;
+
+    case PKT_TYPE_CALL_STOP:
+        /* Call Stop report */
+        sr->call_stop = malloc(sizeof(*sr->call_stop));
+        size += sizeof(*sr->call_stop);
+        assert(sr->call_stop);
+
+        sts__call_stop__init(sr->call_stop);
+
+        sr->call_stop->session_id = ucc->record.sip_call_stop.session_id;
+        sr->call_stop->has_session_id = true;
+        sr->call_stop->wifi_session_id =
+                                    ucc->record.sip_call_stop.wifi_session_id;
+        sr->call_stop->has_wifi_session_id = true;
+
+        sr->call_stop->client_mac.data =
+        malloc(sizeof(ucc->record.sip_call_stop.clt_mac));
+
+        size += sizeof(ucc->record.sip_call_stop.clt_mac);
+        assert(sr->call_stop->client_mac.data);
+        memcpy(sr->call_stop->client_mac.data,
+    		&ucc->record.sip_call_stop.clt_mac[0],
+    		sizeof(ucc->record.sip_call_stop.clt_mac));
+
+        sr->call_stop->client_mac.len =
+    		sizeof(ucc->record.sip_call_stop.clt_mac);
+        sr->call_stop->has_client_mac = true;
+
+        sr->call_stop->reason = ucc->record.sip_call_stop.reason;
+        sr->call_stop->has_reason = true;
+            break;
+
+    case PKT_TYPE_CALL_REPORT:
+        /* Call report */
+        sr->call_report = malloc(sizeof(*sr->call_report));
+        size += sizeof(*sr->call_report);
+        assert(sr->call_report);
+
+        sts__call_report__init(sr->call_report);
+
+        sr->call_report->session_id = ucc->record.sip_call_report.session_id;
+        sr->call_report->has_session_id = true;
+
+        sr->call_report->wifi_session_id =
+                                ucc->record.sip_call_report.wifi_session_id;
+        sr->call_report->has_wifi_session_id = true;
+
+        sr->call_report->client_mac.data =
+        malloc(sizeof(ucc->record.sip_call_report.clt_mac));
+
+        size += sizeof(ucc->record.sip_call_report.clt_mac);
+        assert(sr->call_report->client_mac.data);
+        memcpy(sr->call_report->client_mac.data,
+               &ucc->record.sip_call_report.clt_mac[0],
+               sizeof(ucc->record.sip_call_report.clt_mac));
+
+        sr->call_report->client_mac.len =
+    		sizeof(ucc->record.sip_call_report.clt_mac);
+        sr->call_report->has_client_mac = true;
+
+        sr->call_report->reason = ucc->record.sip_call_report.reason;
+        sr->call_report->has_reason = true;
+        break;
+
+    default:
+        break;
+    }
+}
+
+
 Sts__RssiPeer__RssiSource dppline_to_proto_rssi_source(rssi_source_t rssi_source)
 {
     switch (rssi_source)
@@ -2089,6 +2266,10 @@ static void dppline_add_stat(Sts__Report
             dppline_add_stat_network_probe(r, s);
             break;
 
+        case DPP_T_UCC:
+            dppline_add_stat_ucc(r, s);
+            break;
+
         default:
             LOG(ERR, "Failed to add %d to stats report", s->type);
             /* do nothing       */
@@ -2253,6 +2434,14 @@ bool dpp_put_network_probe(dpp_network_p
 }
 
 /*
+ * Put Video/voice stats to internal queue
+ */
+bool dpp_put_ucc(dpp_ucc_report_data_t * rpt)
+{
+    return dppline_put(DPP_T_UCC, rpt);
+}
+
+/*
  * Create the protobuf buff and copy it to given buffer
  */
 #ifndef DPP_FAST_PACK
@@ -2261,7 +2450,7 @@ bool dpp_get_report(uint8_t * buff, size
     ds_dlist_iter_t iter;
     dppline_stats_t *s;
     bool ret = false;
-    size_t tmp_packed_size; /* packed size of current report */
+    size_t tmp_packed_size = 0; /* packed size of current report */
 
     /* prevent sending empty reports */
     if (dpp_get_queue_elements() == 0)
@@ -2292,6 +2481,8 @@ bool dpp_get_report(uint8_t * buff, size
         tmp_packed_size = sts__report__get_packed_size(report);
 
         /* check the size, if size too small break the process */
+
+        /* if main buffer size is not enough break */
         if (sz < tmp_packed_size)
         {
             LOG(WARNING, "Packed size: %5zd, buffer size: %5zd ",
--- /dev/null
+++ b/src/sm/src/nl_ucc.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier BSD-3-Clause */
+#include <linux/netlink.h>
+
+#ifndef __KERNEL__
+#include <sys/socket.h>
+
+#include <net/if.h>
+
+#include <sys/types.h>
+
+#include <linux/sockios.h>
+
+#include <netlink/socket.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/family.h>
+#include <netlink/genl/ctrl.h>
+#include <netlink/msg.h>
+#include <netlink/attr.h>
+#endif
+
+
+#define WC_CAPT_BUF_SIZE        500
+#define PKT_TYPE_CALL_START         103
+#define PKT_TYPE_CALL_STOP          104
+#define PKT_TYPE_CALL_REPORT        105
+
+
+struct wc_capture_buf
+{
+    uint64_t TimeStamp;
+    uint64_t tsInUs;
+    uint64_t SessionId;
+    unsigned int Type;
+    unsigned int From;
+    unsigned int Len;
+    unsigned int Channel;
+    unsigned int Direction;
+    int Rssi;
+    unsigned int DataRate;
+    unsigned int Count;
+    int wifiIf;         // for dhcp
+    char staMac[6];     // for dhcp
+    unsigned char Buffer[WC_CAPT_BUF_SIZE];
+};
+
+struct sip_call_start
+{
+    unsigned long long SessionId;
+    unsigned char CltMac[6];
+    int WifiIf;                                 /* To get WiFi session ID */
+    char Url[50];
+    char Codecs[15][30];
+} __attribute__((packed));
+
+struct sip_call_end
+{
+    unsigned long long SessionId;
+    unsigned char CltMac[6];
+    int WifiIf;                                 /* To get WiFi session ID */
+    unsigned int CltMos;
+    unsigned int Reason;
+    unsigned char Codecs[4];
+    unsigned int Latency;
+    unsigned int Jitter;
+    unsigned int PktLostPerc;
+    unsigned int PktLostCons;
+    unsigned int VideoCodec;
+    unsigned int TotalPktSent;
+    unsigned int TotalPktLost;
+    unsigned int RtpSeqFirst;
+    unsigned int RtpSeqLast;
+    unsigned int SipReportIdx;
+} __attribute__((packed));
+
+
+struct sip_call_report
+{
+    unsigned int Latency;
+    unsigned int Jitter;
+    unsigned int PacketLoss;
+    unsigned int Mos;
+} __attribute__((packed));
+
+
+
+#define WC_CAPT_BUF_SIZE        500
+
+#define GENL_UCC_FAMILY_NAME		"genl_ucc"
+#define GENL_UCC_MCGRP0_NAME		"genl_mcgrp0"
+#define GENL_UCC_MCGRP1_NAME		"genl_mcgrp1"
+#define GENL_UCC_MCGRP2_NAME		"genl_mcgrp2"
+
+enum genl_ucc_multicast_groups {
+	GENL_UCC_MCGRP0,
+	GENL_UCC_MCGRP1,
+	GENL_UCC_MCGRP2,
+};
+
+#define GENL_UCC_MCGRP_MAX		3
+
+static char* genl_ucc_mcgrp_names[GENL_UCC_MCGRP_MAX] = {
+	GENL_UCC_MCGRP0_NAME,
+	GENL_UCC_MCGRP1_NAME,
+	GENL_UCC_MCGRP2_NAME,
+};
+
+enum genl_ucc_attrs {
+	GENL_UCC_ATTR_UNSPEC,		/* Must NOT use element 0 */
+
+	GENL_UCC_ATTR_MSG,
+
+	__GENL_UCC_ATTR__MAX,
+};
+#define GENL_UCC_ATTR_MAX (__GENL_UCC_ATTR__MAX - 1)
+
+
+#define GENL_UCC_ATTR_MSG_MAX		256
+
+enum {
+	GENL_UCC_C_UNSPEC,		/* Must NOT use element 0 */
+	GENL_UCC_C_MSG,
+};
+
+
+
+static struct nla_policy genl_ucc_policy[GENL_UCC_ATTR_MAX+1] = {
+	[GENL_UCC_ATTR_MSG] = {
+		.type = NLA_UNSPEC,
+#ifdef __KERNEL__
+		.len = sizeof(struct wc_capture_buf)
+#else
+		.maxlen = sizeof(struct wc_capture_buf)
+#endif
+	},
+};
+
--- a/src/sm/src/sm.h
+++ b/src/sm/src/sm.h
@@ -222,6 +222,13 @@ bool sm_radio_config_enable_fast_scan(
         radio_entry_t              *radio_cfg);
 
 /******************************************************************************
+ *  UCC definitions
+ *****************************************************************************/
+bool ucc_report_request(sm_stats_request_t *request);
+
+/******************************************************************************/
+
+/******************************************************************************
  *  SCAN SCHED definitions
  *****************************************************************************/
 typedef void (*sm_scan_cb_t)(
@@ -271,6 +278,7 @@ typedef enum
     STS_REPORT_DEVICE,
     STS_REPORT_RSSI,
     STS_REPORT_NETWORK_PROBE,
+    STS_REPORT_VIDEO_VOICE,
     STS_REPORT_MAX,
     STS_REPORT_ERROR = STS_REPORT_MAX
 } sm_report_type_t;
--- a/src/sm/src/sm_ovsdb.c
+++ b/src/sm/src/sm_ovsdb.c
@@ -62,6 +62,7 @@ char *sm_report_type_str[STS_REPORT_MAX]
     "device",
     "rssi",
     "network_probe",
+    "video_voice",
 };
 
 #ifndef CONFIG_MANAGER_QM
@@ -347,6 +348,7 @@ bool sm_update_stats_config(sm_stats_con
             break;
         case STS_REPORT_DEVICE:
             sm_device_report_request(&req);
+            ucc_report_request(&req);
             break;
         case STS_REPORT_CAPACITY:
 #ifdef CONFIG_SM_CAPACITY_QUEUE_STATS
@@ -361,6 +363,9 @@ bool sm_update_stats_config(sm_stats_con
 	case STS_REPORT_NETWORK_PROBE:
 	sm_network_probe_report_request(&req);
 	break;
+        case STS_REPORT_VIDEO_VOICE:
+            ucc_report_request(&req);
+	break;
         default:
             return false;
     }
--- /dev/null
+++ b/src/sm/src/ucc_report.c
@@ -0,0 +1,301 @@
+/* SPDX-License-Identifier BSD-3-Clause */
+
+#define _GNU_SOURCE
+#include <unistd.h>
+#include <time.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <stdio.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <string.h>
+#include <ev.h>
+#include <fcntl.h>
+#include <libgen.h>
+#include <limits.h>
+
+#include "sm.h"
+#include "dpp_ucc.h"
+#include "nl_ucc.h"
+
+#define MODULE_ID LOG_MODULE_ID_MAIN
+
+/* new part */
+typedef struct
+{
+    bool                            initialized;
+
+    /* Structure containing cloud request timer params */
+    sm_stats_request_t              request;
+    /* Structure pointing to upper layer video/voice storage */
+    dpp_ucc_report_data_t        report;
+
+    /* Reporting start timestamp used for reporting timestamp calculation */
+    uint64_t                        report_ts;
+} sm_ucc_ctx_t;
+
+/* Common place holder for all video/voice stat report contexts */
+static sm_ucc_ctx_t              g_sm_ucc_ctx;
+
+/******************************************************************************
+ *  PROTECTED definitions
+ *****************************************************************************/
+static
+void sm_ucc_report(struct wc_capture_buf *rbuf)
+{
+    sm_ucc_ctx_t *ucc_ctx = &g_sm_ucc_ctx;
+
+    dpp_ucc_report_data_t *report_ctx = &ucc_ctx->report;
+    sm_stats_request_t *request_ctx = &ucc_ctx->request;
+    struct sip_call_start *SipCallStart = NULL;
+    struct sip_call_end *SipCallEnd = NULL;
+    struct sip_call_report *SipCallReport = NULL;
+
+    /* Get ucc stats */
+
+    /* Report_timestamp is base-timestamp + relative start time offset */
+    report_ctx->timestamp_ms =
+        request_ctx->reporting_timestamp - ucc_ctx->report_ts +
+        get_timestamp();
+
+    switch (rbuf->Type)
+    {
+    case PKT_TYPE_CALL_START:
+        report_ctx->type = PKT_TYPE_CALL_START;
+        SipCallStart = (struct sip_call_start *)&rbuf->Buffer[0];
+        report_ctx->record.sip_call_start.clt_mac[0] = rbuf->staMac[0];
+        report_ctx->record.sip_call_start.clt_mac[1] = rbuf->staMac[1];
+        report_ctx->record.sip_call_start.clt_mac[2] = rbuf->staMac[2];
+        report_ctx->record.sip_call_start.clt_mac[3] = rbuf->staMac[3];
+        report_ctx->record.sip_call_start.clt_mac[4] = rbuf->staMac[4];
+        report_ctx->record.sip_call_start.clt_mac[5] = rbuf->staMac[5];
+
+        report_ctx->record.sip_call_start.session_id = SipCallStart->SessionId;
+        memcpy(&(report_ctx->record.sip_call_start.codecs[0][0]),
+               &(SipCallStart->Codecs[0][0]), 450 );
+        memcpy( &(report_ctx->record.sip_call_start.provider_domain[0]),
+               &(SipCallStart->Url[0]), 50 );
+
+	break;
+
+    case PKT_TYPE_CALL_STOP:
+        report_ctx->type = PKT_TYPE_CALL_STOP;
+
+        SipCallEnd = (struct sip_call_end *)&rbuf->Buffer[0];
+
+        report_ctx->record.sip_call_stop.clt_mac[0] = rbuf->staMac[0];
+        report_ctx->record.sip_call_stop.clt_mac[1] = rbuf->staMac[1];
+        report_ctx->record.sip_call_stop.clt_mac[2] = rbuf->staMac[2];
+        report_ctx->record.sip_call_stop.clt_mac[3] = rbuf->staMac[3];
+        report_ctx->record.sip_call_stop.clt_mac[4] = rbuf->staMac[4];
+        report_ctx->record.sip_call_stop.clt_mac[5] = rbuf->staMac[5];
+        report_ctx->record.sip_call_stop.reason = SipCallEnd->Reason;
+
+        report_ctx->record.sip_call_stop.session_id = SipCallEnd->SessionId;
+
+        /* Stats Currently unimplemented */
+        report_ctx->record.sip_call_stop.call_duration = 0;
+        report_ctx->record.sip_call_stop.stats.direction = 0;
+        report_ctx->record.sip_call_stop.stats.type = 0;
+        report_ctx->record.sip_call_stop.stats.latency = 0;
+        report_ctx->record.sip_call_stop.stats.jitter = 0;
+        report_ctx->record.sip_call_stop.stats.packet_loss_percent = 0;
+        report_ctx->record.sip_call_stop.stats.packet_loss_consec = 0;
+        report_ctx->record.sip_call_stop.stats.codec = 0;
+        report_ctx->record.sip_call_stop.stats.MOSx100 = 0;
+        report_ctx->record.sip_call_stop.stats.total_packets_sent = 0;
+        report_ctx->record.sip_call_stop.stats.total_packets_lost = 0;
+        report_ctx->record.sip_call_stop.stats.rtp_seq_first = 0;
+        report_ctx->record.sip_call_stop.stats.rtp_seq_last = 0;
+        report_ctx->record.sip_call_stop.stats.stats_idx = 0;
+	break;
+
+    case PKT_TYPE_CALL_REPORT:
+        report_ctx->type = PKT_TYPE_CALL_REPORT;
+
+        SipCallReport = (struct sip_call_report *)&rbuf->Buffer[0];
+
+        report_ctx->record.sip_call_report.clt_mac[0] = rbuf->staMac[0];
+        report_ctx->record.sip_call_report.clt_mac[1] = rbuf->staMac[1];
+        report_ctx->record.sip_call_report.clt_mac[2] = rbuf->staMac[2];
+        report_ctx->record.sip_call_report.clt_mac[3] = rbuf->staMac[3];
+        report_ctx->record.sip_call_report.clt_mac[4] = rbuf->staMac[4];
+        report_ctx->record.sip_call_report.clt_mac[5] = rbuf->staMac[5];
+        report_ctx->record.sip_call_report.stats.latency = SipCallReport->Latency;
+        report_ctx->record.sip_call_report.stats.jitter = SipCallReport->Jitter;
+        report_ctx->record.sip_call_report.stats.packet_loss_consec = SipCallReport->PacketLoss;
+        report_ctx->record.sip_call_report.stats.MOSx100 = SipCallReport->Mos;
+
+        break;
+    default:
+	break;
+    }
+
+    dpp_put_ucc(report_ctx);
+
+clean:
+
+    SM_SANITY_CHECK_TIME(report_ctx->timestamp_ms,
+                         &request_ctx->reporting_timestamp,
+                         &ucc_ctx->report_ts);
+}
+
+/* Netlink functions */
+static unsigned int mcgroups;		/* Mask of groups */
+
+static void prep_nl_sock(struct nl_sock** nlsock)
+{
+    int family_id, grp_id;
+    unsigned int bit = 0;
+    mcgroups |= 1 << (0); //group 0 Kir-change
+
+    *nlsock = nl_socket_alloc();
+    if(!*nlsock) {
+        fprintf(stderr, "Unable to alloc nl socket!\n");
+        exit(EXIT_FAILURE);
+    }
+
+    /* disable seq checks on multicast sockets */
+    nl_socket_disable_seq_check(*nlsock);
+    nl_socket_disable_auto_ack(*nlsock);
+
+    /* connect to genl */
+    if (genl_connect(*nlsock)) {
+        fprintf(stderr, "Unable to connect to genl!\n");
+        goto exit_err;
+    }
+
+    /* resolve the generic nl family id*/
+    family_id = genl_ctrl_resolve(*nlsock, GENL_UCC_FAMILY_NAME);
+    if(family_id < 0){
+        fprintf(stderr, "Unable to resolve family name!\n");
+        goto exit_err;
+    }
+
+    if (!mcgroups)
+        return;
+
+    while (bit < sizeof(unsigned int)) {
+        if (!(mcgroups & (1 << bit)))
+            goto next;
+
+        grp_id = genl_ctrl_resolve_grp(*nlsock, GENL_UCC_FAMILY_NAME,
+                                        genl_ucc_mcgrp_names[bit]);
+
+        if (grp_id < 0)	{
+            fprintf(stderr, "Unable to resolve group name for %u!\n",
+                    (1 << bit));
+            goto exit_err;
+        }
+        if (nl_socket_add_membership(*nlsock, grp_id)) {
+            fprintf(stderr, "Unable to join group %u!\n",
+                    (1 << bit));
+            goto exit_err;
+        }
+next:
+        bit++;
+    }
+
+    return;
+
+exit_err:
+    nl_socket_free(*nlsock);
+    exit(EXIT_FAILURE);
+}
+
+static int print_rx_msg(struct nl_msg *msg, void* arg)
+{
+	struct nlattr *attr[GENL_UCC_ATTR_MAX+1];
+
+	struct wc_capture_buf *rbuf;
+
+	genlmsg_parse(nlmsg_hdr(msg), 0, attr,
+			GENL_UCC_ATTR_MAX, genl_ucc_policy);
+
+	rbuf =	(struct wc_capture_buf *)nla_data(attr[GENL_UCC_ATTR_MSG]);
+
+	if (!attr[GENL_UCC_ATTR_MSG]) {
+		fprintf(stdout, "Kernel sent empty message!!\n");
+		return NL_OK;
+	}
+
+	sm_ucc_report(rbuf);
+
+	return NL_OK;
+}
+
+static int skip_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+static ev_io ucc_io;
+struct nl_sock *nlsock;
+
+static void nl_event(struct ev_loop *ev, struct ev_io *io, int event)
+{
+    struct nl_cb *cb = NULL;
+    /* prep the cb */
+    cb = nl_cb_alloc(NL_CB_DEFAULT);
+    nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, skip_seq_check, NULL);
+    nl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, print_rx_msg, NULL);
+    nl_recvmsgs(nlsock, cb);
+
+    nl_cb_put(cb);
+
+}
+
+void netlink_listen(void) {
+
+    struct ev_loop *ucc_evloop = EV_DEFAULT;
+
+    prep_nl_sock(&nlsock);
+
+    ev_io_init(&ucc_io, nl_event, nlsock->s_fd, EV_READ);
+    ev_io_start(ucc_evloop, &ucc_io);
+
+//    nl_socket_free(nlsock);
+}
+
+/******************************************************************************
+ *  PUBLIC API definitions
+ *****************************************************************************/
+bool ucc_report_request(
+        sm_stats_request_t         *request)
+{
+    sm_ucc_ctx_t *ucc_ctx = &g_sm_ucc_ctx;
+    sm_stats_request_t *request_ctx = &ucc_ctx->request;
+    dpp_ucc_report_data_t *report_ctx = &ucc_ctx->report;
+
+    if (NULL == request) {
+        LOG(ERR,
+            "Initializing ucc reporting "
+            "(Invalid request config)");
+        return false;
+    }
+
+    /* Initialize global stats only once */
+    if (!ucc_ctx->initialized) {
+        memset(request_ctx, 0, sizeof(*request_ctx));
+        memset(report_ctx, 0, sizeof(*report_ctx));
+
+        LOG(INFO,
+            "Initializing ucc reporting");
+
+	netlink_listen();
+
+        ucc_ctx->initialized = true;
+    }
+
+    /* Store and compare every request parameter ...
+       memcpy would be easier but we want some debug info
+     */
+    REQUEST_VAL_UPDATE("ucc", reporting_count, "%d");
+    REQUEST_VAL_UPDATE("ucc", reporting_interval, "%d");
+    REQUEST_VAL_UPDATE("ucc", reporting_timestamp, "%"PRIu64"");
+
+
+    return true;
+}
--- a/src/sm/unit.mk
+++ b/src/sm/unit.mk
@@ -44,6 +44,7 @@ UNIT_SRC     += src/sm_radio_config.c
 UNIT_SRC     += src/sm_scan_schedule.c
 UNIT_SRC     += src/sm_rssi_report.c
 UNIT_SRC     += src/sm_network_probe_report.c
+UNIT_SRC     += src/ucc_report.c
 UNIT_SRC     += src/sm_common.c
 
 ifeq ($(CONFIG_SM_CAPACITY_QUEUE_STATS),y)
