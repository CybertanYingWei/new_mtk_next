From 240c13e4767cba7ecc0e1821f572ffc4e72031d8 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Thu, 16 May 2024 11:32:20 +0800
Subject: [PATCH] add sonicfi rap630w 211g

Signed-off-by: Your Name <you@example.com>
---
 include/image-commands.mk                     |  38 +-
 .../sonicfi/nand_sonicfi_rap630w_211g.sh      | 511 ++++++++++
 package/base-files/files/sbin/sysupgrade      |   8 +
 .../boot/uboot-envtools/files/mediatek_mt7981 | 192 ++++
 scripts/mkits_sonicfi_rap630w_211g.sh         | 237 +++++
 .../631-supprt_tps23861_poe_pse.patch         | 940 ++++++++++++++++++
 tools/Makefile                                |   1 +
 tools/crc32sum/Makefile                       |  23 +
 tools/crc32sum/src/Makefile                   |  18 +
 tools/crc32sum/src/crc32sum.c                 | 282 ++++++
 10 files changed, 2249 insertions(+), 1 deletion(-)
 create mode 100644 package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
 create mode 100644 package/boot/uboot-envtools/files/mediatek_mt7981
 create mode 100755 scripts/mkits_sonicfi_rap630w_211g.sh
 create mode 100644 target/linux/generic/pending-5.4/631-supprt_tps23861_poe_pse.patch
 create mode 100644 tools/crc32sum/Makefile
 create mode 100644 tools/crc32sum/src/Makefile
 create mode 100644 tools/crc32sum/src/crc32sum.c

diff --git a/include/image-commands.mk b/include/image-commands.mk
index dc6ee6e7c1..90b8de3108 100644
--- a/include/image-commands.mk
+++ b/include/image-commands.mk
@@ -137,6 +137,7 @@ define Build/append-ubi
 	sh $(TOPDIR)/scripts/ubinize-image.sh \
 		$(if $(UBOOTENV_IN_UBI),--uboot-env) \
 		$(if $(KERNEL_IN_UBI),--kernel $(IMAGE_KERNEL)) \
+		$(if $(ROOTFSNAME_IN_UBI),--rootfs_name $(ROOTFSNAME_IN_UBI)) \
 		$(foreach part,$(UBINIZE_PARTS),--part $(part)) \
 		--rootfs $(IMAGE_ROOTFS) \
 		$@.tmp \
@@ -291,6 +292,32 @@ define Build/initrd_compression
 	$(if $(CONFIG_TARGET_INITRAMFS_COMPRESSION_ZSTD),.zstd)
 endef
 
+ifeq ($(CONFIG_TARGET_mediatek_mt7981_DEVICE_sonicfi_rap630w_211g),y)
+define Build/fit
+	$(TOPDIR)/scripts/mkits_sonicfi_rap630w_211g.sh \
+		-D $(DEVICE_NAME) -o $@.its -k $@ \
+		-C $(word 1,$(1)) \
+		$(if $(word 2,$(1)),\
+			$(if $(findstring 11,$(if $(DEVICE_DTS_OVERLAY),1)$(if $(findstring $(KERNEL_BUILD_DIR)/image-,$(word 2,$(1))),,1)), \
+				-d $(KERNEL_BUILD_DIR)/image-$$(basename $(word 2,$(1))), \
+				-d $(word 2,$(1)))) \
+		$(if $(findstring with-rootfs,$(word 3,$(1))),-r $(IMAGE_ROOTFS)) \
+		$(if $(findstring with-initrd,$(word 3,$(1))), \
+			$(if $(CONFIG_TARGET_ROOTFS_INITRAMFS_SEPARATE), \
+				-i $(KERNEL_BUILD_DIR)/initrd.cpio$(strip $(call Build/initrd_compression)))) \
+		-a $(KERNEL_LOADADDR) -e $(if $(KERNEL_ENTRY),$(KERNEL_ENTRY),$(KERNEL_LOADADDR)) \
+		$(if $(DEVICE_FDT_NUM),-n $(DEVICE_FDT_NUM)) \
+		$(if $(DEVICE_DTS_DELIMITER),-l $(DEVICE_DTS_DELIMITER)) \
+		$(if $(DEVICE_DTS_LOADADDR),-s $(DEVICE_DTS_LOADADDR)) \
+		$(if $(DEVICE_DTS_OVERLAY),$(foreach dtso,$(DEVICE_DTS_OVERLAY), -O $(dtso):$(KERNEL_BUILD_DIR)/image-$(dtso).dtbo)) \
+		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config-1") \
+		-A $(LINUX_KARCH) -v $(LINUX_VERSION) \
+		$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),-r $(ROOTFS/squashfs/$(DEVICE_NAME)))
+	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage $(if $(findstring external,$(word 3,$(1))),\
+		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
+	@mv $@.new $@
+endef
+else
 define Build/fit
 	$(TOPDIR)/scripts/mkits.sh \
 		-D $(DEVICE_NAME) -o $@.its -k $@ \
@@ -309,11 +336,13 @@ define Build/fit
 		$(if $(DEVICE_DTS_LOADADDR),-s $(DEVICE_DTS_LOADADDR)) \
 		$(if $(DEVICE_DTS_OVERLAY),$(foreach dtso,$(DEVICE_DTS_OVERLAY), -O $(dtso):$(KERNEL_BUILD_DIR)/image-$(dtso).dtbo)) \
 		-c $(if $(DEVICE_DTS_CONFIG),$(DEVICE_DTS_CONFIG),"config-1") \
-		-A $(LINUX_KARCH) -v $(LINUX_VERSION)
+		-A $(LINUX_KARCH) -v $(LINUX_VERSION) \
+		$(if $(CONFIG_TARGET_ROOTFS_SQUASHFS),-r $(ROOTFS/squashfs/$(DEVICE_NAME)))
 	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage $(if $(findstring external,$(word 3,$(1))),\
 		-E -B 0x1000 $(if $(findstring static,$(word 3,$(1))),-p 0x1000)) -f $@.its $@.new
 	@mv $@.new $@
 endef
+endif
 
 define Build/libdeflate-gzip
 	$(STAGING_DIR_HOST)/bin/libdeflate-gzip -f -12 -c $@ $(1) > $@.new
@@ -498,6 +527,13 @@ define Build/qsdk-ipq-factory-nor
 	@mv $@.new $@
 endef
 
+define Build/qsdk-ipq-factory-mmc
+	$(TOPDIR)/scripts/mkits-qsdk-ipq-image.sh \
+		$@.its hlos $(IMAGE_KERNEL) rootfs $(IMAGE_ROOTFS)
+	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage -f $@.its $@.new
+	@mv $@.new $@
+endef
+
 define Build/seama
 	$(STAGING_DIR_HOST)/bin/seama -i $@ \
 		-m "dev=/dev/mtdblock/$(SEAMA_MTDBLOCK)" -m "type=firmware"
diff --git a/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh b/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
new file mode 100644
index 0000000000..bd27da76cd
--- /dev/null
+++ b/package/base-files/files/lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh
@@ -0,0 +1,511 @@
+# Copyright (C) 2014 OpenWrt.org
+#
+
+. /lib/functions.sh
+
+# 'kernel' partition on NAND contains the kernel
+CI_KERNPART="${CI_KERNPART:-kernel}"
+
+# 'ubi' partition on NAND contains UBI
+CI_UBIPART="${CI_UBIPART:-ubi}"
+
+# 'rootfs' partition on NAND contains the rootfs
+CI_ROOTPART="${CI_ROOTPART:-rootfs}"
+
+get_boot_param()
+{
+	local cmdline_param=$(cat /proc/cmdline)
+	local name
+	for var in $cmdline_param
+	do
+		#echo "aaa---$var"
+		if [ $var == $1 ];
+		then
+			echo "Y"
+			return
+		else
+			name=$(echo $var | awk -F '=' '{print $1}')
+			#echo "$name"
+			if [ $name == $1 ];
+			then
+					echo $(echo $var | awk -F '=' '{print $2}')
+					return
+			fi
+		fi
+	done
+	echo "N"
+}
+
+ubi_mknod() {
+	local dir="$1"
+	local dev="/dev/$(basename $dir)"
+
+	[ -e "$dev" ] && return 0
+
+	local devid="$(cat $dir/dev)"
+	local major="${devid%%:*}"
+	local minor="${devid##*:}"
+	mknod "$dev" c $major $minor
+}
+
+nand_find_volume() {
+	local ubidevdir ubivoldir
+	ubidevdir="/sys/devices/virtual/ubi/$1"
+	[ ! -d "$ubidevdir" ] && return 1
+	for ubivoldir in $ubidevdir/${1}_*; do
+		[ ! -d "$ubivoldir" ] && continue
+		if [ "$( cat $ubivoldir/name )" = "$2" ]; then
+			basename $ubivoldir
+			ubi_mknod "$ubivoldir"
+			return 0
+		fi
+	done
+}
+
+nand_find_ubi() {
+	local ubidevdir ubidev mtdnum
+	mtdnum="$( find_mtd_index $1 )"
+	[ ! "$mtdnum" ] && return 1
+	for ubidevdir in /sys/devices/virtual/ubi/ubi*; do
+		[ ! -d "$ubidevdir" ] && continue
+		cmtdnum="$( cat $ubidevdir/mtd_num )"
+		[ ! "$mtdnum" ] && continue
+		if [ "$mtdnum" = "$cmtdnum" ]; then
+			ubidev=$( basename $ubidevdir )
+			ubi_mknod "$ubidevdir"
+			echo $ubidev
+			return 0
+		fi
+	done
+}
+
+nand_get_magic_long() {
+	dd if="$1" skip=$2 bs=4 count=1 2>/dev/null | hexdump -v -n 4 -e '1/1 "%02x"'
+}
+
+get_magic_long_tar() {
+	( tar xf $1 $2 -O | dd bs=4 count=1 | hexdump -v -n 4 -e '1/1 "%02x"') 2> /dev/null
+}
+
+identify_magic() {
+	local magic=$1
+	case "$magic" in
+		"55424923")
+			echo "ubi"
+			;;
+		"31181006")
+			echo "ubifs"
+			;;
+		"68737173")
+			echo "squashfs"
+			;;
+		"d00dfeed")
+			echo "fit"
+			;;
+		"4349"*)
+			echo "combined"
+			;;
+		*)
+			echo "unknown $magic"
+			;;
+	esac
+}
+
+
+identify() {
+	identify_magic $(nand_get_magic_long "$1" "${2:-0}")
+}
+
+identify_tar() {
+	identify_magic $(get_magic_long_tar "$1" "$2")
+}
+
+nand_restore_config() {
+	sync
+	local ubidev=$( nand_find_ubi $CI_UBIPART )
+	local ubivol="$( nand_find_volume $ubidev rootfs_data )"
+	[ ! "$ubivol" ] &&
+		ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+	mkdir /tmp/new_root
+	if ! mount -t ubifs /dev/$ubivol /tmp/new_root; then
+		echo "mounting ubifs $ubivol failed"
+		rmdir /tmp/new_root
+		return 1
+	fi
+	mv "$1" "/tmp/new_root/$BACKUP_FILE"
+	umount /tmp/new_root
+	sync
+	rmdir /tmp/new_root
+}
+
+nand_upgrade_prepare_ubi() {
+	local rootfs_length="$1"
+	local rootfs_type="$2"
+	local has_kernel="${3:-0}"
+	local has_env="${4:-0}"
+
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition $CI_UBIPART"
+		return 1
+	fi
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	if [ ! "$ubidev" ]; then
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	fi
+
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		[ "$has_env" -gt 0 ] && {
+			ubimkvol /dev/$ubidev -n 0 -N ubootenv -s 1MiB
+			ubimkvol /dev/$ubidev -n 1 -N ubootenv2 -s 1MiB
+		}
+	fi
+
+	local kern_ubivol="$( nand_find_volume $ubidev $CI_KERNPART )"
+	local root_ubivol="$( nand_find_volume $ubidev $CI_ROOTPART )"
+	local data_ubivol="$( nand_find_volume $ubidev rootfs_data )"
+
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
+	fi
+
+	# kill volumes
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_KERNPART || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $CI_ROOTPART || true
+	[ "$data_ubivol" ] && ubirmvol /dev/$ubidev -N rootfs_data || true
+
+	# update kernel
+	if [ "$has_kernel" = "1" ]; then
+		if ! ubimkvol /dev/$ubidev -N $CI_KERNPART -s $kernel_length; then
+			echo "cannot create kernel volume"
+			return 1;
+		fi
+	fi
+
+	# update rootfs
+	local root_size_param
+	if [ "$rootfs_type" = "ubifs" ]; then
+		root_size_param="-m"
+	else
+		root_size_param="-s $rootfs_length"
+	fi
+	if ! ubimkvol /dev/$ubidev -N $CI_ROOTPART $root_size_param; then
+		echo "cannot create rootfs volume"
+		return 1;
+	fi
+
+	# create rootfs_data for non-ubifs rootfs
+	if [ "$rootfs_type" != "ubifs" ]; then
+		if ! ubimkvol /dev/$ubidev -N rootfs_data -m; then
+			echo "cannot initialize rootfs_data volume"
+			return 1
+		fi
+	fi
+	sync
+	return 0
+}
+
+nand_do_upgrade_success() {
+	local conf_tar="/tmp/sysupgrade.tgz"
+
+	sync
+	[ -f "$conf_tar" ] && nand_restore_config "$conf_tar"
+	echo "sysupgrade successful"
+	umount -a
+	reboot -f
+}
+
+# Flash the UBI image to MTD partition
+nand_upgrade_ubinized() {
+	local ubi_file="$1"
+	local mtdnum="$(find_mtd_index "$CI_UBIPART")"
+
+	[ ! "$mtdnum" ] && {
+		CI_UBIPART="rootfs"
+		mtdnum="$(find_mtd_index "$CI_UBIPART")"
+	}
+
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find mtd device $CI_UBIPART"
+		umount -a
+		reboot -f
+	fi
+
+	local mtddev="/dev/mtd${mtdnum}"
+	ubidetach -p "${mtddev}" || true
+	sync
+	ubiformat "${mtddev}" -y -f "${ubi_file}"
+	ubiattach -p "${mtddev}"
+	nand_do_upgrade_success
+}
+
+# Write the UBIFS image to UBI volume
+nand_upgrade_ubifs() {
+	local rootfs_length=$( (cat $1 | wc -c) 2> /dev/null)
+
+	nand_upgrade_prepare_ubi "$rootfs_length" "ubifs" "0" "0"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	ubiupdatevol /dev/$root_ubivol -s $rootfs_length $1
+
+	nand_do_upgrade_success
+}
+
+nand_upgrade_tar() {
+	local tar_file="$1"
+	local kernel_mtd="$(find_mtd_index $CI_KERNPART)"
+
+	local board_dir=$(tar tf $tar_file | grep -m 1 '^sysupgrade-.*/$')
+	board_dir=${board_dir%/}
+
+	local kernel_length=$( (tar xf $tar_file ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf $tar_file ${board_dir}/root -O | wc -c) 2> /dev/null)
+
+	local rootfs_type="$(identify_tar "$tar_file" ${board_dir}/root)"
+
+	local has_kernel=1
+	local has_env=0
+
+	[ "$kernel_length" != 0 -a -n "$kernel_mtd" ] && {
+		tar xf $tar_file ${board_dir}/kernel -O | mtd write - $CI_KERNPART
+	}
+	[ "$kernel_length" = 0 -o ! -z "$kernel_mtd" ] && has_kernel=0
+
+	nand_upgrade_prepare_ubi "$rootfs_length" "$rootfs_type" "$has_kernel" "$has_env"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	[ "$has_kernel" = "1" ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev $CI_KERNPART)"
+		tar xf $tar_file ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/$kern_ubivol -s $kernel_length -
+	}
+
+	local root_ubivol="$(nand_find_volume $ubidev $CI_ROOTPART)"
+	tar xf $tar_file ${board_dir}/root -O | \
+		ubiupdatevol /dev/$root_ubivol -s $rootfs_length -
+
+	nand_do_upgrade_success
+}
+
+# Recognize type of passed file and start the upgrade process
+nand_do_upgrade() {
+	local file_type=$(identify $1)
+
+	[ ! "$(find_mtd_index "$CI_UBIPART")" ] && CI_UBIPART="rootfs"
+
+	case "$file_type" in
+		"ubi")		nand_upgrade_ubinized $1;;
+		"ubifs")	nand_upgrade_ubifs $1;;
+		*)		nand_upgrade_tar $1;;
+	esac
+}
+
+# Check if passed file is a valid one for NAND sysupgrade. Currently it accepts
+# 3 types of files:
+# 1) UBI - should contain an ubinized image, header is checked for the proper
+#    MAGIC
+# 2) UBIFS - should contain UBIFS partition that will replace "rootfs" volume,
+#    header is checked for the proper MAGIC
+# 3) TAR - archive has to include "sysupgrade-BOARD" directory with a non-empty
+#    "CONTROL" file (at this point its content isn't verified)
+#
+# You usually want to call this function in platform_check_image.
+#
+# $(1): board name, used in case of passing TAR file
+# $(2): file to be checked
+nand_do_platform_check() {
+	local board_name="$1"
+	local tar_file="$2"
+	local control_length=$( (tar xf $tar_file sysupgrade-$board_name/CONTROL -O | wc -c) 2> /dev/null)
+	local file_type="$(identify $2)"
+
+	[ "$control_length" = 0 -a "$file_type" != "ubi" -a "$file_type" != "ubifs" ] && {
+		echo "Invalid sysupgrade file."
+		return 1
+	}
+
+	return 0
+}
+
+dual_boot_upgrade_prepare_ubi() {
+	local kernel_vol_name="$1"
+	local rootfs_vol_name="$2"
+	local kernel_length="$3"
+	local rootfs_length="$4"
+	local reserve_rootfs_data="$5"
+	local conf_tar="/tmp/sysupgrade.tgz"
+
+	local mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+	if [ ! "$mtdnum" ]; then
+		echo "cannot find ubi mtd partition $CI_UBIPART"
+		return 1
+	fi
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	if [ ! "$ubidev" ]; then
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+	fi
+
+	if [ ! "$ubidev" ]; then
+		ubiformat /dev/mtd$mtdnum -y
+		ubiattach -m "$mtdnum"
+		sync
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		ubimkvol /dev/$ubidev -n 0 -N u-boot-env -s 512KiB
+	fi
+
+	#local rootfs_data_vol_name=$(cat /sys/module/boot_param/parameters/rootfs_data_part 2>/dev/null)
+	local rootfs_data_vol_name=$(get_boot_param "boot_param.rootfs_data_part")
+	
+	local kern_ubivol="$( nand_find_volume $ubidev $kernel_vol_name )"
+	local root_ubivol="$( nand_find_volume $ubidev $rootfs_vol_name )"
+	local data_ubivol="$( nand_find_volume $ubidev $rootfs_data_vol_name )"
+
+	# remove ubiblock device of rootfs
+	local root_ubiblk="ubiblock${root_ubivol:3}"
+	if [ "$root_ubivol" -a -e "/dev/$root_ubiblk" ]; then
+		echo "removing $root_ubiblk"
+		if ! ubiblock -r /dev/$root_ubivol; then
+			echo "cannot remove $root_ubiblk"
+			return 1;
+		fi
+	fi
+
+	# kill volumes
+	[ "$kern_ubivol" ] && ubirmvol /dev/$ubidev -N $kernel_vol_name || true
+	[ "$root_ubivol" ] && ubirmvol /dev/$ubidev -N $rootfs_vol_name || true
+
+	# update kernel
+	if ! ubimkvol /dev/$ubidev -N $kernel_vol_name -s $kernel_length; then
+		echo "cannot create kernel volume"
+		return 1;
+	fi
+
+	# update rootfs
+	if ! ubimkvol /dev/$ubidev -N $rootfs_vol_name -s $rootfs_length; then
+		echo "cannot create rootfs volume"
+		return 1;
+	fi
+
+	if [ x"${reserve_rootfs_data}" = xY ] && [ -f "$conf_tar" ]; then
+		# Do not touch rootfs_data
+		sync
+		return 0
+	fi
+
+	# 'format' rootfs_data volume
+	[ "$data_ubivol" ] && {
+		local rootfs_data_length=$(cat /sys/class/ubi/$data_ubivol/data_bytes)
+
+		# kill rootfs_data volume
+		ubirmvol /dev/$ubidev -N $rootfs_data_vol_name || true
+
+		# update rootfs_data
+		if ! ubimkvol /dev/$ubidev -N $rootfs_data_vol_name -s $rootfs_data_length; then
+			echo "cannot create $rootfs_data_vol_name volume"
+		fi
+	}
+
+	sync
+	return 0
+}
+
+ubi_dual_boot_upgrade_tar() {
+	local tar_file="$1"
+	local board_dir=$(tar tf ${tar_file} | grep -m 1 '^sysupgrade-.*/$')
+	#local reserve_rootfs_data=$(cat /sys/module/boot_param/parameters/reserve_rootfs_data 2>/dev/null)
+	local reserve_rootfs_data=$(get_boot_param "boot_param.reserve_rootfs_data")
+	board_dir=${board_dir%/}
+
+	#kernel_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_kernel_part 2>/dev/null)
+	kernel_vol_name=$(get_boot_param "boot_param.upgrade_kernel_part")
+	[ -z "${kernel_vol_name}" -o $? -ne 0 ] && return 1
+
+	#rootfs_vol_name=$(cat /sys/module/boot_param/parameters/upgrade_rootfs_part 2>/dev/null)
+	rootfs_vol_name=$(get_boot_param "boot_param.upgrade_rootfs_part")
+	[ -z "${rootfs_vol_name}" -o $? -ne 0 ] && return 1
+
+	local kernel_length=$( (tar xf ${tar_file} ${board_dir}/kernel -O | wc -c) 2> /dev/null)
+	local rootfs_length=$( (tar xf ${tar_file} ${board_dir}/root -O | wc -c) 2> /dev/null)
+	echo "kernel_vol_name=$kernel_vol_name,rootfs_vol_name=$rootfs_vol_name,kernel_length=$kernel_length,rootfs_length=$rootfs_length,reserve_rootfs_data=$reserve_rootfs_data"
+	dual_boot_upgrade_prepare_ubi "${kernel_vol_name}" "${rootfs_vol_name}" \
+				      "${kernel_length}" "${rootfs_length}" \
+				      "${reserve_rootfs_data}"
+
+	local ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+
+	[ "${kernel_length}" != 0 ] && {
+		local kern_ubivol="$(nand_find_volume $ubidev ${kernel_vol_name})"
+		tar xf ${tar_file} ${board_dir}/kernel -O | \
+			ubiupdatevol /dev/${kern_ubivol} -s ${kernel_length} -
+	}
+
+	[ "${rootfs_length}" != 0 ] && {
+		local root_ubivol="$(nand_find_volume $ubidev ${rootfs_vol_name})"
+		tar xf ${tar_file} ${board_dir}/root -O | \
+			ubiupdatevol /dev/${root_ubivol} -s ${rootfs_length} -
+	}
+
+	#upgrade_image_slot=$(cat /sys/module/boot_param/parameters/upgrade_image_slot 2>/dev/null)
+	upgrade_image_slot=$(get_boot_param "boot_param.upgrade_image_slot")
+	[ -n "${upgrade_image_slot}" ] && {
+		echo "Set new boot image slot to ${upgrade_image_slot}"
+		# Force the creation of fw_printenv.lock
+		mkdir -p /var/lock
+		touch /var/lock/fw_printenv.lock
+		fw_setenv "dual_boot.current_slot" "${upgrade_image_slot}"
+		fw_setenv "dual_boot.slot_${upgrade_image_slot}_invalid" "0"
+	}
+
+	if [ x"${reserve_rootfs_data}" != xY ]; then
+		# do normal upgrade flow
+		nand_do_upgrade_success
+	fi
+
+	# Do not touch rootfs_data
+	sync
+
+	echo "sysupgrade successful"
+	umount -a
+	reboot -f
+}
+
+ubi_do_upgrade() {
+	#local dual_boot=$(cat /sys/module/boot_param/parameters/dual_boot 2>/dev/null)
+	local dual_boot=$(get_boot_param "boot_param.dual_boot")
+	local file_type=$(identify $1)
+
+	if [ -b /dev/dm-0 ]; then
+		v "Detach all device mapper devices"
+		dmsetup remove_all
+	fi
+	echo "dual_boot=$dual_boot file_type=$file_type"
+	if [ x"${dual_boot}" != xY ]; then
+		nand_do_upgrade "$1"
+		return
+	fi
+
+	case "$file_type" in
+		"ubi")		v "Unsupported firmware type: ubinized";;
+		"ubifs")	v "Unsupported firmware type: ubifs";;
+		*)		ubi_dual_boot_upgrade_tar $1;;
+	esac
+}
+
+ubi_do_upgrade "$1"
diff --git a/package/base-files/files/sbin/sysupgrade b/package/base-files/files/sbin/sysupgrade
index 9315091302..28b9ed3c8e 100755
--- a/package/base-files/files/sbin/sysupgrade
+++ b/package/base-files/files/sbin/sysupgrade
@@ -366,6 +366,14 @@ v "Commencing upgrade. Closing all shell sessions."
 
 COMMAND='/lib/upgrade/do_stage2'
 
+board=$(board_name)
+case "$board" in
+	sonicfi,rap630w-211g)
+	cp /lib/upgrade/sonicfi/nand_sonicfi_rap630w_211g.sh /tmp/nand_sonicfi_rap630w_211g.sh
+	chmod 777 /tmp/nand_sonicfi_rap630w_211g.sh
+	;;
+esac
+
 if [ -n "$FAILSAFE" ]; then
 	printf '%s\x00%s\x00%s' "$RAM_ROOT" "$IMAGE" "$COMMAND" >/tmp/sysupgrade
 	lock -u /tmp/.failsafe
diff --git a/package/boot/uboot-envtools/files/mediatek_mt7981 b/package/boot/uboot-envtools/files/mediatek_mt7981
new file mode 100644
index 0000000000..f20de8b63a
--- /dev/null
+++ b/package/boot/uboot-envtools/files/mediatek_mt7981
@@ -0,0 +1,192 @@
+#
+# Copyright (C) 2021 OpenWrt.org
+#
+
+[ -e /etc/config/ubootenv ] && exit 0
+
+touch /etc/config/ubootenv
+
+. /lib/uboot-envtools.sh
+. /lib/functions.sh
+
+CI_UBIPART=ubi
+
+ubi_mknod() {
+        local dir="$1"
+        local dev="/dev/$(basename $dir)"
+
+        [ -e "$dev" ] && return 0
+
+        local devid="$(cat $dir/dev)"
+        local major="${devid%%:*}"
+        local minor="${devid##*:}"
+        mknod "$dev" c $major $minor
+}
+
+get_boot_param()
+{
+	local cmdline_param=$(cat /proc/cmdline)
+	local name
+	for var in $cmdline_param
+	do
+		#echo "aaa---$var"
+		if [ $var == $1 ];
+		then
+			echo "Y"
+			return
+		else
+			name=$(echo $var | awk -F '=' '{print $1}')
+			#echo "$name"
+			if [ $name == $1 ];
+			then
+					echo $(echo $var | awk -F '=' '{print $2}')
+					return
+			fi
+		fi
+	done
+	echo "N"
+}
+
+block_dev_path() {
+	local dev_path
+
+	case "$1" in
+	/dev/mmcblk*)
+		dev_path="$1"
+		;;
+	PARTLABEL=* | PARTUUID=*)
+		dev_path=$(blkid -t "$1" -o device)
+		[ -z "${dev_path}" -o $? -ne 0 ] && return 1
+		;;
+	*)
+		return 1;
+		;;
+	esac
+
+	echo "${dev_path}"
+	return 0
+}
+
+nand_find_volume() {
+	local ubidevdir ubivoldir
+	ubidevdir="/sys/devices/virtual/ubi/$1"
+	[ ! -d "$ubidevdir" ] && return 1
+	for ubivoldir in $ubidevdir/${1}_*; do
+		[ ! -d "$ubivoldir" ] && continue
+		if [ "$( cat $ubivoldir/name )" = "$2" ]; then
+			basename $ubivoldir
+			ubi_mknod "$ubivoldir"
+			return 0
+		fi
+	done
+}
+
+nand_find_ubi() {
+	local ubidevdir ubidev mtdnum
+	mtdnum="$( find_mtd_index $1 )"
+	[ ! "$mtdnum" ] && return 1
+	for ubidevdir in /sys/devices/virtual/ubi/ubi*; do
+		[ ! -d "$ubidevdir" ] && continue
+		cmtdnum="$( cat $ubidevdir/mtd_num )"
+		[ ! "$mtdnum" ] && continue
+		if [ "$mtdnum" = "$cmtdnum" ]; then
+			ubidev=$( basename $ubidevdir )
+			ubi_mknod "$ubidevdir"
+			echo $ubidev
+			return 0
+		fi
+	done
+}
+
+board=$(board_name)
+
+case "$board" in
+bananapi,bpi-r3)
+	rootdev="$(cmdline_get_var root)"
+	rootdev="${rootdev##*/}"
+	rootdev="${rootdev%%p[0-9]*}"
+	case "$rootdev" in
+	mmc*)
+		local envdev=$(find_mmc_part "ubootenv" $rootdev)
+		ubootenv_add_uci_config "$envdev" "0x0" "0x40000" "0x40000" "1"
+		ubootenv_add_uci_config "$envdev" "0x40000" "0x40000" "0x40000" "1"
+		;;
+	mtd*)
+		local envdev=/dev/mtd$(find_mtd_index "u-boot-env")
+		ubootenv_add_uci_config "$envdev" "0x0" "0x20000" "0x20000" "1"
+		ubootenv_add_uci_config "$envdev" "0x20000" "0x20000" "0x20000" "1"
+		;;
+	ubi*)
+		. /lib/upgrade/nand.sh
+		local envubi=$(nand_find_ubi ubi)
+		local envdev=/dev/$(nand_find_volume $envubi ubootenv)
+		local envdev2=/dev/$(nand_find_volume $envubi ubootenv2)
+		ubootenv_add_uci_config "$envdev" "0x0" "0x1f000" "0x1f000" "1"
+		ubootenv_add_uci_config "$envdev2" "0x0" "0x1f000" "0x1f000" "1"
+		;;
+	esac
+	;;
+sonicfi,rap630w-211g)
+	#env_dev=$(cat /sys/module/boot_param/parameters/env_part 2>/dev/null)
+	env_dev=$(get_boot_param "boot_param.env_part")
+	if [ -n "$env_dev" ]; then
+		mtdnum="$( find_mtd_index "$CI_UBIPART" )"
+		if [ ! "$mtdnum" ]; then
+			echo "cannot find ubi mtd partition $CI_UBIPART"
+			return 1
+		fi
+
+		ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		if [ ! "$ubidev" ]; then
+			ubiattach -m "$mtdnum"
+			sync
+			ubidev="$( nand_find_ubi "$CI_UBIPART" )"
+		fi
+
+		env_ubivol="$( nand_find_volume "${ubidev}" ${env_dev} )"
+		if [ -n "${env_ubivol}" ]; then
+			ubootenv_add_uci_config "/dev/$env_ubivol" "0" "0x80000" "0x80000" 1
+		fi
+	fi
+	;;
+glinet,gl-mt3000)
+	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x80000" "0x20000"
+	;;
+mercusys,mr90x-v1)
+	local envdev=/dev/mtd$(find_mtd_index "u-boot-env")
+	ubootenv_add_uci_config "$envdev" "0x0" "0x20000" "0x20000" "1"
+	;;
+edgecore,eap111|\
+netgear,wax220)
+	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x20000" "0x20000"
+	;;
+xiaomi,mi-router-wr30u-112m-nmbm|\
+xiaomi,mi-router-wr30u-stock|\
+xiaomi,redmi-router-ax6000-stock)
+	ubootenv_add_uci_config "/dev/mtd1" "0x0" "0x10000" "0x20000"
+	ubootenv_add_uci_sys_config "/dev/mtd2" "0x0" "0x10000" "0x20000"
+	;;
+h3c,magic-nx30-pro|\
+qihoo,360t7|\
+tplink,tl-xdr4288|\
+tplink,tl-xdr6086|\
+tplink,tl-xdr6088|\
+xiaomi,mi-router-wr30u-ubootmod|\
+xiaomi,redmi-router-ax6000-ubootmod)
+	. /lib/upgrade/nand.sh
+	local envubi=$(nand_find_ubi ubi)
+	local envdev=/dev/$(nand_find_volume $envubi ubootenv)
+	local envdev2=/dev/$(nand_find_volume $envubi ubootenv2)
+	ubootenv_add_uci_config "$envdev" "0x0" "0x1f000" "0x20000" "1"
+	ubootenv_add_uci_config "$envdev2" "0x0" "0x1f000" "0x20000" "1"
+	;;
+zyxel,ex5601-t0)
+	local envdev=/dev/mtd$(find_mtd_index "u-boot-env")
+	ubootenv_add_uci_config "$envdev" "0x0" "0x20000" "0x40000" "2"
+	;;
+esac
+
+config_load ubootenv
+config_foreach ubootenv_add_app_config
+
+exit 0
diff --git a/scripts/mkits_sonicfi_rap630w_211g.sh b/scripts/mkits_sonicfi_rap630w_211g.sh
new file mode 100755
index 0000000000..35f2d00767
--- /dev/null
+++ b/scripts/mkits_sonicfi_rap630w_211g.sh
@@ -0,0 +1,237 @@
+#!/bin/sh
+#
+# Licensed under the terms of the GNU GPL License version 2 or later.
+#
+# Author: Peter Tyser <ptyser@xes-inc.com>
+#
+# U-Boot firmware supports the booting of images in the Flattened Image
+# Tree (FIT) format.  The FIT format uses a device tree structure to
+# describe a kernel image, device tree blob, ramdisk, etc.  This script
+# creates an Image Tree Source (.its file) which can be passed to the
+# 'mkimage' utility to generate an Image Tree Blob (.itb file).  The .itb
+# file can then be booted by U-Boot (or other bootloaders which support
+# FIT images).  See doc/uImage.FIT/howto.txt in U-Boot source code for
+# additional information on FIT images.
+#
+
+usage() {
+	printf "Usage: %s -A arch -C comp -a addr -e entry" "$(basename "$0")"
+	printf " -v version -k kernel [-D name -n address -d dtb] -o its_file"
+
+	printf "\n\t-A ==> set architecture to 'arch'"
+	printf "\n\t-C ==> set compression type 'comp'"
+	printf "\n\t-c ==> set config name 'config'"
+	printf "\n\t-a ==> set load address to 'addr' (hex)"
+	printf "\n\t-e ==> set entry point to 'entry' (hex)"
+	printf "\n\t-f ==> set device tree compatible string"
+	printf "\n\t-i ==> include initrd Blob 'initrd'"
+	printf "\n\t-v ==> set kernel version to 'version'"
+	printf "\n\t-k ==> include kernel image 'kernel'"
+	printf "\n\t-D ==> human friendly Device Tree Blob 'name'"
+	printf "\n\t-n ==> fdt unit-address 'address'"
+	printf "\n\t-d ==> include Device Tree Blob 'dtb'"
+	printf "\n\t-r ==> include RootFS blob 'rootfs'"
+	printf "\n\t-H ==> specify hash algo instead of SHA1"
+	printf "\n\t-l ==> legacy mode character (@ etc otherwise -)"
+	printf "\n\t-o ==> create output file 'its_file'"
+	printf "\n\t-O ==> create config with dt overlay 'name:dtb'"
+	printf "\n\t-s ==> set FDT load address to 'addr' (hex)"
+	printf "\n\t\t(can be specified more than once)\n"
+	exit 1
+}
+
+REFERENCE_CHAR='-'
+FDTNUM=1
+ROOTFSNUM=1
+INITRDNUM=1
+HASH=sha1
+LOADABLES=
+DTOVERLAY=
+DTADDR=
+
+while getopts ":A:a:c:C:D:d:e:f:i:k:l:n:o:O:v:r:s:H:" OPTION
+do
+	case $OPTION in
+		A ) ARCH=$OPTARG;;
+		a ) LOAD_ADDR=$OPTARG;;
+		c ) CONFIG=$OPTARG;;
+		C ) COMPRESS=$OPTARG;;
+		D ) DEVICE=$OPTARG;;
+		d ) DTB=$OPTARG;;
+		e ) ENTRY_ADDR=$OPTARG;;
+		f ) COMPATIBLE=$OPTARG;;
+		i ) INITRD=$OPTARG;;
+		k ) KERNEL=$OPTARG;;
+		l ) REFERENCE_CHAR=$OPTARG;;
+		n ) FDTNUM=$OPTARG;;
+		o ) OUTPUT=$OPTARG;;
+		O ) DTOVERLAY="$DTOVERLAY ${OPTARG}";;
+		r ) ROOTFS=$OPTARG;;
+		s ) FDTADDR=$OPTARG;;
+		H ) HASH=$OPTARG;;
+		v ) VERSION=$OPTARG;;
+		* ) echo "Invalid option passed to '$0' (options:$*)"
+		usage;;
+	esac
+done
+
+# Make sure user entered all required parameters
+if [ -z "${ARCH}" ] || [ -z "${COMPRESS}" ] || [ -z "${LOAD_ADDR}" ] || \
+	[ -z "${ENTRY_ADDR}" ] || [ -z "${VERSION}" ] || [ -z "${KERNEL}" ] || \
+	[ -z "${OUTPUT}" ] || [ -z "${CONFIG}" ]; then
+	usage
+fi
+
+ARCH_UPPER=$(echo "$ARCH" | tr '[:lower:]' '[:upper:]')
+
+if [ -n "${COMPATIBLE}" ]; then
+	COMPATIBLE_PROP="compatible = \"${COMPATIBLE}\";"
+fi
+
+[ "$FDTADDR" ] && {
+	DTADDR="$FDTADDR"
+}
+
+# Conditionally create fdt information
+if [ -n "${DTB}" ]; then
+	FDT_NODE="
+		fdt${REFERENCE_CHAR}$FDTNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree blob\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${DTB}\");
+			type = \"flat_dt\";
+			${DTADDR:+load = <${DTADDR}>;}
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	FDT_PROP="fdt = \"fdt${REFERENCE_CHAR}$FDTNUM\";"
+fi
+
+if [ -n "${INITRD}" ]; then
+	INITRD_NODE="
+		initrd${REFERENCE_CHAR}$INITRDNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} initrd\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${INITRD}\");
+			type = \"ramdisk\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	INITRD_PROP="ramdisk=\"initrd${REFERENCE_CHAR}${INITRDNUM}\";"
+fi
+
+
+if [ -n "${ROOTFS}" ]; then
+	ROOTFS_SIZE=$(stat -c %s ${ROOTFS})
+	ROOTFS_SHA1=$(sha1sum ${ROOTFS} | awk '{print "<0x"substr($0,1,8) " 0x"substr($0,9,8) " 0x"substr($0,17,8) " 0x"substr($0,25,8) " 0x"substr($0,33,8) ">"}')
+	ROOTFS_CRC32=$(crc32sum ${ROOTFS})
+	ROOTFS_NODE="
+		rootfs {
+				size = <${ROOTFS_SIZE}>;
+				hash-1 {
+					value = <0x${ROOTFS_CRC32}>;
+					algo = \"crc32\";
+					};
+				hash-2 {
+					value = ${ROOTFS_SHA1};
+					algo = \"sha1\";
+					};
+			};
+"
+fi
+
+# add DT overlay blobs
+FDTOVERLAY_NODE=""
+OVCONFIGS=""
+[ "$DTOVERLAY" ] && for overlay in $DTOVERLAY ; do
+	overlay_blob=${overlay##*:}
+	ovname=${overlay%%:*}
+	ovnode="fdt-$ovname"
+	ovsize=$(wc -c "$overlay_blob" | awk '{print $1}')
+	echo "$ovname ($overlay_blob) : $ovsize" >&2
+	FDTOVERLAY_NODE="$FDTOVERLAY_NODE
+
+		$ovnode {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree overlay $ovname\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${overlay_blob}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	OVCONFIGS="$OVCONFIGS
+
+		$ovname {
+			description = \"OpenWrt ${DEVICE} overlay $ovname\";
+			fdt = \"$ovnode\";
+			${COMPATIBLE_PROP}
+		};
+	"
+done
+
+# Create a default, fully populated DTS file
+DATA="/dts-v1/;
+
+/ {
+	description = \"${ARCH_UPPER} OpenWrt FIT (Flattened Image Tree)\";
+	#address-cells = <1>;
+
+	images {
+		kernel${REFERENCE_CHAR}1 {
+			description = \"${ARCH_UPPER} OpenWrt Linux-${VERSION}\";
+			data = /incbin/(\"${KERNEL}\");
+			type = \"kernel\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			compression = \"${COMPRESS}\";
+			load = <${LOAD_ADDR}>;
+			entry = <${ENTRY_ADDR}>;
+			hash${REFERENCE_CHAR}1 {
+				algo = \"crc32\";
+			};
+			hash${REFERENCE_CHAR}2 {
+				algo = \"$HASH\";
+			};
+		};
+${INITRD_NODE}
+${FDT_NODE}
+${FDTOVERLAY_NODE}
+	};
+${ROOTFS_NODE}
+	configurations {
+		default = \"${CONFIG}\";
+		${CONFIG} {
+			description = \"OpenWrt ${DEVICE}\";
+			kernel = \"kernel${REFERENCE_CHAR}1\";
+			${FDT_PROP}
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
+		};
+		${OVCONFIGS}
+	};
+};"
+
+# Write .its file to disk
+echo "$DATA" > "${OUTPUT}"
diff --git a/target/linux/generic/pending-5.4/631-supprt_tps23861_poe_pse.patch b/target/linux/generic/pending-5.4/631-supprt_tps23861_poe_pse.patch
new file mode 100644
index 0000000000..9ba87cc61e
--- /dev/null
+++ b/target/linux/generic/pending-5.4/631-supprt_tps23861_poe_pse.patch
@@ -0,0 +1,940 @@
+diff -uarN a/Documentation/devicetree/bindings/hwmon/tps23861.txt b/Documentation/devicetree/bindings/hwmon/tps23861.txt
+--- a/Documentation/devicetree/bindings/hwmon/tps23861.txt	1970-01-01 08:00:00.000000000 +0800
++++ b/Documentation/devicetree/bindings/hwmon/tps23861.txt	2023-07-19 18:45:57.362856118 +0800
+@@ -0,0 +1,21 @@
++* TI TPS23861 PoE PSE
++
++Required node properties:
++- compatible: "ti,tps23861"
++- reg: I2C bus address of the device
++
++Optional properties:
++- shunt-resistor-micro-ohms: The value of curent sense resistor in microohms
++
++Example tps23861 node:
++
++i2c {
++	#address-cells = <1>;
++	#size-cells = <0>;
++
++	tps23861@20 {
++		compatible = "ti,tps23861";
++		reg = <0x20>;
++		shunt-resistor-micro-ohms = <255000>;
++	};
++};
+diff -uarN a/Documentation/hwmon/index.rst b/Documentation/hwmon/index.rst
+--- a/Documentation/hwmon/index.rst	2023-07-20 09:55:00.683302558 +0800
++++ b/Documentation/hwmon/index.rst	2023-07-20 09:55:57.884316677 +0800
+@@ -154,6 +154,7 @@
+    tmp108
+    tmp401
+    tmp421
++   tps23861
+    tps40422
+    twl4030-madc-hwmon
+    ucd9000
+diff -uarN a/Documentation/hwmon/tps23861.rst b/Documentation/hwmon/tps23861.rst
+--- a/Documentation/hwmon/tps23861.rst	1970-01-01 08:00:00.000000000 +0800
++++ b/Documentation/hwmon/tps23861.rst	2023-07-20 09:59:44.715528340 +0800
+@@ -0,0 +1,41 @@
++.. SPDX-License-Identifier: GPL-2.0-only
++
++Kernel driver tps23861
++======================
++
++Supported chips:
++  * Texas Instruments TPS23861
++
++    Prefix: 'tps23861'
++
++    Datasheet: https://www.ti.com/lit/gpn/tps23861
++
++Author: Robert Marko <robert.marko@sartura.hr>
++
++Description
++-----------
++
++This driver supports hardware monitoring for Texas Instruments TPS23861 PoE PSE.
++
++TPS23861 is a quad port IEEE802.3at PSE controller with optional I2C control
++and monitoring capabilities.
++
++TPS23861 offers three modes of operation: Auto, Semi-Auto and Manual.
++
++This driver only supports the Auto mode of operation providing monitoring
++as well as enabling/disabling the four ports.
++
++Sysfs entries
++-------------
++
++======================= =====================================================================
++in[0-3]_input		Voltage on ports [1-4]
++in[0-3]_label		"Port[1-4]"
++in4_input		IC input voltage
++in4_label		"Input"
++temp1_input		IC die temperature
++temp1_label		"Die"
++curr[1-4]_input		Current on ports [1-4]
++in[1-4]_label		"Port[1-4]"
++in[0-3]_enable		Enable/disable ports [1-4]
++======================= =====================================================================
+diff -uarN a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
+--- a/drivers/hwmon/Kconfig	2023-07-19 18:47:22.106455779 +0800
++++ b/drivers/hwmon/Kconfig	2023-07-20 09:34:46.080922856 +0800
+@@ -982,6 +982,17 @@
+ 	  This driver can also be built as a module. If so, the module
+ 	  will be called tc654.
+ 
++config SENSORS_TPS23861
++	tristate "Texas Instruments TPS23861 PoE PSE"
++	depends on I2C
++	select REGMAP_I2C
++	help
++	  If you say yes here you get support for Texas Instruments
++	  TPS23861 802.3at PoE PSE chips.
++
++	  This driver can also be built as a module. If so, the module
++	  will be called tps23861.
++
+ config SENSORS_MENF21BMC_HWMON
+ 	tristate "MEN 14F021P00 BMC Hardware Monitoring"
+ 	depends on MFD_MENF21BMC
+diff -uarN a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
+--- a/drivers/hwmon/Makefile	2023-07-20 09:32:18.741206669 +0800
++++ b/drivers/hwmon/Makefile	2023-07-20 09:33:19.681089576 +0800
+@@ -130,6 +130,7 @@
+ obj-$(CONFIG_SENSORS_MC13783_ADC)+= mc13783-adc.o
+ obj-$(CONFIG_SENSORS_MCP3021)	+= mcp3021.o
+ obj-$(CONFIG_SENSORS_TC654)	+= tc654.o
++obj-$(CONFIG_SENSORS_TPS23861) += tps23861.o
+ obj-$(CONFIG_SENSORS_MLXREG_FAN) += mlxreg-fan.o
+ obj-$(CONFIG_SENSORS_MENF21BMC_HWMON) += menf21bmc_hwmon.o
+ obj-$(CONFIG_SENSORS_NCT6683)	+= nct6683.o
+diff -uarN a/drivers/hwmon/tps23861.c b/drivers/hwmon/tps23861.c
+--- a/drivers/hwmon/tps23861.c	1970-01-01 08:00:00.000000000 +0800
++++ b/drivers/hwmon/tps23861.c	2023-09-19 17:58:07.762366557 +0800
+@@ -0,0 +1,804 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Copyright (c) 2020 Sartura Ltd.
++ *
++ * Driver for the TI TPS23861 PoE PSE.
++ *
++ * Author: Robert Marko <robert.marko@sartura.hr>
++ */
++
++#include <linux/bitfield.h>
++#include <linux/debugfs.h>
++#include <linux/delay.h>
++#include <linux/hwmon-sysfs.h>
++#include <linux/hwmon.h>
++#include <linux/i2c.h>
++#include <linux/module.h>
++#include <linux/of_device.h>
++#include <linux/regmap.h>
++
++#define TEMPERATURE			0x2c
++#define INPUT_VOLTAGE_LSB		0x2e
++#define INPUT_VOLTAGE_MSB		0x2f
++#define PORT_1_CURRENT_LSB		0x30
++#define PORT_1_CURRENT_MSB		0x31
++#define PORT_1_VOLTAGE_LSB		0x32
++#define PORT_1_VOLTAGE_MSB		0x33
++#define PORT_2_CURRENT_LSB		0x34
++#define PORT_2_CURRENT_MSB		0x35
++#define PORT_2_VOLTAGE_LSB		0x36
++#define PORT_2_VOLTAGE_MSB		0x37
++#define PORT_3_CURRENT_LSB		0x38
++#define PORT_3_CURRENT_MSB		0x39
++#define PORT_3_VOLTAGE_LSB		0x3a
++#define PORT_3_VOLTAGE_MSB		0x3b
++#define PORT_4_CURRENT_LSB		0x3c
++#define PORT_4_CURRENT_MSB		0x3d
++#define PORT_4_VOLTAGE_LSB		0x3e
++#define PORT_4_VOLTAGE_MSB		0x3f
++#define PORT_N_CURRENT_LSB_OFFSET	0x04
++#define PORT_N_VOLTAGE_LSB_OFFSET	0x04
++#define VOLTAGE_CURRENT_MASK		GENMASK(13, 0)
++#define PORT_1_RESISTANCE_LSB		0x60
++#define PORT_1_RESISTANCE_MSB		0x61
++#define PORT_2_RESISTANCE_LSB		0x62
++#define PORT_2_RESISTANCE_MSB		0x63
++#define PORT_3_RESISTANCE_LSB		0x64
++#define PORT_3_RESISTANCE_MSB		0x65
++#define PORT_4_RESISTANCE_LSB		0x66
++#define PORT_4_RESISTANCE_MSB		0x67
++#define PORT_N_RESISTANCE_LSB_OFFSET	0x02
++#define PORT_RESISTANCE_MASK		GENMASK(13, 0)
++#define PORT_RESISTANCE_RSN_MASK	GENMASK(15, 14)
++#define PORT_RESISTANCE_RSN_OTHER	0
++#define PORT_RESISTANCE_RSN_LOW		1
++#define PORT_RESISTANCE_RSN_OPEN	2
++#define PORT_RESISTANCE_RSN_SHORT	3
++#define PORT_1_STATUS			0x0c
++#define PORT_2_STATUS			0x0d
++#define PORT_3_STATUS			0x0e
++#define PORT_4_STATUS			0x0f
++#define PORT_STATUS_CLASS_MASK		GENMASK(7, 4)
++#define PORT_STATUS_DETECT_MASK		GENMASK(3, 0)
++#define PORT_CLASS_UNKNOWN		0
++#define PORT_CLASS_1			1
++#define PORT_CLASS_2			2
++#define PORT_CLASS_3			3
++#define PORT_CLASS_4			4
++#define PORT_CLASS_RESERVED		5
++#define PORT_CLASS_0			6
++#define PORT_CLASS_OVERCURRENT		7
++#define PORT_CLASS_MISMATCH		8
++#define PORT_DETECT_UNKNOWN		0
++#define PORT_DETECT_SHORT		1
++#define PORT_DETECT_RESERVED		2
++#define PORT_DETECT_RESISTANCE_LOW	3
++#define PORT_DETECT_RESISTANCE_OK	4
++#define PORT_DETECT_RESISTANCE_HIGH	5
++#define PORT_DETECT_OPEN_CIRCUIT	6
++#define PORT_DETECT_RESERVED_2		7
++#define PORT_DETECT_MOSFET_FAULT	8
++#define PORT_DETECT_LEGACY		9
++/* Measurment beyond clamp voltage */
++#define PORT_DETECT_CAPACITANCE_INVALID_BEYOND	10
++/* Insufficient voltage delta */
++#define PORT_DETECT_CAPACITANCE_INVALID_DELTA	11
++#define PORT_DETECT_CAPACITANCE_OUT_OF_RANGE	12
++#define POE_PLUS			0x40
++#define POE_PLUS_MASK(_port)		GENMASK(_port + 4, _port + 4)
++#define POE_FW_REVISION			0x41  /* Firmware rvision */
++#define POE_DEVICE_ID			0x43  /* Device ID */
++
++#define POE_POWER_STATUS		0x10  /* Power status */
++#define POE_I2C_ADDRESS			0x11  /* I2C slave address */
++#define OPERATING_MODE			0x12
++#define OPERATING_MODE_OFF		0
++#define OPERATING_MODE_MANUAL		1
++#define OPERATING_MODE_SEMI		2
++#define OPERATING_MODE_AUTO		3
++#define OPERATING_MODE_PORT_1_MASK	GENMASK(1, 0)
++#define OPERATING_MODE_PORT_2_MASK	GENMASK(3, 2)
++#define OPERATING_MODE_PORT_3_MASK	GENMASK(5, 4)
++#define OPERATING_MODE_PORT_4_MASK	GENMASK(7, 6)
++#define OPERATING_MODE_PORT(_mode, _port)	(_mode << (_port * 2))
++
++#define DISCONNECT_ENABLE		0x13
++#define DISCONNECT_ENABLE_MASK(_port)	GENMASK(_port, _port)
++#define DISCONNECT_MASK(_port) \
++	(GENMASK(_port, _port) | GENMASK(_port + 4, _port + 4))
++
++#define DETECT_CLASS_ENABLE		0x14
++#define DETECT_CLASS_RESTART		0x18
++#define POWER_ENABLE			0x19
++#define POWER_ENABLE_ON_MASK(_port)	GENMASK(_port, _port)
++#define POWER_ENABLE_OFF_MASK(_port)	GENMASK(_port + 4, _port + 4)
++#define TPS23861_NUM_PORTS		4
++
++#define TPS23861_GENERAL_MASK_1		0x17
++#define TPS23861_CURRENT_SHUNT_MASK	BIT(0)
++
++#define TEMPERATURE_LSB			652 /* 0.652 degrees Celsius */
++#define VOLTAGE_LSB			3662 /* 3.662 mV */
++#define SHUNT_RESISTOR_DEFAULT		255000 /* 255 mOhm */
++#define CURRENT_LSB_250			62260 /* 62.260 uA */
++#define CURRENT_LSB_255			61039 /* 61.039 uA */
++#define RESISTANCE_LSB			110966 /* 11.0966 Ohm*/
++#define RESISTANCE_LSB_LOW		157216 /* 15.7216 Ohm*/
++
++struct tps23861_data {
++	struct regmap *regmap;
++	u32 shunt_resistor;
++	struct i2c_client *client;
++	struct dentry *debugfs_dir;
++};
++
++static struct regmap_config tps23861_regmap_config = {
++	.reg_bits = 8,
++	.val_bits = 8,
++	.max_register = 0x6f,
++};
++
++static int tps23861_read_temp(struct tps23861_data *data, long *val)
++{
++	unsigned int regval;
++	int err;
++
++	err = regmap_read(data->regmap, TEMPERATURE, &regval);
++	if (err < 0)
++		return err;
++
++	*val = (regval * TEMPERATURE_LSB) - 20000;
++
++	return 0;
++}
++
++static int tps23861_read_voltage(struct tps23861_data *data, int channel,
++				 long *val)
++{
++	unsigned int regval;
++	int err;
++
++	if (channel < TPS23861_NUM_PORTS) {
++		err = regmap_bulk_read(data->regmap,
++				       PORT_1_VOLTAGE_LSB + channel * PORT_N_VOLTAGE_LSB_OFFSET,
++				       &regval, 2);
++	} else {
++		err = regmap_bulk_read(data->regmap,
++				       INPUT_VOLTAGE_LSB,
++				       &regval, 2);
++	}
++	if (err < 0)
++		return err;
++
++	*val = (FIELD_GET(VOLTAGE_CURRENT_MASK, regval) * VOLTAGE_LSB) / 1000;
++
++	return 0;
++}
++
++static int tps23861_read_current(struct tps23861_data *data, int channel,
++				 long *val)
++{
++	unsigned int current_lsb;
++	unsigned int regval;
++	int err;
++
++	if (data->shunt_resistor == SHUNT_RESISTOR_DEFAULT)
++		current_lsb = CURRENT_LSB_255;
++	else
++		current_lsb = CURRENT_LSB_250;
++
++	err = regmap_bulk_read(data->regmap,
++			       PORT_1_CURRENT_LSB + channel * PORT_N_CURRENT_LSB_OFFSET,
++			       &regval, 2);
++	if (err < 0)
++		return err;
++
++	*val = (FIELD_GET(VOLTAGE_CURRENT_MASK, regval) * current_lsb) / 1000000;
++
++	return 0;
++}
++
++static int tps23861_port_disable(struct tps23861_data *data, int channel)
++{
++	unsigned int regval = 0;
++	int err;
++
++	regval |= BIT(channel + 4);
++	err = regmap_write(data->regmap, POWER_ENABLE, regval);
++
++	return err;
++}
++
++static int tps23861_port_power_enable(struct tps23861_data *data, int channel)
++{
++	unsigned int   regval = 0 ;
++	int err ;
++
++	regval |= BIT(channel + 0) ;
++	err = regmap_write(data->regmap, POWER_ENABLE, regval) ;
++
++	return(err) ;
++}    /* tps23861_port_power_enable */
++
++static int tps23861_port_enable(struct tps23861_data *data, int channel)
++{
++	unsigned int regval = 0;
++	int err;
++
++	regval |= BIT(channel);
++	regval |= BIT(channel + 4);
++	err = regmap_write(data->regmap, DETECT_CLASS_RESTART, regval);
++
++	return err;
++}
++
++static umode_t tps23861_is_visible(const void *data, enum hwmon_sensor_types type,
++				   u32 attr, int channel)
++{
++	switch (type) {
++	case hwmon_temp:
++		switch (attr) {
++		case hwmon_temp_input:
++		case hwmon_temp_label:
++			return 0444;
++		default:
++			return 0;
++		}
++	case hwmon_in:
++		switch (attr) {
++		case hwmon_in_input:
++		case hwmon_in_label:
++			return 0444;
++		case hwmon_in_enable:
++			return 0200;
++		default:
++			return 0;
++		}
++	case hwmon_curr:
++		switch (attr) {
++		case hwmon_curr_input:
++		case hwmon_curr_label:
++			return 0444;
++		default:
++			return 0;
++		}
++	default:
++		return 0;
++	}
++}
++
++static int tps23861_write(struct device *dev, enum hwmon_sensor_types type,
++			  u32 attr, int channel, long val)
++{
++	struct tps23861_data *data = dev_get_drvdata(dev);
++	int err;
++
++	switch (type) {
++	case hwmon_in:
++		switch (attr) {
++		case hwmon_in_enable:
++			if (val == 0)
++				err = tps23861_port_disable(data, channel);
++			else if (val == 1)
++				err = tps23861_port_enable(data, channel);
++			else if (val == 2)   /* Power enable */
++				err = tps23861_port_power_enable(data, channel) ;
++			else
++				err = -EINVAL;
++			break;
++		default:
++			return -EOPNOTSUPP;
++		}
++		break;
++	default:
++		return -EOPNOTSUPP;
++	}
++
++	return err;
++}
++
++static int tps23861_read(struct device *dev, enum hwmon_sensor_types type,
++			 u32 attr, int channel, long *val)
++{
++	struct tps23861_data *data = dev_get_drvdata(dev);
++	int err;
++
++	switch (type) {
++	case hwmon_temp:
++		switch (attr) {
++		case hwmon_temp_input:
++			err = tps23861_read_temp(data, val);
++			break;
++		default:
++			return -EOPNOTSUPP;
++		}
++		break;
++	case hwmon_in:
++		switch (attr) {
++		case hwmon_in_input:
++			err = tps23861_read_voltage(data, channel, val);
++			break;
++		default:
++			return -EOPNOTSUPP;
++		}
++		break;
++	case hwmon_curr:
++		switch (attr) {
++		case hwmon_curr_input:
++			err = tps23861_read_current(data, channel, val);
++			break;
++		default:
++			return -EOPNOTSUPP;
++		}
++		break;
++	default:
++		return -EOPNOTSUPP;
++	}
++
++	return err;
++}
++
++static const char * const tps23861_port_label[] = {
++	"Port1",
++	"Port2",
++	"Port3",
++	"Port4",
++	"Input",
++};
++
++static int tps23861_read_string(struct device *dev,
++				enum hwmon_sensor_types type,
++				u32 attr, int channel, const char **str)
++{
++	switch (type) {
++	case hwmon_in:
++	case hwmon_curr:
++		*str = tps23861_port_label[channel];
++		break;
++	case hwmon_temp:
++		*str = "Die";
++		break;
++	default:
++		return -EOPNOTSUPP;
++	}
++
++	return 0;
++}
++
++static const struct hwmon_channel_info *tps23861_info[] = {
++	HWMON_CHANNEL_INFO(chip,
++			   HWMON_C_REGISTER_TZ),
++	HWMON_CHANNEL_INFO(temp,
++			   HWMON_T_INPUT | HWMON_T_LABEL),
++	HWMON_CHANNEL_INFO(in,
++			   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_ENABLE | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL),
++	HWMON_CHANNEL_INFO(curr,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL),
++	NULL
++};
++
++static const struct hwmon_ops tps23861_hwmon_ops = {
++	.is_visible = tps23861_is_visible,
++	.write = tps23861_write,
++	.read = tps23861_read,
++	.read_string = tps23861_read_string,
++};
++
++static const struct hwmon_chip_info tps23861_chip_info = {
++	.ops = &tps23861_hwmon_ops,
++	.info = tps23861_info,
++};
++
++static char *tps23861_port_operating_mode(struct tps23861_data *data, int port)
++{
++	unsigned int regval;
++	int mode;
++
++	regmap_read(data->regmap, OPERATING_MODE, &regval);
++
++	switch (port) {
++	case 1:
++		mode = FIELD_GET(OPERATING_MODE_PORT_1_MASK, regval);
++		break;
++	case 2:
++		mode = FIELD_GET(OPERATING_MODE_PORT_2_MASK, regval);
++		break;
++	case 3:
++		mode = FIELD_GET(OPERATING_MODE_PORT_3_MASK, regval);
++		break;
++	case 4:
++		mode = FIELD_GET(OPERATING_MODE_PORT_4_MASK, regval);
++		break;
++	default:
++		mode = -EINVAL;
++	}
++
++	switch (mode) {
++	case OPERATING_MODE_OFF:
++		return "Off";
++	case OPERATING_MODE_MANUAL:
++		return "Manual";
++	case OPERATING_MODE_SEMI:
++		return "Semi-Auto";
++	case OPERATING_MODE_AUTO:
++		return "Auto";
++	default:
++		return "Invalid";
++	}
++}
++
++static char *tps23861_port_detect_status(struct tps23861_data *data, int port)
++{
++	unsigned int regval;
++
++	regmap_read(data->regmap,
++		    PORT_1_STATUS + (port - 1),
++		    &regval);
++
++	switch (FIELD_GET(PORT_STATUS_DETECT_MASK, regval)) {
++	case PORT_DETECT_UNKNOWN:
++		return "Unknown device(POR value)";
++	case PORT_DETECT_SHORT:
++		return "Short circuit";
++	case PORT_DETECT_RESISTANCE_LOW:
++		return "Resistance too low";
++	case PORT_DETECT_RESISTANCE_OK:
++		return "Resistance valid";
++	case PORT_DETECT_RESISTANCE_HIGH:
++		return "Resistance too high";
++	case PORT_DETECT_OPEN_CIRCUIT:
++		return "Open circuit";
++	case PORT_DETECT_MOSFET_FAULT:
++		return "MOSFET fault";
++	case PORT_DETECT_LEGACY:
++		return "Legacy device";
++	case PORT_DETECT_CAPACITANCE_INVALID_BEYOND:
++		return "Invalid capacitance, beyond clamp voltage";
++	case PORT_DETECT_CAPACITANCE_INVALID_DELTA:
++		return "Invalid capacitance, insufficient voltage delta";
++	case PORT_DETECT_CAPACITANCE_OUT_OF_RANGE:
++		return "Valid capacitance, outside of legacy range";
++	case PORT_DETECT_RESERVED:
++	case PORT_DETECT_RESERVED_2:
++	default:
++		return "Invalid";
++	}
++}
++
++static char *tps23861_port_class_status(struct tps23861_data *data, int port)
++{
++	unsigned int regval;
++
++	regmap_read(data->regmap,
++		    PORT_1_STATUS + (port - 1),
++		    &regval);
++
++	switch (FIELD_GET(PORT_STATUS_CLASS_MASK, regval)) {
++	case PORT_CLASS_UNKNOWN:
++		return "Unknown";
++	case PORT_CLASS_RESERVED:
++	case PORT_CLASS_0:
++		return "0";
++	case PORT_CLASS_1:
++		return "1";
++	case PORT_CLASS_2:
++		return "2";
++	case PORT_CLASS_3:
++		return "3";
++	case PORT_CLASS_4:
++		return "4";
++	case PORT_CLASS_OVERCURRENT:
++		return "Overcurrent";
++	case PORT_CLASS_MISMATCH:
++		return "Mismatch";
++	default:
++		return "Invalid";
++	}
++}
++
++static char *tps23861_port_poe_plus_status(struct tps23861_data *data, int port)
++{
++	unsigned int regval;
++
++	regmap_read(data->regmap, POE_PLUS, &regval);
++
++	if (BIT(port + 3) & regval)
++		return "Yes";
++	else
++		return "No";
++}
++
++static int tps23861_port_resistance(struct tps23861_data *data, int port)
++{
++	unsigned int raw_val;
++	__le16 regval;
++
++	regmap_bulk_read(data->regmap,
++			 PORT_1_RESISTANCE_LSB + PORT_N_RESISTANCE_LSB_OFFSET * (port - 1),
++			 &regval,
++			 2);
++
++	raw_val = le16_to_cpu(regval);
++	switch (FIELD_GET(PORT_RESISTANCE_RSN_MASK, raw_val)) {
++	case PORT_RESISTANCE_RSN_OTHER:
++		return (FIELD_GET(PORT_RESISTANCE_MASK, raw_val) * RESISTANCE_LSB) / 10000;
++	case PORT_RESISTANCE_RSN_LOW:
++		return (FIELD_GET(PORT_RESISTANCE_MASK, raw_val) * RESISTANCE_LSB_LOW) / 10000;
++	case PORT_RESISTANCE_RSN_SHORT:
++	case PORT_RESISTANCE_RSN_OPEN:
++	default:
++		return 0;
++	}
++}
++
++
++static char *tps23861_power_status(struct tps23861_data *data, int port)
++{
++	unsigned int   regVal ;
++
++	regmap_read(data->regmap, POE_POWER_STATUS, &regVal) ;
++	if (regVal & (1 << (port - 1)))
++	{   /* Port is on */
++		if (regVal & (1 << (port + 3)))   /* Power is good */
++			return("Port is on and power is good") ;
++		else      /* Power is not good */
++			return("Port is on but power is not good") ;
++	}/* End of if port is on */
++	else
++	{   /* Port is off */
++		if (regVal & (1 << (port + 3)))   /* Power is good */
++			return("Port is off but power is good") ;
++		else      /* Power is not good */
++			return("Port is off and power is not good") ;
++	}/* End of if port is off */
++}    /* tps23861_power_status */
++
++
++static int  tps23861_input_voltage(struct tps23861_data *data, int port)
++{
++	long   val = 0 ;
++	int    err = 0 ;
++
++	/* Fix to channel 0 for EWW631-C1 device */
++	if ((err = tps23861_read_voltage(data, (port - 1), &val)) < 0)
++		return(0) ;
++	else
++		return((int)val) ;
++}    /* tps23861_input_voltage */
++
++
++static int  tps23861_input_current(struct tps23861_data *data, int port)
++{
++	long   val = 0 ;
++	int    err = 0 ;
++
++	/* Fix to channel 0 for EWW631-C1 device */
++	if ((err = tps23861_read_current(data, (port - 1), &val)) < 0)
++		return(0) ;
++	else
++		return((int)val) ;
++}    /* tps23861_input_current */
++
++
++static int  *tps23861_misc_status(struct tps23861_data *data, char *dataBuf)
++{
++	unsigned int	rVal ;
++	long		rTmp ;
++
++	regmap_read(data->regmap, POE_I2C_ADDRESS, &rVal) ;
++	sprintf(dataBuf, "AUTO=%d, I2C slave address=0x%X, ",
++		((((unsigned char)rVal) >> 7) & 0x01),
++		((unsigned char)rVal) & 0x7F) ;
++	regmap_read(data->regmap, DISCONNECT_ENABLE, &rVal) ;
++	sprintf(dataBuf + strlen(dataBuf), "DISCONNECT_ENABLE(0x%X)=0x%X, ",
++		DISCONNECT_ENABLE, (int)rVal) ;
++	regmap_read(data->regmap, DETECT_CLASS_ENABLE, &rVal) ;
++	sprintf(dataBuf + strlen(dataBuf), "DETECT_CLASS_ENABLE(0x%X)=0x%X, ",
++		DETECT_CLASS_ENABLE, (int)rVal) ;
++	strcpy(dataBuf + strlen(dataBuf), "temperature: ") ;
++	if (tps23861_read_temp(data, &rTmp) < 0)
++		strcpy(dataBuf + strlen(dataBuf), "unknown") ;
++	else
++		sprintf(dataBuf + strlen(dataBuf), "%d", (int)rTmp) ;
++
++	return(0) ;
++}    /* tps23861_misc_status */
++
++
++static int tps23861_port_status_show(struct seq_file *s, void *data)
++{
++	struct tps23861_data *priv = s->private;
++	char   dataBuf[128] = "" ;
++	int i;
++
++/*	for (i = 1; i < TPS23861_NUM_PORTS + 1; i++) {*/
++	for (i = 1 ; i < 2 ; i++) {
++		seq_printf(s, "Port: \t\t%d\n", i);
++		seq_printf(s, "Operating mode: %s\n", tps23861_port_operating_mode(priv, i));
++		seq_printf(s, "Detected: \t%s\n", tps23861_port_detect_status(priv, i));
++		seq_printf(s, "Class: \t\t%s\n", tps23861_port_class_status(priv, i));
++		seq_printf(s, "PoE Plus: \t%s\n", tps23861_port_poe_plus_status(priv, i));
++		seq_printf(s, "Resistance: \t%d\n", tps23861_port_resistance(priv, i));
++		seq_printf(s, "Power Status: \t%s\n", tps23861_power_status(priv, i)) ;
++		seq_printf(s, "Input Voltage: \t%dmV\n", tps23861_input_voltage(priv, i)) ;
++		seq_printf(s, "Input Current: \t%dmA\n", tps23861_input_current(priv, i)) ;
++		tps23861_misc_status(priv, dataBuf) ;
++		seq_printf(s, "Misc Status: %s\n", dataBuf) ;
++		seq_putc(s, '\n');
++	}
++
++	return 0;
++}
++
++DEFINE_SHOW_ATTRIBUTE(tps23861_port_status);
++
++static void tps23861_init_debugfs(struct tps23861_data *data)
++{
++	data->debugfs_dir = debugfs_create_dir(data->client->name, NULL);
++
++	debugfs_create_file("port_status",
++			    0400,
++			    data->debugfs_dir,
++			    data,
++			    &tps23861_port_status_fops);
++}
++
++static int tps23861_probe(struct i2c_client *client)
++{
++	struct device *dev = &client->dev;
++	struct tps23861_data *data;
++	struct device *hwmon_dev;
++	struct device_node *child ;
++	u32 shunt_resistor;
++	u32    reg ;
++	u32    temp ;
++	const char *mode ;
++	unsigned int   poe_plusval ;
++	unsigned int   mode_val ;
++	unsigned int   power_val ;
++	unsigned int   enable_val ;
++	unsigned int   disconnect_enable_val ;
++
++	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
++	if (!data)
++		return -ENOMEM;
++
++	data->client = client;
++	i2c_set_clientdata(client, data);
++
++	data->regmap = devm_regmap_init_i2c(client, &tps23861_regmap_config);
++	if (IS_ERR(data->regmap)) {
++		dev_err(dev, "failed to allocate register map\n");
++		return PTR_ERR(data->regmap);
++	}
++
++	if (!of_property_read_u32(dev->of_node, "shunt-resistor-micro-ohms", &shunt_resistor))
++		data->shunt_resistor = shunt_resistor;
++	else
++		data->shunt_resistor = SHUNT_RESISTOR_DEFAULT;
++
++	if (data->shunt_resistor == SHUNT_RESISTOR_DEFAULT)
++		regmap_update_bits(data->regmap,
++				  TPS23861_GENERAL_MASK_1,
++				  TPS23861_CURRENT_SHUNT_MASK,
++				  TPS23861_CURRENT_SHUNT_MASK);
++	else
++		regmap_update_bits(data->regmap,
++				TPS23861_GENERAL_MASK_1,
++				TPS23861_CURRENT_SHUNT_MASK, 0);
++
++	/* Initializing ports */
++	regmap_read(data->regmap, POE_PLUS, &poe_plusval) ;
++	regmap_read(data->regmap, POWER_ENABLE, &power_val) ;
++	regmap_read(data->regmap, OPERATING_MODE, &mode_val) ;
++	regmap_read(data->regmap, DETECT_CLASS_ENABLE, &enable_val) ;
++	regmap_read(data->regmap, DISCONNECT_ENABLE, &disconnect_enable_val) ;
++
++	for_each_child_of_node(dev->of_node, child) {
++		if (of_property_read_u32(child, "reg", &reg))
++			continue;
++
++		if (reg > (TPS23861_NUM_PORTS - 1) || reg < 0)
++			continue;
++
++		if (!of_property_read_string(child, "mode", &mode))
++		{   /* Set operating mode */
++			if (!strncmp(mode, "manual", 6))
++			{   /* Manual mode */
++				mode_val &= ~OPERATING_MODE_PORT(OPERATING_MODE_AUTO, reg) ;
++				mode_val |= OPERATING_MODE_PORT(OPERATING_MODE_MANUAL, reg) ;
++			}/* End of if Manual mode */
++			else if (!strncmp(mode, "semiauto", 8))
++			{   /* Semi-Auto mode */
++				mode_val &= ~OPERATING_MODE_PORT(OPERATING_MODE_AUTO, reg) ;
++				mode_val |= OPERATING_MODE_PORT(OPERATING_MODE_SEMI, reg) ;
++			}/* End of if Semi-Auto mode */
++			else if (!strncmp(mode, "auto", 4))      /* Auto mode */
++				mode_val |= OPERATING_MODE_PORT(OPERATING_MODE_AUTO, reg) ;
++			else     /* Off mode */
++				mode_val &= ~OPERATING_MODE_PORT(OPERATING_MODE_AUTO, reg) ;
++		}/* End of if set operating mode */
++	
++		if (!of_property_read_u32(child, "enable", &temp))
++		{   /* Detect/Class/Disconnect control */
++			if (temp)
++			{   /* Enable */
++				enable_val |= DISCONNECT_MASK(reg) ;
++				disconnect_enable_val |= DISCONNECT_ENABLE_MASK(reg) ;
++			}/* End of if enable */
++			else
++			{   /* Disable */
++				enable_val &= ~DISCONNECT_MASK(reg) ;
++				disconnect_enable_val &= ~DISCONNECT_ENABLE_MASK(reg) ;
++			}/* End of if disable */
++		}/* End of if Detect/Class/Disconnect control */
++
++		if (!of_property_read_u32(child, "power", &temp))
++		{   /* Power Enable control */ 
++			if (temp)    /* Enable */
++				power_val |= POWER_ENABLE_ON_MASK(reg) ;
++			else         /* Disable */
++				power_val |= POWER_ENABLE_OFF_MASK(reg) ;
++		}/* End of if power enable control */
++
++		if (!of_property_read_u32(child, "poe_plus", &temp))
++		{   /* PoE Plus control */ 
++			if (temp)    /* Enable PoE Plus function */
++				poe_plusval |= POE_PLUS_MASK(reg) ;
++			else         /* Disable PoE Plus function */
++				poe_plusval &= ~POE_PLUS_MASK(reg) ;
++		}/* End of if PoE Plus control */
++
++		regmap_write(data->regmap, POE_PLUS, poe_plusval) ;
++		regmap_write(data->regmap, POWER_ENABLE, power_val) ;
++		regmap_write(data->regmap, OPERATING_MODE, mode_val) ;
++		regmap_write(data->regmap, DETECT_CLASS_ENABLE, enable_val) ;
++		regmap_write(data->regmap, DISCONNECT_ENABLE, disconnect_enable_val) ;
++	}/* End of for */
++
++	hwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,
++							 data, &tps23861_chip_info,
++							 NULL);
++	if (IS_ERR(hwmon_dev))
++		return PTR_ERR(hwmon_dev);
++
++	tps23861_init_debugfs(data);
++
++	return 0;
++}
++
++static int tps23861_remove(struct i2c_client *client)
++{
++	struct tps23861_data *data = i2c_get_clientdata(client);
++
++	debugfs_remove_recursive(data->debugfs_dir);
++
++	return 0;
++}
++
++static const struct of_device_id __maybe_unused tps23861_of_match[] = {
++	{ .compatible = "ti,tps23861", },
++	{ },
++};
++MODULE_DEVICE_TABLE(of, tps23861_of_match);
++
++static struct i2c_driver tps23861_driver = {
++	.probe_new		= tps23861_probe,
++	.remove			= tps23861_remove,
++	.driver = {
++		.name		= "tps23861",
++		.of_match_table	= of_match_ptr(tps23861_of_match),
++	},
++};
++module_i2c_driver(tps23861_driver);
++
++MODULE_LICENSE("GPL");
++MODULE_AUTHOR("Robert Marko <robert.marko@sartura.hr>");
++MODULE_DESCRIPTION("TI TPS23861 PoE PSE");
+diff -uarN a/MAINTAINERS b/MAINTAINERS
+--- a/MAINTAINERS	2023-07-20 09:37:00.732661649 +0800
++++ b/MAINTAINERS	2023-07-20 09:57:49.538041937 +0800
+@@ -16081,6 +16081,15 @@
+ F:	drivers/iio/dac/ti-dac7612.c
+ F:	Documentation/devicetree/bindings/iio/dac/ti,dac7612.txt
+ 
++TEXAS INSTRUMENTS TPS23861 PoE PSE DRIVER
++M:	Robert Marko <robert.ma...@sartura.hr>
++M:	Luka Perkov <luka.per...@sartura.hr>
++L:	linux-hwmon@vger.kernel.org
++S:	Maintained
++F:	Documentation/devicetree/bindings/hwmon/tps23861.txt
++F:	Documentation/hwmon/tps23861.rst
++F:	drivers/hwmon/tps23861.c
++
+ THANKO'S RAREMONO AM/FM/SW RADIO RECEIVER USB DRIVER
+ M:	Hans Verkuil <hverkuil@xs4all.nl>
+ L:	linux-media@vger.kernel.org
diff --git a/tools/Makefile b/tools/Makefile
index 40c3ec1ab0..6c7abaaf9c 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -68,6 +68,7 @@ tools-y += sstrip
 tools-y += zip
 tools-y += zlib
 tools-y += zstd
+tools-y += crc32sum
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS),y) += liblzo
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_B43_TOOLS),y) += b43-tools
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_BZIP2_TOOLS),y) += bzip2
diff --git a/tools/crc32sum/Makefile b/tools/crc32sum/Makefile
new file mode 100644
index 0000000000..bc13ecf92b
--- /dev/null
+++ b/tools/crc32sum/Makefile
@@ -0,0 +1,23 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=crc32sum
+PKG_VERSION:=1.0
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Prepare
+	mkdir -p $(HOST_BUILD_DIR)
+	$(CP) -a ./src/* $(HOST_BUILD_DIR)/
+endef
+
+define Host/Install
+	$(INSTALL_BIN) $(HOST_BUILD_DIR)/crc32sum $(STAGING_DIR_HOST)/bin/
+endef
+
+$(eval $(call HostBuild))
diff --git a/tools/crc32sum/src/Makefile b/tools/crc32sum/src/Makefile
new file mode 100644
index 0000000000..7428ba2f54
--- /dev/null
+++ b/tools/crc32sum/src/Makefile
@@ -0,0 +1,18 @@
+#
+# Copyright (C) 2021 MediaTek Inc. All rights reserved.
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+all: crc32sum
+
+crc32sum: crc32sum.c
+	$(CC) $(CFLAGS) -O2 -ggdb -MD -o $@ $< $(LDFLAGS)
+
+clean:
+	rm -f crc32sum crc32sum.d
+
+.PHONY: clean
+
+-include crc32sum.d
diff --git a/tools/crc32sum/src/crc32sum.c b/tools/crc32sum/src/crc32sum.c
new file mode 100644
index 0000000000..381c7a95a7
--- /dev/null
+++ b/tools/crc32sum/src/crc32sum.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 MediaTek Inc. All Rights Reserved.
+ *
+ * Author: Weijie Gao <weijie.gao@mediatek.com>
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+
+#ifdef _WIN32
+#include <io.h>
+#include <fcntl.h>
+#define SET_BINARY_MODE(_f)		_setmode(_fileno(_f, O_BINARY)
+#else
+#define SET_BINARY_MODE(_f)		((void)0)
+#endif
+
+#define CRC32_LE_POLY_DEFAULT		0xedb88320
+#define CRC32_BE_POLY_DEFAULT		0x04c11db7
+#define CRC32_TABLE_ITEMS		256
+
+static uint32_t crc32_le_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)(crc ^ *data++)] ^ (crc >> 8);
+
+	return crc;
+}
+
+static void crc32_le_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i;
+
+		for (j = 0; j < 8; j++)
+			v = (v >> 1) ^ ((v & 1) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+static uint32_t crc32_be_calc(uint32_t crc, const uint8_t *data, size_t length,
+			      const uint32_t *crc_table)
+{
+	while (length--)
+		crc = crc_table[(uint8_t)((crc >> 24) ^ *data++)] ^ (crc << 8);
+
+	return crc;
+}
+
+static void crc32_be_init(uint32_t *crc_table, uint32_t poly)
+{
+	uint32_t i, j, v;
+
+	for (i = 0; i < CRC32_TABLE_ITEMS; i++) {
+		v = i << 24;
+
+		for (j = 0; j < 8; j++)
+			v = (v << 1) ^ ((v & (1 << 31)) ? poly : 0);
+
+		crc_table[i] = v;
+	}
+}
+
+struct crc_funcs {
+	uint32_t poly;
+
+	void (*init)(uint32_t *crc_table, uint32_t poly);
+	uint32_t (*calc)(uint32_t crc, const uint8_t *data, size_t length,
+			 const uint32_t *crc_table);
+};
+
+static const struct crc_funcs crc32_le = {
+	.poly = CRC32_LE_POLY_DEFAULT,
+	.init = crc32_le_init,
+	.calc = crc32_le_calc,
+};
+
+static const struct crc_funcs crc32_be = {
+	.poly = CRC32_BE_POLY_DEFAULT,
+	.init = crc32_be_init,
+	.calc = crc32_be_calc,
+};
+
+static const struct crc_funcs *crc32_algo = &crc32_le;
+static uint32_t crc32_poly;
+static uint32_t crc32_val;
+static const char *input_file;
+static bool output_decimal;
+static bool no_comp;
+
+static void err(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	fprintf(stderr, "Error: ");
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+}
+
+static void usage(FILE *con, const char *progname, int exitcode)
+{
+	const char *prog;
+	size_t len;
+
+	len = strlen(progname);
+	prog = progname + len - 1;
+
+	while (prog > progname) {
+		if (*prog == '\\' || *prog == '/') {
+			prog++;
+			break;
+		}
+
+		prog--;
+	}
+
+	fprintf(con, "CRC32 checksum tool\n");
+	fprintf(con, "\n");
+	fprintf(con, "Usage: %s [options] <input_file>\n", prog);
+	fprintf(con, "\n");
+	fprintf(con, "Options:\n");
+	fprintf(con, "\t-h         display help message\n");
+	fprintf(con, "\t-i <val>   crc value for incremental calculation\n");
+	fprintf(con, "\t           (default is 0)\n");
+	fprintf(con, "\t-p <val>   polynomial for calculation\n");
+	fprintf(con, "\t           (default is 0x%08x for LE, 0x%08x for BE)\n",
+		crc32_le.poly, crc32_be.poly);
+	fprintf(con, "\t-b         use big-endian mode\n");
+	fprintf(con, "\t-n         do not use one's complement\n");
+	fprintf(con, "\t-d         use decimal output\n");
+	fprintf(con, "\n");
+
+	exit(exitcode);
+}
+
+static int parse_args(int argc, char *argv[])
+{
+	int opt;
+
+	static const char *optstring = "i:p:bndh";
+
+	opterr = 0;
+
+	while ((opt = getopt(argc, argv, optstring)) >= 0) {
+		switch (opt) {
+		case 'i':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid crc value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_val = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'p':
+			if (!isxdigit(optarg[0])) {
+				err("Invalid polynomial value - %s\n", optarg);
+				return -EINVAL;
+			}
+
+			crc32_poly = strtoul(optarg, NULL, 0);
+			break;
+
+		case 'b':
+			crc32_algo = &crc32_be;
+			break;
+
+		case 'n':
+			no_comp = true;
+			break;
+
+		case 'd':
+			output_decimal = true;
+			break;
+
+		case 'h':
+			usage(stdout, argv[0], 0);
+			break;
+
+		default:
+			usage(stderr, argv[0], EXIT_FAILURE);
+		}
+	}
+
+	if (!crc32_poly)
+		crc32_poly = crc32_algo->poly;
+
+	if (optind >= argc)
+		input_file = "-";
+	else
+		input_file = argv[optind];
+
+	if (!input_file[0]) {
+		err("Input file must not be empty\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int crc32_calc(void)
+{
+	uint32_t crc_table[CRC32_TABLE_ITEMS];
+	bool using_stdin = false;
+	uint8_t buf[4096];
+	size_t size;
+	int ret, i;
+	FILE *f;
+
+	if (!strcmp(input_file, "-")) {
+		SET_BINARY_MODE(stdin);
+		using_stdin = true;
+		f = stdin;
+	} else {
+		f = fopen(input_file, "rb");
+	}
+
+	if (!f) {
+		err("Failed to open file '%s'\n", input_file);
+		return -EINVAL;
+	}
+
+	crc32_algo->init(crc_table, crc32_poly);
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	do {
+		size = fread(buf, 1, sizeof(buf), f);
+
+		if (size) {
+			crc32_val = crc32_algo->calc(crc32_val, buf, size,
+						     crc_table);
+		}
+
+		if (size < sizeof(buf)) {
+			ret = ferror(f);
+
+			if (!ret && feof(f))
+				break;
+
+			err("Error while reading file: %d\n", ret);
+			break;
+		}
+	} while (true);
+
+	if (!using_stdin)
+		fclose(f);
+
+	if (ret)
+		return ret;
+
+	if (!no_comp)
+		crc32_val ^= 0xffffffff;
+
+	if (output_decimal)
+		printf("%u\n", crc32_val);
+	else
+		printf("%08x\n", crc32_val);
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	if (parse_args(argc, argv))
+		return 1;
+
+	return crc32_calc();
+}
-- 
2.43.2

