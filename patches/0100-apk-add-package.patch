From 36477da6dda49f71f44f3746260020965514198d Mon Sep 17 00:00:00 2001
From: Paul Spooren <mail@aparcar.org>
Date: Mon, 14 Feb 2022 12:21:08 +0100
Subject: [PATCH] apk: add package

APK (Alpine Package Keeper) is the package manager of Alpine Linux and
has multiple advantages over OPKG, add the manager as an alternative.

Signed-off-by: Paul Spooren <mail@aparcar.org>
---
 package/system/apk/Makefile                   |  64 +++
 ...-prepare-database-reading-for-layers.patch | 234 ++++++++++
 ...-prepare-database-writing-for-layers.patch | 416 ++++++++++++++++++
 ...db-sort-world-dependencies-to-layers.patch | 128 ++++++
 .../0004-adb-add-layer-to-pkginfo.patch       |  52 +++
 ...ackage-layer-to-be-enabled-for-insta.patch |  45 ++
 ...naming-schema-to-name-_-version-.apk.patch |  61 +++
 .../0007-package-store-scripts-in-tmp.patch   |  41 ++
 .../0008-context-fix-uvol-default-path.patch  |  29 ++
 ...uvol-take-down-volume-before-removal.patch |  37 ++
 ...-index-format-without-attaching-arch.patch |  63 +++
 ...-t-create-cache-folder-with-no-cache.patch |  49 +++
 12 files changed, 1219 insertions(+)
 create mode 100644 package/system/apk/Makefile
 create mode 100644 package/system/apk/patches/0001-db-prepare-database-reading-for-layers.patch
 create mode 100644 package/system/apk/patches/0002-db-prepare-database-writing-for-layers.patch
 create mode 100644 package/system/apk/patches/0003-db-sort-world-dependencies-to-layers.patch
 create mode 100644 package/system/apk/patches/0004-adb-add-layer-to-pkginfo.patch
 create mode 100644 package/system/apk/patches/0005-solver-require-package-layer-to-be-enabled-for-insta.patch
 create mode 100644 package/system/apk/patches/0006-change-naming-schema-to-name-_-version-.apk.patch
 create mode 100644 package/system/apk/patches/0007-package-store-scripts-in-tmp.patch
 create mode 100644 package/system/apk/patches/0008-context-fix-uvol-default-path.patch
 create mode 100644 package/system/apk/patches/0009-fs_uvol-take-down-volume-before-removal.patch
 create mode 100644 package/system/apk/patches/0010-support-new-index-format-without-attaching-arch.patch
 create mode 100644 package/system/apk/patches/0011-Don-t-create-cache-folder-with-no-cache.patch

diff --git a/package/system/apk/Makefile b/package/system/apk/Makefile
new file mode 100644
index 0000000000..980186cb00
--- /dev/null
+++ b/package/system/apk/Makefile
@@ -0,0 +1,64 @@
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=apk
+PKG_RELEASE:=$(AUTORELEASE)
+
+PKG_SOURCE_DATE:=20220201
+PKG_SOURCE_VERSION:=6315575af1cfd9d8d195c6a7173b6a73ccf28f14
+PKG_HASH:=0cd0672d56b6cd2ae1aa7b371540a26360beffde2f59a8bd1da2de07a6ee159e
+
+PKG_VERSION:=3.0.0_pre0_git$(PKG_SOURCE_DATE)
+PKG_SOURCE:=apk-tools-v$(PKG_SOURCE_VERSION).tar.gz
+PKG_SOURCE_URL:=https://gitlab.alpinelinux.org/alpine/apk-tools/-/archive/$(PKG_SOURCE_VERSION)
+PKG_BUILD_DIR:=$(BUILD_DIR)/apk-tools-$(PKG_SOURCE_VERSION)
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/apk-tools-$(PKG_SOURCE_VERSION)
+
+PKG_MAINTAINER:=Paul Spooren <mail@aparcar.org>
+PKG_LICENSE:=GPL-2.0-only
+PKG_LICENSE_FILES:=LICENSE
+PKG_INSTALL:=1
+
+HOST_BUILD_PREFIX:=$(STAGING_DIR_HOST)
+HOST_BUILD_DEPENDS:=lua/host
+PKG_BUILD_DEPENDS:=$(HOST_BUILD_DEPENDS)
+
+include $(INCLUDE_DIR)/package.mk
+include $(INCLUDE_DIR)/host-build.mk
+include $(INCLUDE_DIR)/meson.mk
+
+define Package/apk
+  SECTION:=base
+  CATEGORY:=Base system
+  TITLE:=apk package manager
+  DEPENDS:=+zlib +libopenssl +libpthread @!arc
+  URL:=$(PKG_SOURCE_URL)
+endef
+
+MESON_HOST_ARGS += \
+	-Dlua_version=5.1 \
+	-Dcompressed-help=false \
+	-Ddocs=disabled
+MESON_ARGS += \
+	-Dlua_version=5.1 \
+	-Dcompressed-help=false \
+	-Ddocs=disabled
+	
+HOST_LDFLAGS += \
+	-Wl,-rpath $(STAGING_DIR_HOST)/lib \
+	-lpthread
+
+TARGET_CFLAGS += $(FPIC)
+HOST_CFLAGS += $(HOST_FPIC)
+
+define Package/apk/install
+	$(INSTALL_DIR) $(1)/lib/apk/db
+
+	$(INSTALL_DIR) $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_INSTALL_DIR)/usr/bin/apk $(1)/usr/bin/apk
+
+	$(INSTALL_DIR) $(1)/usr/lib
+	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libapk.so.* $(1)/usr/lib/
+endef
+
+$(eval $(call BuildPackage,apk))
+$(eval $(call HostBuild))
diff --git a/package/system/apk/patches/0001-db-prepare-database-reading-for-layers.patch b/package/system/apk/patches/0001-db-prepare-database-reading-for-layers.patch
new file mode 100644
index 0000000000..be5185cb0d
--- /dev/null
+++ b/package/system/apk/patches/0001-db-prepare-database-reading-for-layers.patch
@@ -0,0 +1,234 @@
+From 554f08822b3fee3b5ca21f415770a5c3c40f67b9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
+Date: Tue, 1 Feb 2022 19:44:36 +0200
+Subject: [PATCH 01/11] db: prepare database reading for layers
+
+---
+ src/apk_database.h |  6 ++++
+ src/apk_package.h  |  1 +
+ src/app_policy.c   |  6 ++--
+ src/database.c     | 70 ++++++++++++++++++++++++++++++++--------------
+ 4 files changed, 58 insertions(+), 25 deletions(-)
+
+diff --git a/src/apk_database.h b/src/apk_database.h
+index 5958d6f..88107d3 100644
+--- a/src/apk_database.h
++++ b/src/apk_database.h
+@@ -115,6 +115,10 @@ struct apk_repository {
+ 	apk_blob_t description;
+ };
+ 
++#define APK_DB_LAYER_ROOT		0
++#define APK_DB_LAYER_UVOL		1
++#define APK_DB_LAYER_NUM		2
++
+ #define APK_REPOSITORY_CACHED		0
+ #define APK_REPOSITORY_FIRST_CONFIGURED	1
+ 
+@@ -138,6 +142,7 @@ struct apk_database {
+ 	unsigned int repo_update_errors, repo_update_counter;
+ 	unsigned int pending_triggers;
+ 	unsigned int extract_flags;
++	unsigned int active_layers;
+ 	int performing_self_upgrade : 1;
+ 	int permanent : 1;
+ 	int autoupdate : 1;
+@@ -189,6 +194,7 @@ struct apk_db_dir *apk_db_dir_query(struct apk_database *db, apk_blob_t name);
+ struct apk_db_file *apk_db_file_query(struct apk_database *db,
+ 				      apk_blob_t dir, apk_blob_t name);
+ 
++const char *apk_db_layer_name(int layer);
+ void apk_db_init(struct apk_database *db);
+ int apk_db_open(struct apk_database *db, struct apk_ctx *ctx);
+ void apk_db_close(struct apk_database *db);
+diff --git a/src/apk_package.h b/src/apk_package.h
+index 1d9ca6e..e7e0a53 100644
+--- a/src/apk_package.h
++++ b/src/apk_package.h
+@@ -93,6 +93,7 @@ struct apk_package {
+ 	unsigned marked : 1;
+ 	unsigned uninstallable : 1;
+ 	unsigned cached_non_repository : 1;
++	unsigned layer : 4;
+ 	struct apk_checksum csum;
+ };
+ APK_ARRAY(apk_package_array, struct apk_package *);
+diff --git a/src/app_policy.c b/src/app_policy.c
+index c026337..a927a5f 100644
+--- a/src/app_policy.c
++++ b/src/app_policy.c
+@@ -13,8 +13,6 @@
+ #include "apk_version.h"
+ #include "apk_print.h"
+ 
+-extern const char * const apk_installed_file;
+-
+ static void print_policy(struct apk_database *db, const char *match, struct apk_name *name, void *ctx)
+ {
+ 	struct apk_out *out = &db->ctx->out;
+@@ -44,8 +42,8 @@ zlib1g policy:
+ 		if (num++ == 0)
+ 			apk_out(out, "%s policy:", name->name);
+ 		apk_out(out, "  " BLOB_FMT ":", BLOB_PRINTF(*p->version));
+-		if (p->pkg->ipkg != NULL)
+-			apk_out(out, "    %s", apk_installed_file);
++		if (p->pkg->ipkg)
++			apk_out(out, "    %s/installed", apk_db_layer_name(p->pkg->layer));
+ 		for (i = 0; i < db->num_repos; i++) {
+ 			repo = &db->repos[i];
+ 			if (!(BIT(i) & p->pkg->repos))
+diff --git a/src/database.c b/src/database.c
+index a122d91..2ef0576 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -56,9 +56,6 @@ static const char * const apk_static_cache_dir = "var/cache/apk";
+ static const char * const apk_world_file = "etc/apk/world";
+ static const char * const apk_arch_file = "etc/apk/arch";
+ static const char * const apk_lock_file = "lib/apk/db/lock";
+-static const char * const apk_scripts_file = "lib/apk/db/scripts.tar";
+-static const char * const apk_triggers_file = "lib/apk/db/triggers";
+-const char * const apk_installed_file = "lib/apk/db/installed";
+ 
+ static struct apk_db_acl *apk_default_acl_dir, *apk_default_acl_file;
+ 
+@@ -747,7 +744,7 @@ err:
+ 	return apk_istream_close(is);
+ }
+ 
+-int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo)
++static int apk_db_fdb_read(struct apk_database *db, struct apk_istream *is, int repo, unsigned layer)
+ {
+ 	struct apk_out *out = &db->ctx->out;
+ 	struct apk_package *pkg = NULL;
+@@ -800,6 +797,7 @@ int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo)
+ 		/* If no package, create new */
+ 		if (pkg == NULL) {
+ 			pkg = apk_pkg_new();
++			pkg->layer = layer;
+ 			ipkg = NULL;
+ 			diri = NULL;
+ 			file_diri_node = NULL;
+@@ -899,6 +897,11 @@ err_fmt:
+ 	return apk_istream_close(is);
+ }
+ 
++int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo)
++{
++	return apk_db_fdb_read(db, is, repo, 0);
++}
++
+ static void apk_blob_push_db_acl(apk_blob_t *b, char field, struct apk_db_acl *acl)
+ {
+ 	char hdr[2] = { field, ':' };
+@@ -1159,21 +1162,29 @@ static int apk_db_triggers_read(struct apk_database *db, struct apk_istream *is)
+ 	return apk_istream_close(is);
+ }
+ 
+-static int apk_db_read_state(struct apk_database *db, int flags)
++static int apk_db_read_layer(struct apk_database *db, unsigned layer)
+ {
+ 	apk_blob_t blob, world;
+-	int r, ret = 0;
++	int r, fd, ret = 0, flags = db->ctx->open_flags;
+ 
+ 	/* Read:
+-	 * 1. /etc/apk/world
++	 * 1. world
+ 	 * 2. installed packages db
+ 	 * 3. triggers db
+ 	 * 4. scripts db
+ 	 */
++
++	fd = openat(db->root_fd, apk_db_layer_name(layer), O_RDONLY | O_CLOEXEC);
++	if (fd < 0) return -errno;
++
+ 	if (!(flags & APK_OPENF_NO_WORLD)) {
+-		blob = world = apk_blob_from_file(db->root_fd, apk_world_file);
+-		if (!APK_BLOB_IS_NULL(blob)) {
+-			blob = apk_blob_trim(blob);
++		if (layer == APK_DB_LAYER_ROOT)
++			world = apk_blob_from_file(db->root_fd, apk_world_file);
++		else
++			world = apk_blob_from_file(fd, "world");
++
++		if (!APK_BLOB_IS_NULL(world)) {
++			blob = apk_blob_trim(world);
+ 			apk_blob_pull_deps(&blob, db, &db->world);
+ 			free(world.ptr);
+ 		} else {
+@@ -1182,18 +1193,19 @@ static int apk_db_read_state(struct apk_database *db, int flags)
+ 	}
+ 
+ 	if (!(flags & APK_OPENF_NO_INSTALLED)) {
+-		r = apk_db_index_read(db, apk_istream_from_file(db->root_fd, apk_installed_file), -1);
+-		if (r && r != -ENOENT) ret = r;
+-		r = apk_db_triggers_read(db, apk_istream_from_file(db->root_fd, apk_triggers_file));
+-		if (r && r != -ENOENT) ret = r;
++		r = apk_db_fdb_read(db, apk_istream_from_file(fd, "installed"), -1, layer);
++		if (!ret && r != -ENOENT) ret = r;
++		r = apk_db_triggers_read(db, apk_istream_from_file(fd, "triggers"));
++		if (!ret && r != -ENOENT) ret = r;
+ 	}
+ 
+ 	if (!(flags & APK_OPENF_NO_SCRIPTS)) {
+-		r = apk_tar_parse(apk_istream_from_file(db->root_fd, apk_scripts_file),
++		r = apk_tar_parse(apk_istream_from_file(fd, "scripts.tar"),
+ 				  apk_read_script_archive_entry, db, db->id_cache);
+-		if (r && r != -ENOENT) ret = r;
++		if (!ret && r != -ENOENT) ret = r;
+ 	}
+ 
++	close(fd);
+ 	return ret;
+ }
+ 
+@@ -1604,6 +1616,17 @@ static void unmount_proc(struct apk_database *db)
+ }
+ #endif
+ 
++const char *apk_db_layer_name(int layer)
++{
++	switch (layer) {
++	case APK_DB_LAYER_ROOT: return "lib/apk/db";
++	case APK_DB_LAYER_UVOL: return "lib/apk/db-uvol";
++	default:
++		assert("invalid layer");
++		return 0;
++	}
++}
++
+ void apk_db_init(struct apk_database *db)
+ {
+ 	memset(db, 0, sizeof(*db));
+@@ -1625,7 +1648,7 @@ int apk_db_open(struct apk_database *db, struct apk_ctx *ac)
+ 	struct apk_out *out = &ac->out;
+ 	const char *msg = NULL;
+ 	apk_blob_t blob;
+-	int r;
++	int r, i;
+ 
+ 	apk_default_acl_dir = apk_db_acl_atomize(db, 0755, 0, 0);
+ 	apk_default_acl_file = apk_db_acl_atomize(db, 0644, 0, 0);
+@@ -1709,10 +1732,15 @@ int apk_db_open(struct apk_database *db, struct apk_ctx *ac)
+ 		apk_db_read_overlay(db, apk_istream_from_fd(STDIN_FILENO));
+ 	}
+ 
+-	r = apk_db_read_state(db, ac->open_flags);
+-	if (r != 0 && !(r == -ENOENT && (ac->open_flags & APK_OPENF_CREATE))) {
+-		msg = "Unable to read database state";
+-		goto ret_r;
++	for (i = 0; i < APK_DB_LAYER_NUM; i++) {
++		r = apk_db_read_layer(db, i);
++		if (r) {
++			if (i != 0) continue;
++			if (r == -ENOENT && (ac->open_flags & APK_OPENF_CREATE)) continue;
++			msg = "Unable to read database";
++			goto ret_r;
++		}
++		db->active_layers |= BIT(i);
+ 	}
+ 
+ 	if (!(ac->open_flags & APK_OPENF_NO_INSTALLED_REPO)) {
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0002-db-prepare-database-writing-for-layers.patch b/package/system/apk/patches/0002-db-prepare-database-writing-for-layers.patch
new file mode 100644
index 0000000000..e93b3d1a31
--- /dev/null
+++ b/package/system/apk/patches/0002-db-prepare-database-writing-for-layers.patch
@@ -0,0 +1,416 @@
+From 503c13830b65c3a2849db09392d7494cc6d81f73 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
+Date: Tue, 1 Feb 2022 17:44:49 +0200
+Subject: [PATCH 02/11] db: prepare database writing for layers
+
+---
+ src/database.c | 307 +++++++++++++++++++++++++++----------------------
+ 1 file changed, 172 insertions(+), 135 deletions(-)
+
+diff --git a/src/database.c b/src/database.c
+index 2ef0576..23e366e 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -919,10 +919,9 @@ static void apk_blob_push_db_acl(apk_blob_t *b, char field, struct apk_db_acl *a
+ 	apk_blob_push_blob(b, APK_BLOB_STR("\n"));
+ }
+ 
+-static int apk_db_write_fdb(struct apk_database *db, struct apk_ostream *os)
++static int apk_db_fdb_write(struct apk_database *db, struct apk_installed_package *ipkg, struct apk_ostream *os)
+ {
+-	struct apk_installed_package *ipkg;
+-	struct apk_package *pkg;
++	struct apk_package *pkg = ipkg->pkg;
+ 	struct apk_db_dir_instance *diri;
+ 	struct apk_db_file *file;
+ 	struct hlist_node *c1, *c2;
+@@ -932,45 +931,66 @@ static int apk_db_write_fdb(struct apk_database *db, struct apk_ostream *os)
+ 
+ 	if (IS_ERR(os)) return PTR_ERR(os);
+ 
+-	list_for_each_entry(ipkg, &db->installed.packages, installed_pkgs_list) {
+-		pkg = ipkg->pkg;
+-		r = apk_pkg_write_index_entry(pkg, os);
++	r = apk_pkg_write_index_entry(pkg, os);
++	if (r < 0) goto err;
++
++	if (ipkg->replaces->num) {
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("r:"));
++		apk_blob_push_deps(&bbuf, db, ipkg->replaces);
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++	}
++	if (ipkg->replaces_priority) {
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("q:"));
++		apk_blob_push_uint(&bbuf, ipkg->replaces_priority, 10);
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++	}
++	if (ipkg->repository_tag) {
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("s:"));
++		apk_blob_push_blob(&bbuf, db->repo_tags[ipkg->repository_tag].plain_name);
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++	}
++	if (ipkg->broken_files || ipkg->broken_script || ipkg->broken_xattr || ipkg->sha256_160) {
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("f:"));
++		if (ipkg->broken_files)
++			apk_blob_push_blob(&bbuf, APK_BLOB_STR("f"));
++		if (ipkg->broken_script)
++			apk_blob_push_blob(&bbuf, APK_BLOB_STR("s"));
++		if (ipkg->broken_xattr)
++			apk_blob_push_blob(&bbuf, APK_BLOB_STR("x"));
++		if (ipkg->sha256_160)
++			apk_blob_push_blob(&bbuf, APK_BLOB_STR("S"));
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++	}
++	hlist_for_each_entry(diri, c1, &ipkg->owned_dirs, pkg_dirs_list) {
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("F:"));
++		apk_blob_push_blob(&bbuf, APK_BLOB_PTR_LEN(diri->dir->name, diri->dir->namelen));
++		apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++
++		if (diri->acl != apk_default_acl_dir)
++			apk_blob_push_db_acl(&bbuf, 'M', diri->acl);
++
++		bbuf = apk_blob_pushed(APK_BLOB_BUF(buf), bbuf);
++		if (APK_BLOB_IS_NULL(bbuf)) {
++			r = -ENOBUFS;
++			goto err;
++		}
++		r = apk_ostream_write(os, bbuf.ptr, bbuf.len);
+ 		if (r < 0) goto err;
++		bbuf = APK_BLOB_BUF(buf);
+ 
+-		if (ipkg->replaces->num) {
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("r:"));
+-			apk_blob_push_deps(&bbuf, db, ipkg->replaces);
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-		}
+-		if (ipkg->replaces_priority) {
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("q:"));
+-			apk_blob_push_uint(&bbuf, ipkg->replaces_priority, 10);
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-		}
+-		if (ipkg->repository_tag) {
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("s:"));
+-			apk_blob_push_blob(&bbuf, db->repo_tags[ipkg->repository_tag].plain_name);
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-		}
+-		if (ipkg->broken_files || ipkg->broken_script || ipkg->broken_xattr || ipkg->sha256_160) {
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("f:"));
+-			if (ipkg->broken_files)
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("f"));
+-			if (ipkg->broken_script)
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("s"));
+-			if (ipkg->broken_xattr)
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("x"));
+-			if (ipkg->sha256_160)
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("S"));
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-		}
+-		hlist_for_each_entry(diri, c1, &ipkg->owned_dirs, pkg_dirs_list) {
+-			apk_blob_push_blob(&bbuf, APK_BLOB_STR("F:"));
+-			apk_blob_push_blob(&bbuf, APK_BLOB_PTR_LEN(diri->dir->name, diri->dir->namelen));
++		hlist_for_each_entry(file, c2, &diri->owned_files, diri_files_list) {
++			apk_blob_push_blob(&bbuf, APK_BLOB_STR("R:"));
++			apk_blob_push_blob(&bbuf, APK_BLOB_PTR_LEN(file->name, file->namelen));
+ 			apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+ 
+-			if (diri->acl != apk_default_acl_dir)
+-				apk_blob_push_db_acl(&bbuf, 'M', diri->acl);
++			if (file->acl != apk_default_acl_file)
++				apk_blob_push_db_acl(&bbuf, 'a', file->acl);
++
++			if (file->csum.type != APK_CHECKSUM_NONE) {
++				apk_blob_push_blob(&bbuf, APK_BLOB_STR("Z:"));
++				apk_blob_push_csum(&bbuf, &file->csum);
++				apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
++			}
+ 
+ 			bbuf = apk_blob_pushed(APK_BLOB_BUF(buf), bbuf);
+ 			if (APK_BLOB_IS_NULL(bbuf)) {
+@@ -980,43 +1000,17 @@ static int apk_db_write_fdb(struct apk_database *db, struct apk_ostream *os)
+ 			r = apk_ostream_write(os, bbuf.ptr, bbuf.len);
+ 			if (r < 0) goto err;
+ 			bbuf = APK_BLOB_BUF(buf);
+-
+-			hlist_for_each_entry(file, c2, &diri->owned_files, diri_files_list) {
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("R:"));
+-				apk_blob_push_blob(&bbuf, APK_BLOB_PTR_LEN(file->name, file->namelen));
+-				apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-
+-				if (file->acl != apk_default_acl_file)
+-					apk_blob_push_db_acl(&bbuf, 'a', file->acl);
+-
+-				if (file->csum.type != APK_CHECKSUM_NONE) {
+-					apk_blob_push_blob(&bbuf, APK_BLOB_STR("Z:"));
+-					apk_blob_push_csum(&bbuf, &file->csum);
+-					apk_blob_push_blob(&bbuf, APK_BLOB_STR("\n"));
+-				}
+-
+-				bbuf = apk_blob_pushed(APK_BLOB_BUF(buf), bbuf);
+-				if (APK_BLOB_IS_NULL(bbuf)) {
+-					r = -ENOBUFS;
+-					goto err;
+-				}
+-				r = apk_ostream_write(os, bbuf.ptr, bbuf.len);
+-				if (r < 0) goto err;
+-				bbuf = APK_BLOB_BUF(buf);
+-			}
+ 		}
+-		r = apk_ostream_write(os, "\n", 1);
+-		if (r < 0) goto err;
+ 	}
++	r = apk_ostream_write(os, "\n", 1);
+ err:
+ 	if (r < 0) apk_ostream_cancel(os, r);
+-	return apk_ostream_close(os);
++	return r;
+ }
+ 
+-static int apk_db_scriptdb_write(struct apk_database *db, struct apk_ostream *os)
++static int apk_db_scriptdb_write(struct apk_database *db, struct apk_installed_package *ipkg, struct apk_ostream *os)
+ {
+-	struct apk_installed_package *ipkg;
+-	struct apk_package *pkg;
++	struct apk_package *pkg = ipkg->pkg;
+ 	struct apk_file_info fi;
+ 	char filename[256];
+ 	apk_blob_t bfn;
+@@ -1024,40 +1018,34 @@ static int apk_db_scriptdb_write(struct apk_database *db, struct apk_ostream *os
+ 
+ 	if (IS_ERR(os)) return PTR_ERR(os);
+ 
+-	list_for_each_entry(ipkg, &db->installed.packages, installed_pkgs_list) {
+-		pkg = ipkg->pkg;
+-
+-		for (i = 0; i < APK_SCRIPT_MAX; i++) {
+-			if (ipkg->script[i].ptr == NULL)
+-				continue;
+-
+-			fi = (struct apk_file_info) {
+-				.name = filename,
+-				.size = ipkg->script[i].len,
+-				.mode = 0755 | S_IFREG,
+-			};
+-			/* The scripts db expects file names in format:
+-			 * pkg-version.<hexdump of package checksum>.action */
+-			bfn = APK_BLOB_BUF(filename);
+-			apk_blob_push_blob(&bfn, APK_BLOB_STR(pkg->name->name));
+-			apk_blob_push_blob(&bfn, APK_BLOB_STR("-"));
+-			apk_blob_push_blob(&bfn, *pkg->version);
+-			apk_blob_push_blob(&bfn, APK_BLOB_STR("."));
+-			apk_blob_push_csum(&bfn, &pkg->csum);
+-			apk_blob_push_blob(&bfn, APK_BLOB_STR("."));
+-			apk_blob_push_blob(&bfn, APK_BLOB_STR(apk_script_types[i]));
+-			apk_blob_push_blob(&bfn, APK_BLOB_PTR_LEN("", 1));
+-
+-			r = apk_tar_write_entry(os, &fi, ipkg->script[i].ptr);
+-			if (r < 0) {
+-				apk_ostream_cancel(os, -APKE_V2DB_FORMAT);
+-				break;
+-			}
++	for (i = 0; i < APK_SCRIPT_MAX; i++) {
++		if (!ipkg->script[i].ptr) continue;
++
++		fi = (struct apk_file_info) {
++			.name = filename,
++			.size = ipkg->script[i].len,
++			.mode = 0755 | S_IFREG,
++		};
++		/* The scripts db expects file names in format:
++		 * pkg-version.<hexdump of package checksum>.action */
++		bfn = APK_BLOB_BUF(filename);
++		apk_blob_push_blob(&bfn, APK_BLOB_STR(pkg->name->name));
++		apk_blob_push_blob(&bfn, APK_BLOB_STR("-"));
++		apk_blob_push_blob(&bfn, *pkg->version);
++		apk_blob_push_blob(&bfn, APK_BLOB_STR("."));
++		apk_blob_push_csum(&bfn, &pkg->csum);
++		apk_blob_push_blob(&bfn, APK_BLOB_STR("."));
++		apk_blob_push_blob(&bfn, APK_BLOB_STR(apk_script_types[i]));
++		apk_blob_push_blob(&bfn, APK_BLOB_PTR_LEN("", 1));
++
++		r = apk_tar_write_entry(os, &fi, ipkg->script[i].ptr);
++		if (r < 0) {
++			apk_ostream_cancel(os, -APKE_V2DB_FORMAT);
++			break;
+ 		}
+ 	}
+ 
+-	apk_tar_write_entry(os, NULL, NULL);
+-	return apk_ostream_close(os);
++	return r;
+ }
+ 
+ static int apk_read_script_archive_entry(void *ctx,
+@@ -1111,28 +1099,26 @@ static int parse_triggers(void *ctx, apk_blob_t blob)
+ 	return 0;
+ }
+ 
+-static int apk_db_triggers_write(struct apk_database *db, struct apk_ostream *os)
++static int apk_db_triggers_write(struct apk_database *db, struct apk_installed_package *ipkg, struct apk_ostream *os)
+ {
+-	struct apk_installed_package *ipkg;
+ 	char buf[APK_BLOB_CHECKSUM_BUF];
+ 	apk_blob_t bfn;
+ 	char **trigger;
+ 
+ 	if (IS_ERR(os)) return PTR_ERR(os);
++	if (!ipkg->triggers || ipkg->triggers->num == 0) return 0;
+ 
+-	list_for_each_entry(ipkg, &db->installed.triggers, trigger_pkgs_list) {
+-		bfn = APK_BLOB_BUF(buf);
+-		apk_blob_push_csum(&bfn, &ipkg->pkg->csum);
+-		bfn = apk_blob_pushed(APK_BLOB_BUF(buf), bfn);
+-		apk_ostream_write(os, bfn.ptr, bfn.len);
+-
+-		foreach_array_item(trigger, ipkg->triggers) {
+-			apk_ostream_write(os, " ", 1);
+-			apk_ostream_write_string(os, *trigger);
+-		}
+-		apk_ostream_write(os, "\n", 1);
++	bfn = APK_BLOB_BUF(buf);
++	apk_blob_push_csum(&bfn, &ipkg->pkg->csum);
++	bfn = apk_blob_pushed(APK_BLOB_BUF(buf), bfn);
++	apk_ostream_write(os, bfn.ptr, bfn.len);
++
++	foreach_array_item(trigger, ipkg->triggers) {
++		apk_ostream_write(os, " ", 1);
++		apk_ostream_write_string(os, *trigger);
+ 	}
+-	return apk_ostream_close(os);
++	apk_ostream_write(os, "\n", 1);
++	return 0;
+ }
+ 
+ static int apk_db_triggers_read(struct apk_database *db, struct apk_istream *is)
+@@ -1187,7 +1173,7 @@ static int apk_db_read_layer(struct apk_database *db, unsigned layer)
+ 			blob = apk_blob_trim(world);
+ 			apk_blob_pull_deps(&blob, db, &db->world);
+ 			free(world.ptr);
+-		} else {
++		} else if (layer == APK_DB_LAYER_ROOT) {
+ 			ret = -ENOENT;
+ 		}
+ 	}
+@@ -1735,10 +1721,11 @@ int apk_db_open(struct apk_database *db, struct apk_ctx *ac)
+ 	for (i = 0; i < APK_DB_LAYER_NUM; i++) {
+ 		r = apk_db_read_layer(db, i);
+ 		if (r) {
+-			if (i != 0) continue;
+-			if (r == -ENOENT && (ac->open_flags & APK_OPENF_CREATE)) continue;
+-			msg = "Unable to read database";
+-			goto ret_r;
++			if (i != APK_DB_LAYER_ROOT) continue;
++			if (!(r == -ENOENT && (ac->open_flags & APK_OPENF_CREATE))) {
++				msg = "Unable to read database";
++				goto ret_r;
++			}
+ 		}
+ 		db->active_layers |= BIT(i);
+ 	}
+@@ -1798,10 +1785,74 @@ struct write_ctx {
+ 	int fd;
+ };
+ 
++static int apk_db_write_layers(struct apk_database *db)
++{
++	struct layer_data {
++		int fd;
++		struct apk_ostream *installed, *scripts, *triggers;
++	} layers[APK_DB_LAYER_NUM] = {0};
++	struct apk_installed_package *ipkg;
++	struct apk_ostream *os;
++	int i, r, rr = 0;
++
++	for (i = 0; i < APK_DB_LAYER_NUM; i++) {
++		struct layer_data *ld = &layers[i];
++		if (!(db->active_layers & BIT(i))) continue;
++
++		ld->fd = openat(db->root_fd, apk_db_layer_name(i), O_RDONLY | O_CLOEXEC);
++		if (ld->fd < 0) {
++			if (i == 0) return -errno;
++			continue;
++		}
++		ld->installed = apk_ostream_to_file(ld->fd, "installed", 0644);
++		ld->scripts   = apk_ostream_to_file(ld->fd, "scripts.tar", 0644);
++		ld->triggers  = apk_ostream_to_file(ld->fd, "triggers", 0644);
++	}
++
++	os = apk_ostream_to_file(db->root_fd, apk_world_file, 0644);
++	if (!IS_ERR(os)) {
++		apk_deps_write(db, db->world, os, APK_BLOB_PTR_LEN("\n", 1));
++		apk_ostream_write(os, "\n", 1);
++		r = apk_ostream_close(os);
++		if (!rr) rr = r;
++	}
++
++	list_for_each_entry(ipkg, &db->installed.packages, installed_pkgs_list) {
++		struct layer_data *ld = &layers[ipkg->pkg->layer];
++		if (!ld->fd) continue;
++		apk_db_fdb_write(db, ipkg, ld->installed);
++		apk_db_scriptdb_write(db, ipkg, ld->scripts);
++		apk_db_triggers_write(db, ipkg, ld->triggers);
++	}
++
++	for (i = 0; i < APK_DB_LAYER_NUM; i++) {
++		struct layer_data *ld = &layers[i];
++		if (!(db->active_layers & BIT(i))) continue;
++
++		if (!IS_ERR(ld->installed))
++			r = apk_ostream_close(ld->installed);
++		else	r = PTR_ERR(ld->installed);
++		if (!rr) rr = r;
++
++		if (!IS_ERR(ld->scripts)) {
++			apk_tar_write_entry(ld->scripts, NULL, NULL);
++			r = apk_ostream_close(ld->scripts);
++		} else	r = PTR_ERR(ld->scripts);
++		if (!rr) rr = r;
++
++		if (!IS_ERR(ld->triggers))
++			r = apk_ostream_close(ld->triggers);
++		else	r = PTR_ERR(ld->triggers);
++		if (!rr) rr = r;
++
++		close(ld->fd);
++	}
++	return rr;
++}
++
+ int apk_db_write_config(struct apk_database *db)
+ {
+ 	struct apk_out *out = &db->ctx->out;
+-	struct apk_ostream *os;
+ 	int r, rr = 0;
+ 
+ 	if ((db->ctx->flags & APK_SIMULATE) || db->ctx->root == NULL)
+@@ -1825,26 +1876,12 @@ int apk_db_write_config(struct apk_database *db)
+ 	if (db->write_arch)
+ 		apk_blob_to_file(db->root_fd, apk_arch_file, *db->arch, APK_BTF_ADD_EOL);
+ 
+-	os = apk_ostream_to_file(db->root_fd, apk_world_file, 0644);
+-	if (!IS_ERR(os)) {
+-		apk_deps_write(db, db->world, os, APK_BLOB_PTR_LEN("\n", 1));
+-		apk_ostream_write(os, "\n", 1);
+-		r = apk_ostream_close(os);
+-		if (r && !rr) rr = r;
+-	}
+-
+-	r = apk_db_write_fdb(db, apk_ostream_to_file(db->root_fd, apk_installed_file, 0644));
+-	if (r < 0 && !rr) rr = r;
+-
+-	r = apk_db_scriptdb_write(db, apk_ostream_to_file(db->root_fd, apk_scripts_file, 0644));
+-	if (r < 0 && !rr) rr = r;
++	r = apk_db_write_layers(db);
++	if (!rr ) rr = r;
+ 
+ 	r = apk_db_index_write_nr_cache(db);
+ 	if (r < 0 && !rr) rr = r;
+ 
+-	r = apk_db_triggers_write(db, apk_ostream_to_file(db->root_fd, apk_triggers_file, 0644));
+-	if (r < 0 && !rr) rr = r;
+-
+ 	if (rr) {
+ 		apk_err(out, "System state may be inconsistent: failed to write database: %s",
+ 			apk_error_str(rr));
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0003-db-sort-world-dependencies-to-layers.patch b/package/system/apk/patches/0003-db-sort-world-dependencies-to-layers.patch
new file mode 100644
index 0000000000..ec84a9cba9
--- /dev/null
+++ b/package/system/apk/patches/0003-db-sort-world-dependencies-to-layers.patch
@@ -0,0 +1,128 @@
+From b4760d4597cd1e1b567fc2883acede3d3c897c7d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
+Date: Sun, 6 Feb 2022 21:08:09 +0200
+Subject: [PATCH 03/11] db: sort world dependencies to layers
+
+---
+ src/apk_database.h |  1 +
+ src/apk_package.h  |  3 +++
+ src/database.c     | 13 +++++++++----
+ src/package.c      | 12 +++++++++---
+ src/solver.c       |  5 +++++
+ 5 files changed, 27 insertions(+), 7 deletions(-)
+
+diff --git a/src/apk_database.h b/src/apk_database.h
+index 88107d3..f0f6ba5 100644
+--- a/src/apk_database.h
++++ b/src/apk_database.h
+@@ -101,6 +101,7 @@ struct apk_name {
+ 	unsigned is_dependency : 1;
+ 	unsigned auto_select_virtual: 1;
+ 	unsigned priority : 2;
++	unsigned layer : 4;
+ 	unsigned int foreach_genid;
+ 	union {
+ 		struct apk_solver_name_state ss;
+diff --git a/src/apk_package.h b/src/apk_package.h
+index e7e0a53..8d9cba4 100644
+--- a/src/apk_package.h
++++ b/src/apk_package.h
+@@ -48,6 +48,7 @@ struct apk_dependency {
+ 	unsigned conflict : 1;
+ 	unsigned result_mask : 4;
+ 	unsigned fuzzy : 1;
++	unsigned layer : 4; // solver sets for 'world' dependencies only
+ };
+ APK_ARRAY(apk_dependency_array, struct apk_dependency);
+ 
+@@ -120,6 +121,8 @@ void apk_blob_push_deps(apk_blob_t *to, struct apk_database *, struct apk_depend
+ void apk_blob_pull_dep(apk_blob_t *from, struct apk_database *, struct apk_dependency *);
+ void apk_blob_pull_deps(apk_blob_t *from, struct apk_database *, struct apk_dependency_array **);
+ 
++int apk_deps_write_layer(struct apk_database *db, struct apk_dependency_array *deps,
++			 struct apk_ostream *os, apk_blob_t separator, unsigned layer);
+ int apk_deps_write(struct apk_database *db, struct apk_dependency_array *deps,
+ 		   struct apk_ostream *os, apk_blob_t separator);
+ 
+diff --git a/src/database.c b/src/database.c
+index 23e366e..80d3d8c 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -1807,11 +1807,16 @@ static int apk_db_write_layers(struct apk_database *db)
+ 		ld->installed = apk_ostream_to_file(ld->fd, "installed", 0644);
+ 		ld->scripts   = apk_ostream_to_file(ld->fd, "scripts.tar", 0644);
+ 		ld->triggers  = apk_ostream_to_file(ld->fd, "triggers", 0644);
+-	}
+ 
+-	os = apk_ostream_to_file(db->root_fd, apk_world_file, 0644);
+-	if (!IS_ERR(os)) {
+-		apk_deps_write(db, db->world, os, APK_BLOB_PTR_LEN("\n", 1));
++		if (i == 0)
++			os = apk_ostream_to_file(db->root_fd, apk_world_file, 0644);
++		else
++			os = apk_ostream_to_file(ld->fd, "world", 0644);
++		if (IS_ERR(os)) {
++			if (!rr) rr = PTR_ERR(os);
++			continue;
++		}
++		apk_deps_write_layer(db, db->world, os, APK_BLOB_PTR_LEN("\n", 1), i);
+ 		apk_ostream_write(os, "\n", 1);
+ 		r = apk_ostream_close(os);
+ 		if (!rr) rr = r;
+diff --git a/src/package.c b/src/package.c
+index eef5dd5..cc86192 100644
+--- a/src/package.c
++++ b/src/package.c
+@@ -423,7 +423,7 @@ void apk_blob_push_deps(apk_blob_t *to, struct apk_database *db, struct apk_depe
+ 	}
+ }
+ 
+-int apk_deps_write(struct apk_database *db, struct apk_dependency_array *deps, struct apk_ostream *os, apk_blob_t separator)
++int apk_deps_write_layer(struct apk_database *db, struct apk_dependency_array *deps, struct apk_ostream *os, apk_blob_t separator, unsigned layer)
+ {
+ 	apk_blob_t blob;
+ 	char tmp[256];
+@@ -433,9 +433,10 @@ int apk_deps_write(struct apk_database *db, struct apk_dependency_array *deps, s
+ 		return 0;
+ 
+ 	for (i = 0; i < deps->num; i++) {
++		if (layer != -1 && deps->item[i].layer != layer) continue;
++
+ 		blob = APK_BLOB_BUF(tmp);
+-		if (i)
+-			apk_blob_push_blob(&blob, separator);
++		if (n) apk_blob_push_blob(&blob, separator);
+ 		apk_blob_push_dep(&blob, db, &deps->item[i]);
+ 
+ 		blob = apk_blob_pushed(APK_BLOB_BUF(tmp), blob);
+@@ -449,6 +450,11 @@ int apk_deps_write(struct apk_database *db, struct apk_dependency_array *deps, s
+ 	return n;
+ }
+ 
++int apk_deps_write(struct apk_database *db, struct apk_dependency_array *deps, struct apk_ostream *os, apk_blob_t separator)
++{
++	return apk_deps_write_layer(db, deps, os, separator, -1);
++}
++
+ void apk_dep_from_adb(struct apk_dependency *dep, struct apk_database *db, struct adb_obj *d)
+ {
+ 	*dep = (struct apk_dependency) {
+diff --git a/src/solver.c b/src/solver.c
+index 2ea7f3f..3283659 100644
+--- a/src/solver.c
++++ b/src/solver.c
+@@ -1093,6 +1093,11 @@ restart:
+ 		goto restart;
+ 	}
+ 
++	foreach_array_item(d, world) {
++		if (!d->name->ss.chosen.pkg) continue;
++		d->layer = d->name->ss.chosen.pkg->layer;
++	}
++
+ 	apk_hash_foreach(&db->available.names, free_name, NULL);
+ 	apk_hash_foreach(&db->available.packages, free_package, NULL);
+ 	dbg_printf("solver done, errors=%d\n", ss->errors);
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0004-adb-add-layer-to-pkginfo.patch b/package/system/apk/patches/0004-adb-add-layer-to-pkginfo.patch
new file mode 100644
index 0000000000..c27ff1c2de
--- /dev/null
+++ b/package/system/apk/patches/0004-adb-add-layer-to-pkginfo.patch
@@ -0,0 +1,52 @@
+From 18f423520473e6c906b28c07c66a1c46dce0bafc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
+Date: Sun, 6 Feb 2022 21:15:38 +0200
+Subject: [PATCH 04/11] adb: add layer to pkginfo
+
+---
+ src/apk_adb.c | 1 +
+ src/apk_adb.h | 3 ++-
+ src/package.c | 1 +
+ 3 files changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/src/apk_adb.c b/src/apk_adb.c
+index 37206f0..ea27a4d 100644
+--- a/src/apk_adb.c
++++ b/src/apk_adb.c
+@@ -412,6 +412,7 @@ const struct adb_object_schema schema_pkginfo = {
+ 		ADB_FIELD(ADBI_PI_REPLACES,	"replaces",	schema_dependency_array),
+ 		ADB_FIELD(ADBI_PI_INSTALL_IF,	"install-if",	schema_dependency_array),
+ 		ADB_FIELD(ADBI_PI_RECOMMENDS,	"recommends",	schema_dependency_array),
++		ADB_FIELD(ADBI_PI_LAYER,	"layer",	scalar_int),
+ 	},
+ };
+ 
+diff --git a/src/apk_adb.h b/src/apk_adb.h
+index 68bc92d..5b8283c 100644
+--- a/src/apk_adb.h
++++ b/src/apk_adb.h
+@@ -31,7 +31,8 @@
+ #define ADBI_PI_REPLACES	0x11
+ #define ADBI_PI_INSTALL_IF	0x12
+ #define ADBI_PI_RECOMMENDS	0x13
+-#define ADBI_PI_MAX		0x14
++#define ADBI_PI_LAYER		0x14
++#define ADBI_PI_MAX		0x15
+ 
+ /* ACL entries */
+ #define ADBI_ACL_MODE		0x01
+diff --git a/src/package.c b/src/package.c
+index cc86192..5aee917 100644
+--- a/src/package.c
++++ b/src/package.c
+@@ -611,6 +611,7 @@ void apk_pkg_from_adb(struct apk_database *db, struct apk_package *pkg, struct a
+ 	pkg->maintainer = apk_atomize_dup(&db->atoms, adb_ro_blob(pkginfo, ADBI_PI_MAINTAINER));
+ 	pkg->build_time = adb_ro_int(pkginfo, ADBI_PI_BUILD_TIME);
+ 	pkg->commit = commit_id(adb_ro_blob(pkginfo, ADBI_PI_REPO_COMMIT));
++	pkg->layer = adb_ro_int(pkginfo, ADBI_PI_LAYER);
+ 
+ 	apk_deps_from_adb(&pkg->depends, db, adb_ro_obj(pkginfo, ADBI_PI_DEPENDS, &obj));
+ 	apk_deps_from_adb(&pkg->provides, db, adb_ro_obj(pkginfo, ADBI_PI_PROVIDES, &obj));
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0005-solver-require-package-layer-to-be-enabled-for-insta.patch b/package/system/apk/patches/0005-solver-require-package-layer-to-be-enabled-for-insta.patch
new file mode 100644
index 0000000000..dea6cac4e8
--- /dev/null
+++ b/package/system/apk/patches/0005-solver-require-package-layer-to-be-enabled-for-insta.patch
@@ -0,0 +1,45 @@
+From 9dd5dfbe95ae9d1bbff60633716ea34fa43357d4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
+Date: Sun, 6 Feb 2022 21:37:31 +0200
+Subject: [PATCH 05/11] solver: require package layer to be enabled for install
+
+---
+ src/commit.c | 3 +++
+ src/solver.c | 7 ++++---
+ 2 files changed, 7 insertions(+), 3 deletions(-)
+
+diff --git a/src/commit.c b/src/commit.c
+index 6130f36..42280aa 100644
+--- a/src/commit.c
++++ b/src/commit.c
+@@ -425,6 +425,9 @@ static void print_pinning_errors(struct print_state *ps, struct apk_package *pkg
+ 	if (!(pkg->repos & db->available_repos)) {
+ 		label_start(ps, "masked in:");
+ 		apk_print_indented_fmt(&ps->i, "--no-network");
++	} else if (!(BIT(pkg->layer) & db->active_layers)) {
++		label_start(ps, "masked in:");
++		apk_print_indented_fmt(&ps->i, "layer");
+ 	} else if (pkg->repos == BIT(APK_REPOSITORY_CACHED) && !pkg->filename) {
+ 		label_start(ps, "masked in:");
+ 		apk_print_indented_fmt(&ps->i, "cache");
+diff --git a/src/solver.c b/src/solver.c
+index 3283659..fc73642 100644
+--- a/src/solver.c
++++ b/src/solver.c
+@@ -198,9 +198,10 @@ static void discover_name(struct apk_solver_state *ss, struct apk_name *name)
+ 			/* Package is in 'cached' repository if filename is provided,
+ 			 * or it's a 'virtual' package with install_size zero */
+ 			pkg->ss.pkg_selectable =
+-				(pkg->repos & db->available_repos) ||
+-				pkg->cached_non_repository ||
+-				pkg->ipkg;
++				(BIT(pkg->layer) & db->active_layers) &&
++				((pkg->repos & db->available_repos) ||
++				  pkg->cached_non_repository ||
++				  pkg->ipkg);
+ 
+ 			/* Prune install_if packages that are no longer available,
+ 			 * currently works only if SOLVERF_AVAILABLE is set in the
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0006-change-naming-schema-to-name-_-version-.apk.patch b/package/system/apk/patches/0006-change-naming-schema-to-name-_-version-.apk.patch
new file mode 100644
index 0000000000..d8fbd69a17
--- /dev/null
+++ b/package/system/apk/patches/0006-change-naming-schema-to-name-_-version-.apk.patch
@@ -0,0 +1,61 @@
+From 1ea102a60b26fd831926de7964a6b881fc941954 Mon Sep 17 00:00:00 2001
+From: Paul Spooren <mail@aparcar.org>
+Date: Tue, 1 Feb 2022 09:30:20 +0100
+Subject: [PATCH 06/11] change naming schema to <name>_<version>.apk
+
+OpenWrt allows dashes in package names but no underlines. The current
+cleanup mechanism in the build system uses those underlines to find
+suiting packages to cleanup via `<pkgname>_*.apk`.
+
+Signed-off-by: Paul Spooren <mail@aparcar.org>
+---
+ src/apk_package.h | 2 +-
+ src/app_mkpkg.c   | 2 +-
+ src/database.c    | 4 ++--
+ 3 files changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/src/apk_package.h b/src/apk_package.h
+index 8d9cba4..eb97095 100644
+--- a/src/apk_package.h
++++ b/src/apk_package.h
+@@ -102,7 +102,7 @@ APK_ARRAY(apk_package_array, struct apk_package *);
+ #define APK_PROVIDER_FROM_PACKAGE(pkg)	  (struct apk_provider){(pkg),(pkg)->version}
+ #define APK_PROVIDER_FROM_PROVIDES(pkg,p) (struct apk_provider){(pkg),(p)->version}
+ 
+-#define PKG_VER_FMT		"%s-" BLOB_FMT
++#define PKG_VER_FMT		"%s_" BLOB_FMT
+ #define PKG_VER_PRINTF(pkg)	pkg->name->name, BLOB_PRINTF(*pkg->version)
+ #define PKG_FILE_FMT		PKG_VER_FMT ".apk"
+ #define PKG_FILE_PRINTF(pkg)	PKG_VER_PRINTF(pkg)
+diff --git a/src/app_mkpkg.c b/src/app_mkpkg.c
+index afbc150..731acd5 100644
+--- a/src/app_mkpkg.c
++++ b/src/app_mkpkg.c
+@@ -213,7 +213,7 @@ static char *pkgi_filename(struct adb_obj *pkgi, char *buf, size_t n)
+ {
+ 	apk_blob_t to = APK_BLOB_PTR_LEN(buf, n);
+ 	apk_blob_push_blob(&to, adb_ro_blob(pkgi, ADBI_PI_NAME));
+-	apk_blob_push_blob(&to, APK_BLOB_STR("-"));
++	apk_blob_push_blob(&to, APK_BLOB_STR("_"));
+ 	apk_blob_push_blob(&to, adb_ro_blob(pkgi, ADBI_PI_VERSION));
+ 	apk_blob_push_blob(&to, APK_BLOB_STR(".apk"));
+ 	apk_blob_push_blob(&to, APK_BLOB_PTR_LEN("", 1));
+diff --git a/src/database.c b/src/database.c
+index 80d3d8c..9e6a978 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -561,9 +561,9 @@ struct apk_package *apk_db_pkg_add(struct apk_database *db, struct apk_package *
+ 
+ static int apk_pkg_format_cache_pkg(apk_blob_t to, struct apk_package *pkg)
+ {
+-	/* pkgname-1.0_alpha1.12345678.apk */
++	/* pkgname_1.0_alpha1.12345678.apk */
+ 	apk_blob_push_blob(&to, APK_BLOB_STR(pkg->name->name));
+-	apk_blob_push_blob(&to, APK_BLOB_STR("-"));
++	apk_blob_push_blob(&to, APK_BLOB_STR("_"));
+ 	apk_blob_push_blob(&to, *pkg->version);
+ 	apk_blob_push_blob(&to, APK_BLOB_STR("."));
+ 	apk_blob_push_hexdump(&to, APK_BLOB_PTR_LEN((char *) pkg->csum.data,
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0007-package-store-scripts-in-tmp.patch b/package/system/apk/patches/0007-package-store-scripts-in-tmp.patch
new file mode 100644
index 0000000000..603ff6ea73
--- /dev/null
+++ b/package/system/apk/patches/0007-package-store-scripts-in-tmp.patch
@@ -0,0 +1,41 @@
+From c2176a24105a56c3c9cc2beaa9da6934e6667ffe Mon Sep 17 00:00:00 2001
+From: Paul Spooren <mail@aparcar.org>
+Date: Thu, 9 Dec 2021 06:14:27 -1000
+Subject: [PATCH 07/11] package: store scripts in tmp
+
+Signed-off-by: Paul Spooren <mail@aparcar.org>
+---
+ src/package.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/src/package.c b/src/package.c
+index 5aee917..2a4d80e 100644
+--- a/src/package.c
++++ b/src/package.c
+@@ -799,7 +799,7 @@ void apk_ipkg_run_script(struct apk_installed_package *ipkg,
+ 	argv[0] = (char *) apk_script_types[type];
+ 
+ 	/* Avoid /tmp as it can be mounted noexec */
+-	snprintf(fn, sizeof(fn), "var/cache/misc/" PKG_VER_FMT ".%s",
++	snprintf(fn, sizeof(fn), "tmp/cache/misc/" PKG_VER_FMT ".%s",
+ 		PKG_VER_PRINTF(pkg),
+ 		apk_script_types[type]);
+ 
+@@ -811,10 +811,10 @@ void apk_ipkg_run_script(struct apk_installed_package *ipkg,
+ 		if (faccessat(db->root_fd, "tmp", F_OK, 0) != 0)
+ 			mkdirat(db->root_fd, "tmp", 01777);
+ 		make_device_tree(db);
+-		if (faccessat(db->root_fd, "var/cache/misc", F_OK, 0) != 0) {
+-			mkdirat(root_fd, "var", 0755);
+-			mkdirat(root_fd, "var/cache", 0755);
+-			mkdirat(root_fd, "var/cache/misc", 0755);
++		if (faccessat(db->root_fd, "tmp/cache/misc", F_OK, 0) != 0) {
++			mkdirat(root_fd, "tmp", 0755);
++			mkdirat(root_fd, "tmp/cache", 0755);
++			mkdirat(root_fd, "tmp/cache/misc", 0755);
+ 		}
+ 	}
+ 
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0008-context-fix-uvol-default-path.patch b/package/system/apk/patches/0008-context-fix-uvol-default-path.patch
new file mode 100644
index 0000000000..54b26865f4
--- /dev/null
+++ b/package/system/apk/patches/0008-context-fix-uvol-default-path.patch
@@ -0,0 +1,29 @@
+From 6e628f6e0b7588f4d6f0b9e8cb1773c6b1d7b183 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 17 Dec 2021 19:09:42 +0000
+Subject: [PATCH 08/11] context: fix 'uvol' default path
+
+'uvol' is installed to /usr/sbin by default. Assume that path if not
+set by APK_UVOL environment variable.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ src/context.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/src/context.c b/src/context.c
+index 3a806db..400e09b 100644
+--- a/src/context.c
++++ b/src/context.c
+@@ -50,7 +50,7 @@ int apk_ctx_prepare(struct apk_ctx *ac)
+ 		ac->flags |= APK_NO_CHROOT;
+ 
+ 		// Check uvol availability
+-		ac->uvol = getenv("APK_UVOL") ?: "/usr/bin/uvol";
++		ac->uvol = getenv("APK_UVOL") ?: "/usr/sbin/uvol";
+ 		if (access(ac->uvol, X_OK) != 0)
+ 			ac->uvol = ERR_PTR(-APKE_UVOL_NOT_AVAILABLE);
+ 	} else {
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0009-fs_uvol-take-down-volume-before-removal.patch b/package/system/apk/patches/0009-fs_uvol-take-down-volume-before-removal.patch
new file mode 100644
index 0000000000..ba09800500
--- /dev/null
+++ b/package/system/apk/patches/0009-fs_uvol-take-down-volume-before-removal.patch
@@ -0,0 +1,37 @@
+From 4c7072f5e0e3ee11b15d5f0e2d39c41036e55bfe Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Fri, 17 Dec 2021 19:10:38 +0000
+Subject: [PATCH 09/11] fs_uvol: take down volume before removal
+
+Make sure volume is in 'down' state before attempting to remove it.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ src/fs_uvol.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/src/fs_uvol.c b/src/fs_uvol.c
+index ec6fc35..d00cdc8 100644
+--- a/src/fs_uvol.c
++++ b/src/fs_uvol.c
+@@ -128,6 +128,7 @@ static int uvol_file_control(struct apk_fsdir *d, apk_blob_t filename, int ctrl)
+ 	struct apk_ctx *ac = d->ac;
+ 	struct apk_pathbuilder pb;
+ 	const char *uvol_name;
++	int r;
+ 
+ 	if (IS_ERR(ac->uvol)) return PTR_ERR(ac->uvol);
+ 
+@@ -140,6 +141,9 @@ static int uvol_file_control(struct apk_fsdir *d, apk_blob_t filename, int ctrl)
+ 	case APK_FS_CTRL_APKNEW:
+ 	case APK_FS_CTRL_CANCEL:
+ 	case APK_FS_CTRL_DELETE:
++		r = uvol_run(ac, "down", uvol_name, 0, 0);
++		if (r)
++			return r;
+ 		return uvol_run(ac, "remove", uvol_name, 0, 0);
+ 	default:
+ 		return -APKE_UVOL_ERROR;
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0010-support-new-index-format-without-attaching-arch.patch b/package/system/apk/patches/0010-support-new-index-format-without-attaching-arch.patch
new file mode 100644
index 0000000000..80a0c94f19
--- /dev/null
+++ b/package/system/apk/patches/0010-support-new-index-format-without-attaching-arch.patch
@@ -0,0 +1,63 @@
+From 8d6aa115d8964ba6b3aa3d4d39c2ec2bda6acc15 Mon Sep 17 00:00:00 2001
+From: Paul Spooren <mail@aparcar.org>
+Date: Tue, 1 Feb 2022 10:18:16 +0100
+Subject: [PATCH 10/11] support new index format without attaching arch
+
+By default the package architecture is attached to the repository url.
+With this commit it is possible to define new indexes ending on `.adb`.
+If such index file is detected the packages must be in the same folder
+as the index.
+
+Signed-off-by: Paul Spooren <mail@aparcar.org>
+---
+ src/database.c | 28 ++++++++++++++++++++--------
+ 1 file changed, 20 insertions(+), 8 deletions(-)
+
+diff --git a/src/database.c b/src/database.c
+index 9e6a978..5198bad 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -591,20 +591,32 @@ int apk_repo_format_real_url(apk_blob_t *default_arch, struct apk_repository *re
+ 			     struct apk_package *pkg, char *buf, size_t len,
+ 			     struct apk_url_print *urlp)
+ {
++
++	apk_blob_t uri = APK_BLOB_STR(repo->url);
+ 	apk_blob_t arch;
+ 	int r;
+ 
+ 	if (pkg && pkg->arch) arch = *pkg->arch;
+ 	else arch = *default_arch;
+ 
+-	if (pkg != NULL)
+-		r = snprintf(buf, len, "%s%s" BLOB_FMT "/"  PKG_FILE_FMT,
+-			     repo->url, repo->url[strlen(repo->url)-1] == '/' ? "" : "/",
+-			     BLOB_PRINTF(arch), PKG_FILE_PRINTF(pkg));
+-	else
+-		r = snprintf(buf, len, "%s%s" BLOB_FMT "/%s",
+-			     repo->url, repo->url[strlen(repo->url)-1] == '/' ? "" : "/",
+-			     BLOB_PRINTF(arch), apkindex_tar_gz);
++	if (apk_blob_ends_with(uri, APK_BLOB_STR(".adb"))) {
++		if (pkg != NULL) {
++			apk_blob_rsplit(uri, '/', &uri, NULL);
++			r = snprintf(buf, len, BLOB_FMT "/" PKG_FILE_FMT,
++				BLOB_PRINTF(uri), PKG_FILE_PRINTF(pkg));
++		} else {
++			r = snprintf(buf, len, BLOB_FMT, BLOB_PRINTF(uri));
++		}
++	} else {
++		apk_blob_push_fmt(&uri, "/" BLOB_FMT, BLOB_PRINTF(arch));
++		if (pkg != NULL)
++			r = snprintf(buf, len, BLOB_FMT "/" BLOB_FMT "/" PKG_FILE_FMT,
++				BLOB_PRINTF(uri), BLOB_PRINTF(arch), PKG_FILE_PRINTF(pkg));
++		else
++			r = snprintf(buf, len, BLOB_FMT "/" BLOB_FMT "/%s",
++				BLOB_PRINTF(uri), BLOB_PRINTF(arch), apkindex_tar_gz);
++	}
++
+ 	if (r >= len)
+ 		return -ENOBUFS;
+ 
+-- 
+2.35.1
+
diff --git a/package/system/apk/patches/0011-Don-t-create-cache-folder-with-no-cache.patch b/package/system/apk/patches/0011-Don-t-create-cache-folder-with-no-cache.patch
new file mode 100644
index 0000000000..231b9c62e4
--- /dev/null
+++ b/package/system/apk/patches/0011-Don-t-create-cache-folder-with-no-cache.patch
@@ -0,0 +1,49 @@
+From bda8e08c6c43963d25d714f28a2d367922ba4c02 Mon Sep 17 00:00:00 2001
+From: Paul Spooren <mail@aparcar.org>
+Date: Sun, 13 Feb 2022 18:56:28 +0100
+Subject: [PATCH 11/11] Don't create cache folder with --no-cache
+
+Prevent the --initdb command to create cache folder if it's explicitly
+disabled. This is relevant since other tooling may provide the /var
+folder, specifically in OpenWrt it's a symlink to /tmp/
+
+Signed-off-by: Paul Spooren <mail@aparcar.org>
+---
+ src/database.c | 14 +++++++++-----
+ 1 file changed, 9 insertions(+), 5 deletions(-)
+
+diff --git a/src/database.c b/src/database.c
+index 5198bad..6bd80f5 100644
+--- a/src/database.c
++++ b/src/database.c
+@@ -1720,9 +1720,11 @@ int apk_db_open(struct apk_database *db, struct apk_ctx *ac)
+ 			     add_protected_paths_from_file, db);
+ 
+ 	/* figure out where to have the cache */
+-	if ((r = setup_cache(db, ac)) < 0) {
+-		apk_err(out, "Unable to remount cache read/write");
+-		goto ret_r;
++	if (!(db->ctx->flags & APK_NO_CACHE)) {
++		if ( (r = setup_cache(db, ac)) < 0) {
++			apk_err(out, "Unable to remount cache read/write");
++			goto ret_r;
++		}
+ 	}
+ 
+ 	if (db->ctx->flags & APK_OVERLAY_FROM_STDIN) {
+@@ -1896,8 +1898,10 @@ int apk_db_write_config(struct apk_database *db)
+ 	r = apk_db_write_layers(db);
+ 	if (!rr ) rr = r;
+ 
+-	r = apk_db_index_write_nr_cache(db);
+-	if (r < 0 && !rr) rr = r;
++	if (!(db->ctx->flags & APK_NO_CACHE)) {
++		r = apk_db_index_write_nr_cache(db);
++		if (r < 0 && !rr) rr = r;
++	}
+ 
+ 	if (rr) {
+ 		apk_err(out, "System state may be inconsistent: failed to write database: %s",
+-- 
+2.35.1
+
-- 
2.35.1

